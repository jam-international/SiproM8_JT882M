<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<plcProject caseSensitive="false" useCustomWorkspace="false" debugMode="false" extcheck="true" SFCControl="false" strictPointerCheck="false" strictEnumsCheck="false" copyWarningThreshold="200" version="2.7" useLD2="false" useXPLCFiles="false" useFBMethods="false">
	<image>Cuci.imgx</image>
	<commSettings>SiaxProComm:0,1000,T#TCPIP:192.168.0.92/12003,5000</commSettings>
	<sources>
		<main>
			<resources>
				<resource name="SiaxM32" processor="ColdFire">
					<task name="Main" interval="t#0us" priority="0" type="cyclic" hidden="false" dynamic="false" descr=""/>
					<task name="Boot" interval="t#0us" priority="1" type="cyclic" hidden="false" dynamic="false" descr=""/>
					<task name="RtcAx" interval="t#0us" priority="2" type="cyclic" hidden="false" dynamic="false" descr=""/>
				</resource>
			</resources>
			<tasks>
				<task name="Main">
					<program>Emergenze</program>
					<program>AppMainC3</program>
					<program>C1_LoadUdf</program>
					<program>C1_Camme</program>
					<program>C1_Cucitrice</program>
					<program>C1_AppMacchina</program>
					<program>C2_LoadUdf</program>
					<program>C2_Camme</program>
					<program>C2_Cucitrice</program>
					<program>C2_AppMacchina</program>
					<program>Piegatore</program>
					<program>Uscite</program>
					<program>RitSensori</program>
					<program>AppMainC1</program>
					<program>AppMainC2</program>
					<program>Caricatore</program>
					<program>Scaricatore</program>
					<program>Param_Delta</program>
					<program>OutAnalogicheT1</program>
					<program>OutAnalogicheT2</program>
					<program>OpCodeT1</program>
					<program>OpCodeT2</program>
					<program>TestManutenzione</program>
					<program>ComandiHMI</program>
					<program>RotturaFilo_Spola_C1</program>
					<program>RotturaFilo_Spola_C2</program>
					<program>Contatori</program>
					<program>Timeout_Sensori</program>
					<program>CariactorePattine</program>
				</task>
				<task name="Boot">
					<program>Boot</program>
					<program>C1_Boot</program>
					<program>C2_Boot</program>
				</task>
				<task name="RtcAx">
					<program>C1_CuciRtc</program>
					<program>C2_CuciRtc</program>
				</task>
			</tasks>
			<globalVars>
				<group name="Ungrouped_vars" excludeFromBuild="FALSE">
					<var name="vret" type="DINT"/>
					<var name="EnbAutomatico" type="BOOL"/>
					<var name="FallEnbAutomatico" type="FallEdge"/>
					<var name="RiseEnbAutomatico" type="RiseEdge"/>
					<var name="EnbManuale" type="BOOL"/>
					<var name="FallEnbManuale" type="FallEdge"/>
					<var name="RiseEnbManuale" type="RiseEdge"/>
					<var name="ResetPrimoCiclo" type="BOOL"/>
					<var name="Rise_i1_Pulsanti_start" type="RiseEdge"/>
					<var name="Rise_Vb4511_AppEnbCaricatore" type="RiseEdge"/>
					<var name="Fall_Vb4511_AppEnbCaricatore" type="FallEdge"/>
					<var name="Rise_Vb4509_AppEnbPiegatore" type="RiseEdge"/>
					<var name="Fall_Vb4509_AppEnbPiegatore" type="FallEdge"/>
					<var name="Rise_Vb4513_AppEnbCucitrice2" type="RiseEdge"/>
					<var name="Fall_Vb4513_AppEnbCucitrice2" type="FallEdge"/>
					<var name="MoveAsseY_C2_ON" type="BOOL"/>
					<var name="EnbMoveAsseY_C2_ON" type="BOOL"/>
					<var name="ResetEmgOFF" type="FallEdge"/>
					<var name="RitResetEmgOFF" type="Toff"/>
					<var name="AssiFermi" type="BOOL"/>
					<var name="AssiFermiC1" type="BOOL"/>
					<var name="AssiFermiC2" type="BOOL"/>
					<var name="AssiFermiC3" type="BOOL"/>
					<var name="ipar" type="INT"/>
					<var name="iparRtcAx" type="INT"/>
					<var name="PiegatoreStaSalendo" type="BOOL"/>
				</group>
			</globalVars>
			<retainVars>
				<group name="Ungrouped_vars" excludeFromBuild="FALSE"/>
			</retainVars>
			<constantVars>
				<group name="Ungrouped_vars" excludeFromBuild="FALSE"/>
			</constantVars>
			<iecVarsDeclaration>
				<group name="Ungrouped_vars">
					<iecDeclaration active="FALSE"/>
				</group>
			</iecVarsDeclaration>
			<functions/>
			<functionBlocks/>
			<programs>
				<program name="Emergenze" version="1.0.0" creationDate="0" lastModifiedDate="1715351205" excludeFromBuild="FALSE">
					<vars>
						<localVars>
							<var name="Rise_ciclo_emergenza_attivata" type="RiseEdge"/>
							<var name="Rise_Emg_pressostato" type="RiseEdge"/>
							<var name="Rit_Driver" type="Ton"/>
							<var name="Rise_AllarmeDriver_X" type="RiseEdge"/>
							<var name="Rise_AllarmeDriver_Y" type="RiseEdge"/>
							<var name="Rise_Valvolone" type="RiseEdge"/>
							<var name="Ciclo_emergenza_attivata" type="BOOL"/>
							<var name="VcdIdxOP" type="INT"/>
							<var name="Rise_i21_Emg" type="RiseEdge"/>
							<var name="Riti35_Pressostato" type="Ton"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[(* ========================================================================== 
(* SIPRO - Siax M															  	
(*                                                                            
(* COMPANY:     JAM INTERNATIONAL                                             
(*                                                                            
(* NAME: Emergenze                                                          
(*
(* TASK MAIN	 
(*
(* DESCRIPTION: Emergenze 
(*
(*                                                                             
(* NOTE:                                NAME:           VER:    DATE:         
(* -------------------------------------------------------------------------  
(* Prima stesura                        Jam             1.0     29/04/2021    
(* Ultima modifica                                                            
(* ========================================================================== *)


	(* Ingresso di emergenza - ritardato per PLC sicurezza *)
RitResetEmgOFF ( in := i21_Emg , pt := 100) ;					
ResetEmgOFF( in := RitResetEmgOFF.q );
	
	(* Emergenza *)			
if ( ResetEmgOFF.q or ResetPrimoCiclo )then
		(* Set Emergenza *)					
	vret := ExecPlcFun( PLC_SET_EMERGENZA, 2, 0 );
	Ciclo_emergenza_attivata := TRUE;
end_if;
Rise_ciclo_emergenza_attivata (in :=Ciclo_emergenza_attivata);

if(Rise_ciclo_emergenza_attivata.q) then
	Ciclo_emergenza_attivata := FALSE;
		
		(* Forza tutti gli assi non azzerati *)
	vret := ExecPlcFun( PLC_FORCE_ZEROED, 0, 0 );	

		(* Sgancia inseguimento gantry *)
	C1_CmdSganciaCrochet := TRUE;		(* Sgancia inseguimento crochet 1 *)
	C2_CmdSganciaCrochet := TRUE;		(* Sgancia inseguimento crochet 2 *)

		(* reset piegatori *)
	Vb4025_Piegatore1_OFF := TRUE ;
	Vb4026_Piegatore2_OFF := TRUE ;
	Vb4027_Piegatore3_OFF := TRUE ;
	Vb4028_Piegatore4_OFF := TRUE ;		
	Vb4033_RitardoAvanzataCaricatore:= FALSE ;	
 
		(* reset varie *)
 	Vb7_TestManutRun		   := FALSE ;
 	Vb9_ChiudePiegatore4	   := FALSE ;
 	Vb11_StepResetCanale3_1	   := FALSE ;
 	Vb52RichiestaZeroAxDaHmiC1 := FALSE ;
 	Vb53RichiestaZeroAxDaHmiC2 := FALSE ;
 	Vb76EnableCucitureInfinite_C1 := FALSE;
 	Vb4003_RqsStopPiegatore:= FALSE;
 
 	Vb4078_TestHomeC1				 := FALSE ;
 	Vb4079_TestHomeC2 				 := FALSE ;
 	Vb4080_TestFcZeroC1				 := FALSE ;
 	Vb4081_TestCaricatorePinzaC1	 := FALSE ;	     
 	Vb4082_TestCaricatoreLanciaC1	 := FALSE ;	   
 	Vb4083_TestCaricatoreC2CaricoC1	 := FALSE ;	 
 	Vb4084_TestCaricatoreC2ScaricoC2 := FALSE ;
 	Vb4085_TestFcZeroC2				 := FALSE ;
 	Vb4086_SavePosizioni			 := FALSE ;
 	Vb4805_AppStartCaricatoreC1		 := FALSE ;
 	C1_ReloadParam					 := TRUE ;(* forzo la rilettura dei programmi*)
 	C2_ReloadParam			 		 := TRUE ;(* forzo la rilettura dei programmi*)
	C1_CuciSimulaAuto				:= FALSE ;
	Vb30_C1_InCucitura				:= FALSE;
	Vb31_C2_InCucitura				:= FALSE;
	Vb4807_PinzeAlteDopoPC			:= TRUE ;(* dopo home alzo le pinze*)
	Vb4907_PinzeAlteDopoPCC2		:= TRUE ;(* dopo home alzo le pinze*)
	Vb4018_TrigrHMITascaCucita := FALSE;	(*TCP 4.0*)	
	Vn200_Tipo_DXSX_Ultima_cucita_su_C1 :=0;
	
	(* azzera OPT *)


	
	Vb36_Clear_OPT1 := TRUE;
	Vb37_Clear_OPT2 := TRUE;
	Vb38_Clear_OPT3 := TRUE;
		

		(* azzera vn fork *)
 	Vn201PrgForkPiegatore:= 0 ;		
 	Vn201PrgForkPiegatore:= 0 ;		
 	Vn202PrgForkCaricatoreMan:= 0 ;		
 	Vn202PrgForkCaricatoreMan:= 0 ;		
 	Vn203PrgForkResetFolder:= 0 ;
 	Vn203PrgForkResetFolder:= 0 ;

		(* reset appoggio vb uscite manuale *)
	Vb4133_AppMan_o1_Piegatore_1 		  	:= FALSE ;  						
	Vb4134_AppMan_o2_Piegatore_2  		  	:= FALSE ;    				
	Vb4135_AppMan_o3_Piegatore_3  		  	:= FALSE ; 
	Vb4136_AppMan_o4_Piegatore_4    	    := FALSE ;  
	Vb4137_AppMan_o5_Cambio_corpo			:= FALSE ;	
	Vb4138_AppMan_o6_Cambio_lama_front   	:= FALSE ;  		    				 		
	Vb4139_AppMan_o7_Cambio_lame_lateral 	:= FALSE ;    		
 	Vb4140_AppMan_o8_Cambio_Lamelle_4_5    	:= FALSE ;    		   		  
	Vb4141_AppMan_o9_Lancia_AD         		:= FALSE ;  	  
	Vb4142_AppMan_o10_Piegatore_AD      	:= FALSE ;     		  
	Vb4143_AppMan_o11_Piegatore_Su_Giu    	:= FALSE ;    		  
	Vb4144_AppMan_o12_Bilanciere_Su_Giu   	:= FALSE ;     		  
	Vb4145_AppMan_o13_Lancia_Cargo_Aperta	:= FALSE ; 
	Vb4146_AppMan_o14_C1_rasafilo         	:= FALSE ; 
	Vb4147_AppMan_o15_EvAspiratore   		:= FALSE ;
	Vb4148_AppMan_o16_Lancia_Cargo_Chiusa	:= FALSE ;
	Vb4149_AppMan_o17_C1_Piedino          	:= FALSE ;			      
	Vb4150_AppMan_o18_C1_Pinza_int        	:= FALSE ; 			      
	Vb4151_AppMan_o19_C1_Pinza_est        	:= FALSE ;   		     
	Vb4152_AppMan_o20_C1_Retrattile_AC    	:= FALSE ;    		   
	Vb4153_AppMan_o21_C1_RaffreddamentoAgo	:= FALSE ;  
	//22 
	Vb4155_AppMan_o23_Lentezza_Tasca_AD   	:= FALSE ; 	 		   		 
	Vb4156_AppMan_o24_Pinza_carico_Su_Giu 	:= FALSE ;       	
	Vb4157_AppMan_o25_C1_Cambio_Pinze     	:= FALSE ;       	
	Vb4158_AppMan_o26_C1_Scalino_Piedino  	:= FALSE ;      	
	Vb4159_AppMan_o27_C1_Ranocchia_retrat 	:= FALSE ;      	
 	//28
 	//29
 	//30
 	Vb4163_AppMan_o31_C1_bloccaFiloMagente	:= FALSE ;  
 	Vb4164_AppMan_o32_Enable_AssiXY_C1		:=FALSE; 
 	//
 	Vb4165_AppMan_o33_Valvolone          	:= FALSE ;        	
	Vb4166_AppMan_o34_CarPat_FrontBack		:= FALSE ;
	Vb4167_AppMan_o35_CarPat_Aghi			:= FALSE ;
	Vb4168_AppMan_o36_CarPat_SoffioAghi		:= FALSE ;	
	Vb4169_AppMan_o37_CarPat_SoffiPattina	:= FALSE ;
	Vb4170_AppMan_o38_CarPat_DCGiu			:= FALSE ;
	Vb4171_AppMan_o39_CarPat_DCSu			:= FALSE ;
	Vb4178_AppMan_o46_C2_rasafilo        	:= FALSE ;
	Vb4180_AppMano_48_Enable_AssiXY_C2		:= FALSE ;
	Vb4181_AppMan_o49_C2_Piedino          	:= FALSE ;      	
	Vb4182_AppMan_o50_C2_Pinza_int        	:= FALSE ;
	


	Vb4185_AppMan_o53_C2_RaffreddamentoAgo 	:=FALSE;   
	Vb4186_AppMan_o54_Scaric_dx_sx       	:= FALSE ; 

	Vb4188_AppMan_o56_Piza_tras_su_giu   	:= FALSE ;   			      	         	    
	Vb4189_AppMan_o57_C2_Cambio_Pinze    	:= FALSE ;           
	Vb4190_AppMan_o58_C2_Scalino_Piedino 	:= FALSE ;        
      
       
	Vb4192_AppMan_o60_Prima_barra        	:= FALSE ;        
	Vb4193_AppMan_o61_Seconda_barra      	:= FALSE ;         
      
   	Vb4195_AppMan_C2_bloccaFiloMagente 		:= FALSE ;       

		(* reset appoggio vb uscite automatico *)
	Vb4333_AppAut_o1_Piegatore_1  		:= FALSE ;				
	Vb4334_AppAut_o2_Piegatore_2     		:= FALSE ;		
	Vb4335_AppAut_o3_Piegatore_3      	:= FALSE ;
	Vb4336_AppAut_o4_Piegatore_4    	   := FALSE ;
	Vb4337_AppAut_o5_Cambio_corpo         := FALSE ;					 		
	Vb4338_AppAut_o6_Cambio_lama_front    := FALSE ; 	
	Vb4339_AppAut_o7_Cambio_lame_lateral  := FALSE ; 		
	Vb4340_AppAut_o8_Cambio_Lamelle_4_5   := FALSE ;				  
	Vb4341_AppAut_o9_Lancia_AD            := FALSE ;	  
	Vb4342_AppAut_o10_Piegatore_AD         := FALSE ;		  
	Vb4343_AppAut_o11_Piegatore_Su_Giu     := FALSE ;		  
	Vb4344_AppAut_o12_Bilanciere_Su_Giu    := FALSE ; 		  
	Vb4345_AppAut_o13_Lancia_Cargo_Aperta	:=FALSE;
	Vb4346_AppAut_o14_C1_rasafilo          := FALSE ; 		 
	Vb4347_AppAut_o15_EvAspiratore   	   := FALSE ;
	Vb4348_AppAut_o16_Lancia_Cargo_Chiusa	:=FALSE;
	Vb4349_AppAut_o17_C1_Piedino           := FALSE ;		      
	Vb4350_AppAut_o18_C1_Pinza_int		   := FALSE ;		      
	Vb4351_AppAut_o19_C1_Pinza_est         := FALSE ;	     
	Vb4352_AppAut_o20_C1_Retrattile_AC     := FALSE ;		   
	Vb4353_AppAut_o21_C1_RaffreddamentoAgo	:= FALSE ;	
	//22
	Vb4355_AppAut_o23_Lentezza_Tasca_AD	   := FALSE ;		 
	Vb4356_AppAut_o24_Pinza_carico_Su_Giu  := FALSE ;  	
	Vb4357_AppAut_o25_C1_Cambio_Pinze      := FALSE ;  	
	Vb4358_AppAut_o26_C1_Scalino_Piedino   := FALSE ; 	
	Vb4359_AppAut_o27_C1_Ranocchia_retrat  := FALSE ; 	
	//28
	//29
	//30
	//31
	Vb4364_AppAut_o32_Enable_AssiXY_C1		:=FALSE;
	Vb4365_AppAut_o33_Valvolone				:=FALSE;
	Vb4366_AppAut_o34_CarPat_FrontBack		:=FALSE;
	Vb4367_AppAut_o35_CarPat_Aghi			:=FALSE;
	Vb4368_AppAut_o36_CarPat_SoffioAghi		:=FALSE;		
	Vb4369_AppAut_o37_CarPat_SoffiPattina	:=FALSE;
	Vb4370_AppAut_o38_CarPat_DCGiu			:=FALSE;
	Vb4371_AppAut_o39_CarPat_DCSu			:=FALSE;
	//35
	//36
	//37
	//38
	//39
	//40
	//41
	//42
	//43
	//44
	//45
	Vb4378_AppAut_o46_C2_rasafilo         := FALSE ; 
	//47
	Vb4380_AppAuto48_Enable_AssiXY_C2		:=FALSE;
	Vb4381_AppAut_o49_C2_Piedino           := FALSE ;				
	Vb4382_AppAut_o50_C2_Pinza_int         := FALSE ; 
	//51
	//52	   
	Vb4385_AppAut_o53_C2_RaffreddamentoAgo        := FALSE ;  
	Vb4386_AppAut_o54_Scaric_dx_sx        := FALSE ;
	//55
	Vb4388_AppAut_o56_Pinza_tras_su_giu    := FALSE ;  		    
	Vb4389_AppAut_o57_C2_Cambio_Pinze     := FALSE ;     
	Vb4390_AppAut_o58_C2_Scalino_Piedino  := FALSE ;   
 	//59
	Vb4392_AppAut_o60_Prima_barra         := FALSE ;  
	Vb4393_AppAut_o61_Seconda_barra       := FALSE ;   
	//62
	Vb4395_AppAut_o63_C2_bloccaFiloMagente :=FALSE;
	//64




		(* reset variabili appoggio e stato *)
		(* piegatore *)
	Vn132_DebugPie 						:= 0 ;
	Vb4000_Automatico					:= FALSE ;
	Vb4001_StepPiegatore				:= FALSE ;
	Vb4002_StepPiegatoreStop 	        := FALSE ;
	Vb4004_AvvioPiegatore 	          	:= FALSE ;
	Vb4521_AppHmiTestPiegatore			:= FALSE ;
	Vb4005_AvvioCaricatore	          	:= FALSE ;
	Vb4010_PrgPiegatoreRun 	          	:= FALSE ;
	Vb4011_TascaOk 	          			:= FALSE ;
	Vb4012_FlagTascaPronta 	          	:= FALSE ;
	Vb4013_DisableLancia 	          	:= FALSE ;
	Vb4015_PrgCaricatoreRun	          	:= FALSE ;
	Vb4507_AppManAuto		          	:= FALSE ;
(*	Vb4509_AppEnbPiegatore	          	:= FALSE ;
	Vb4511_AppEnbCaricatore	          	:= FALSE ;*)
	Vb4801_PulsStartHmiC1	          	:= FALSE ;
	Vb4802_PulsResetHmiC1	          	:= FALSE ;
	Vb4803_AppResetHmiC1	          	:= FALSE ;
 	Vb4901_PulsStartHmiC2	          	:= FALSE ;	   		
 	Vb4902_PulsResetHmiC2	          	:= FALSE ;	   		
 	Vb4903_AppResetHmiC2	          	:= FALSE ;	   		
 	C1_CmdPiedinoGiu					:= FALSE ;
 	C1_CmdPiedinoSu						:= FALSE ;
 	C2_CmdPiedinoGiu					:= FALSE ;
 	C2_CmdPiedinoSu						:= FALSE ;
 	Vb4509_AppEnbPiegatore				:= FALSE ;
 	Vb4511_AppEnbCaricatore				:= FALSE ;
 	C1_VqActPntCuci						:= 0;
 	Vb4006_StepTraslatore				:= FALSE ;
 	Vb86In_Azzeramento_C1				:= FALSE;
 	Vb4016_PrgTraslatoreRun 			:= FALSE;
 	Vb4017_AttesaTascaIsRunning			:= FALSE;
 	PiegatoreStaSalendo 				:= FALSE;
 	Vb4513_AppEnbCucitrice2				:= TRUE;
 	Vb90_AnticipoTrasl_SX 				:= FALSE;

		(* azzeramento variabili PLC *)
	MoveAsseY_C2_ON 	          		:= FALSE ;
	EnbMoveAsseY_C2_ON	          		:= FALSE ;
	Vb4520_AppScaricoCortiConPinzaRunning := FALSE ;
	Vb4072_AllarmeContSpolaC1 			:= FALSE ;
	Vb4074_AllarmeContSpolaC2 			:= FALSE ;
	RichiestaStartCuci2					:= FALSE ;	
	Vb88_TascaC1Completata				:= FALSE ;
	Vb89_TascaC2Completata				:= FALSE ;
	Vb43_TestCuciPrimaTasca_C1			:= FALSE;
	Vb45_TestCuciPrimaTasca_C2			:= FALSE;
	
	
	(* azzeramento variabili pattina*)
	Vb153GoCicloCarPAttina				:= FALSE;
	Vb154CarInPosAltaOK					:= FALSE;
	Vb155LasciaPattina					:= FALSE;
	Vb156PattinaScaricata				:= FALSE;
	C2_VbRunCuci						:= FALSE;
	Vb4042_SyncSplit1					:= FALSE;
	Vb4043_SyncSplit2					:= FALSE;

	
		(* azzero uscite analogiche *)
    vret := ExecPlcFun( PLC_AN_OUT_NUM, AO97_ValoreTensioneTesta1, 0 );
    vret := ExecPlcFun( PLC_AN_OUT_NUM, AO98_ValoreTensioneTesta2, 0 );
    vret := ExecPlcFun( PLC_AN_OUT_NUM, AO99_ValoreElettrocSotto,  0 );
    vret := ExecPlcFun( PLC_AN_OUT_NUM, AO100_ValoreElettrocSopra, 0 );

	(*tasti tensione + -*)
	mc_stati_PiuMenoTensione :=0;
	mc_stati_PiuMenoTensioneT2  :=0;
	
	
	VnVelJogAx3			:=0;
 	VnVelSemiAutoAx3	:=30;
	VnVelJogAx5			:=0;
	VnVelSemiAutoAx5	:=30;
	VnVelJogAx10		:=10;
	VnVelSemiAutoAx10	:=30;
	VnVelJogAx8			:=10;
	VnVelSemiAutoAx8	:=30;

	
		(* lasciare ultima riga *)
	ResetPrimoCiclo  	          	:= FALSE ;
end_if;


	(* reset variabili  manuali quando esco dal manuale  *)
if ( FallEnbManuale.q )then
	Vb4133_AppMan_o1_Piegatore_1 		:= FALSE ;  						
	Vb4134_AppMan_o2_Piegatore_2  		:= FALSE ;    				
	Vb4135_AppMan_o3_Piegatore_3  		:= FALSE ;  
	Vb4136_AppMan_o4_Piegatore_4    	:= FALSE ;     				 		
	Vb4137_AppMan_o5_Cambio_corpo      := FALSE ;
	Vb4338_AppAut_o6_Cambio_lama_front := FALSE ;     	  
	Vb4139_AppMan_o7_Cambio_lame_lateral  := FALSE ;    		
	Vb4140_AppMan_o8_Cambio_Lamelle_4_5 := FALSE ;  		  
	Vb4141_AppMan_o9_Lancia_AD         := FALSE ;     		  
	Vb4142_AppMan_o10_Piegatore_AD      := FALSE ;     		  
	Vb4143_AppMan_o11_Piegatore_Su_Giu  := FALSE ;    		  
	Vb4144_AppMan_o12_Bilanciere_Su_Giu := FALSE ;     		  
 
 	Vb4146_AppMan_o14_C1_rasafilo          := FALSE ;      			
	    		 

	Vb4149_AppMan_o17_C1_Piedino           := FALSE ;			      
	Vb4150_AppMan_o18_C1_Pinza_int         := FALSE ; 			      
	Vb4151_AppMan_o19_C1_Pinza_est     	   := FALSE ;   		     
	Vb4152_AppMan_o20_C1_Retrattile_AC     := FALSE ;    		   
	Vb4153_AppMan_o21_C1_RaffreddamentoAgo:= FALSE ;     		 
	Vb4156_AppMan_o24_Pinza_carico_Su_Giu  := FALSE ;       	
	Vb4157_AppMan_o25_C1_Cambio_Pinze      := FALSE ;       	
	Vb4158_AppMan_o26_C1_Scalino_Piedino   := FALSE ;      	
	Vb4159_AppMan_o27_C1_Ranocchia_retrat  := FALSE ;      	
		

	Vb4181_AppMan_o49_C2_Piedino           := FALSE ;      	
	Vb4182_AppMan_o50_C2_Pinza_int         := FALSE ;      	          	    
	Vb4189_AppMan_o57_C2_Cambio_Pinze     := FALSE ;           
	Vb4190_AppMan_o58_C2_Scalino_Piedino  := FALSE ;        
	Vb4188_AppMan_o56_Piza_tras_su_giu    := FALSE ;         
	Vb4186_AppMan_o54_Scaric_dx_sx        := FALSE ;        
	Vb4192_AppMan_o60_Prima_barra         := FALSE ;        
	Vb4193_AppMan_o61_Seconda_barra       := FALSE ;         
	Vb4178_AppMan_o46_C2_rasafilo         := FALSE ;  
	Vb4185_AppMan_o53_C2_RaffreddamentoAgo :=FALSE;       
	Vb4165_AppMan_o33_Valvolone           := FALSE ;       	  
end_if;


	(* Emergenza pressostato*)
Riti35_Pressostato( in := ( not Vb4503_CN_Allarme and  i35_Pressostato and i21_Emg ), pt := 2000 );	
//Rise_Emg_pressostato ( in := i35_Pressostato );
			
if ( Riti35_Pressostato.q )then
		(* Set Emergenza pressostato*)					
	vret := ExecPlcFun( PLC_SET_EMERGENZA, 3, 0 );
	Ciclo_emergenza_attivata := TRUE;
end_if;

if(Vn_ID_macchina = 862 or Vn_ID_macchina = 860)then
	Rit_Driver( in := (VB_SYS_CNC_ENABLED ), pt := 500 );
	(* Allarme driver X *)
	Rise_AllarmeDriver_X ( in := (Rit_Driver.q and not i31_C1_ReadyAsseX));
	if ( Rise_AllarmeDriver_X.q )then
			Vn4CodiceWarning := 1;
			vret := ExecPlcFun( PLC_SET_EMERGENZA, 4, 0 );
	end_if;
	(* Allarme driver Y *)
		Rise_AllarmeDriver_Y ( in := (Rit_Driver.q and not i32_C1_ReadyAsseY));
	if ( Rise_AllarmeDriver_Y.q )then
		Vn4CodiceWarning := 2;
		vret := ExecPlcFun( PLC_SET_EMERGENZA, 5, 0 );
		Ciclo_emergenza_attivata := TRUE;
	end_if;

end_if;
	
	 
(* Emergenza orologio*)	

Rise_Valvolone ( in:= o33_Valvolone );	
	
if(Rise_Valvolone.q)then
	vret := ExecPlcFun( 103, 0, 240 ); // leggo la data del CN	
	if(Vn246LimiteAnno <> 0 and Vn247LimiteMese <>0 and Vn248LimiteGiorno <>0 ) then
	
		if(Vn240AnnoOrologioPLC > Vn246LimiteAnno ) then
			vret := ExecPlcFun( PLC_SET_EMERGENZA, 7, 0 );
		end_if;
	
		if(Vn240AnnoOrologioPLC = Vn246LimiteAnno and Vn241MeseOrologioPLC > Vn247LimiteMese) then
			vret := ExecPlcFun( PLC_SET_EMERGENZA, 7, 0 );
		end_if;
		
		if(Vn240AnnoOrologioPLC = Vn246LimiteAnno and Vn241MeseOrologioPLC = Vn247LimiteMese and Vn242giornoOrologioPLC > Vn248LimiteGiorno) then
			vret := ExecPlcFun( PLC_SET_EMERGENZA, 7, 0 );
		end_if;
		
		
	end_if;	
end_if;

(* premo il pulsante verde *)
Rise_i21_Emg ( in := i21_Emg) ;	
if ( Rise_i21_Emg.q)then

	(*se ho il pulsante rest piegatore attivo allora alzo la pinza esterna per sbloccare le pinze*)
	if(i25_PulsResetFolder ) then
		Vb81PremutoResetAccensione := TRUE;   
		Vb4351_AppAut_o19_C1_Pinza_est := TRUE;
		Vb4075_GiraAgoFaiSpolaC1 := FALSE;
	//	o19_C1_Pinza_est := TRUE;
	else
		Vb81PremutoResetAccensione := FALSE;
	end_if;
	
	(*controllo se è attivo 1 o 2 teste*)
	if(Vb4513_AppEnbCucitrice2)then
		Vb4523_C2_PinzaDietroUnaTesta := FALSE;
	else
		  Vb4523_C2_PinzaDietroUnaTesta := TRUE;
	end_if;
end_if;
]]>
					</sourceCode>
				</program>
				<program name="C1_Boot" version="1.0.0" creationDate="0" lastModifiedDate="1697105091" excludeFromBuild="FALSE">
					<vars/>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[(* ========================================================================== 
(* SIPRO - Siax M															  	
(*                                                                            
(* COMPANY:     JAM INTERNATIONAL                                             
(*                                                                            
(* NAME: C1_Boot                                                          
(*
(* TASK BOOT
(*
(* DESCRIPTION:  Esecuzione delle inizializzazioni ( CUCITRICE 1 )
(*
(*		#### NON MODIFICARE ####
(*                                                                             
(* NOTE:                                NAME:           VER:    DATE:         
(* -------------------------------------------------------------------------  
(* Prima stesura                        gf              1.0     29/04/2021    
(* Ultima modifica                                                            
(* ========================================================================== *)

	(* NOTA: L'asse ago deve avere il parametro OVERRIDE attivo *)
	(* Imposta override al 100% *)
VN_CHN_OVERRIDE_G0 := 1000;
VN_CHN_OVERRIDE_G1 := 1000;
VN_AX1_OVERRIDE := 1000;
VN_AX2_OVERRIDE := 1000;
VN_AX3_OVERRIDE := 1000;
VN_AX4_OVERRIDE := 1000;

	(* Variabili per l'inseguimento gantry Ago - Crochet *)
VN_AX4_FOLL_CONF := 1;
VN_AX4_FOLL_MASTER_NUM := C1_AsseAGO;	
VQ_AX4_FOLL_NUM := 1000;
VQ_AX4_FOLL_DEN := 1000;

	(* Comandi cucitrice *)
C1_VbStartCuci   := FALSE;
C1_VbHoldCuci    := FALSE;           
C1_VbReleaseCuci := FALSE;       
C1_VbEndCuci     := FALSE;        
C1_VbRunCuci     := FALSE;        
C1_VbRallCuci    := FALSE;       
C1_VbRasafCuci   := FALSE;        
C1_VbAgoAzzCuci  := FALSE;        
C1_VbCamMovCuci  := FALSE;        
C1_VbAxMovCuci   := FALSE;        
C1_VbLastPnt     := FALSE;        
C1_VbSuspendCuci := FALSE;        
C1_VbCuciGoto    := FALSE;        

	(* Reset comandi e flags *)
C1_CmdInitCamme   := FALSE;
C1_CmdHoldRelease := FALSE;
C1_CmdHoldHMI     := FALSE;
C1_CmdReleaseHMI  := FALSE;
C1_CmdPiedinoSu   := FALSE;
C1_CmdPiedinoGiu  := FALSE;
C1_CuciSimulaAuto := FALSE;
C1_CuciLastPoint  := FALSE;
C1_CmdRiposiziona := FALSE;
C1_CuciLastPointEnaStop := FALSE;
C1_CmdReloadTabellone   := FALSE;
C1_CmdSaveParam         := FALSE;
C1_CmdGantryCrochet     := FALSE;
C1_CmdStdFollowCrochet  := FALSE;
C1_CmdSganciaCrochet    := FALSE;
C1_CmdSetOffsetAgoTacca := FALSE;
C1_CmdSbloccaAgo        := FALSE;  
C1_CmdForceLoadProfilo  := TRUE;		(* Forzatura load profilo *)	
	
	(* Impstazione default variabili *)
C1_PlcStatoAgo := 0;
C1_VelLimitRPM := 0;
C1_CntApritens := 0;
C1_CntColtello := 0;
C1_VqActPntCuci := 0;


(* LETTURA PARAMETRI ASSE *)
(* Lettura fine corsa indietro asse X *)
ipar := ( (C1_AsseX * 100) + 14 );    
vret := ExecPlcFun( PLC_READ_AX_PARAM, ipar, 104 );	//Valore letto messo in Vq_104_READ_FC_ind_X
(* Lettura fine corsa avanti asse X *)
ipar := ( (C1_AsseX * 100) + 15 );    
vret := ExecPlcFun( PLC_READ_AX_PARAM, ipar, 105 );	//Valore letto messo in Vq_105_READ_FC_ava_X
(* Lettura fine corsa indietro asse Y *)
ipar := ( (C1_AsseY * 100) + 14 );    
vret := ExecPlcFun( PLC_READ_AX_PARAM, ipar, 106 );	//Valore letto messo in Vq_106_READ_FC_ind_Y
(* Lettura fine corsa avanti asse Y *)
ipar := ( (C1_AsseY * 100) + 15 );    
vret := ExecPlcFun( PLC_READ_AX_PARAM, ipar, 107 );	//Valore letto messo in Vq_107_READ_FC_ava_Y

(* Lettura fine corsa indietro Caricatore *)
ipar := ( (C1_AsseCAR * 100) + 14 );    
vret := ExecPlcFun( PLC_READ_AX_PARAM, ipar, 110 );	//Valore letto messo in Vq_110
(* Lettura fine corsa avanti Caricatore *)
ipar := ( (C1_AsseCAR * 100) + 15 );    
vret := ExecPlcFun( PLC_READ_AX_PARAM, ipar, 111 );	//Valore letto messo in Vq_111



(* LETTURA PARAMETRI ASSE *)
(* Lettura fine corsa indietro asse X C2 *)
ipar := ( (C2_AsseX * 100) + 14 );    
vret := ExecPlcFun( PLC_READ_AX_PARAM, ipar, 114 );	//Valore letto messo in Vq_114_READ_FC_ind_X
(* Lettura fine corsa avanti asse X C2 *)
ipar := ( (C2_AsseX * 100) + 15 );    
vret := ExecPlcFun( PLC_READ_AX_PARAM, ipar, 115 );	//Valore letto messo in Vq_115_READ_FC_ava_X
(* Lettura fine corsa indietro asse Y C2*)
ipar := ( (C2_AsseY * 100) + 14 );    
vret := ExecPlcFun( PLC_READ_AX_PARAM, ipar, 116 );	//Valore letto messo in Vq_116_READ_FC_ind_Y
(* Lettura fine corsa avanti asse Y C2 *)
ipar := ( (C2_AsseY * 100) + 15 );    
vret := ExecPlcFun( PLC_READ_AX_PARAM, ipar, 117 );	//Valore letto messo in Vq_117_READ_FC_ava_Y

(* Lettura fine corsa indietro Traslatore *)
ipar := ( (C2_AsseCAR * 100) + 14 );    
vret := ExecPlcFun( PLC_READ_AX_PARAM, ipar, 118 );	//Valore letto messo in Vq_118
(* Lettura fine corsa avanti Traslatore *)
ipar := ( (C2_AsseCAR * 100) + 15 );    
vret := ExecPlcFun( PLC_READ_AX_PARAM, ipar, 119 );	//Valore letto messo in Vq_119


(*tasca dx e sx*)
Vn196_Tasca_DX_C1 :=1;
Vn197_Tasca_SX_C1 :=0;

]]>
					</sourceCode>
				</program>
				<program name="C1_Camme" version="1.0.0" creationDate="0" lastModifiedDate="1702977680" excludeFromBuild="FALSE">
					<vars>
						<localVars>
							<var name="RiseApritens" type="RiseEdge"/>
							<var name="RiseColtello" type="RiseEdge"/>
							<var name="RiseBloccoFiloINI" type="RiseEdge"/>
							<var name="RiseBloccoFiloEND" type="RiseEdge"/>
							<var name="FallBloccoFiloINI" type="FallEdge"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[(* ========================================================================== 
(* SIPRO - Siax M															  	
(*                                                                            
(* COMPANY:     JAM INTERNATIONAL                                             
(*                                                                            
(* NAME: C1_Camme                                                          
(*
(* TASK MAIN	 
(*
(* DESCRIPTION: Programmazione delle camme digitali  ( CUCITRICE 1 ) 
(*
(* NOTE:                                NAME:           VER:    DATE:         
(* -------------------------------------------------------------------------  
(* Prima stesura                        gf              1.0     29/04/2021    
(* Ultima modifica                                                            
(* ========================================================================== *)

	(* Inizializzazione delle Camme digitali *)
if ( C1_CmdInitCamme ) then
	C1_CmdInitCamme := FALSE;
		
	C1_VbEnableCamme := FALSE;
	C1_VbEnableCammeIni := FALSE;
	
        (* Camma fuori ingombro - senza anticipi *)
	CamMode   := ( C1_MODE_FUORI_ING * 1000 );
	CamAxNum  := ( C1_AsseAGO * 1000 );
	CamDigOut := ( C1_AGO_FUORI_ING_IDX * 1000 );
	CamStart  := C1_SogliaStart;
	CamStop   := C1_SogliaStop; 
	CamModule := ( CAM_MODULE * 1000 );
	vret := ExecPlcFun( PLC_INIT_ONE_CAM, C1_ID_CAM_FUORI_ING, INIT_CAM_VQ_IDX );      

        (* Camma per la fermata sull'ago alto *)
	CamMode   := ( C1_MODE_AGO_ALTO * 1000 );
	CamAxNum  := ( C1_AsseAGO * 1000 );
	CamDigOut := ( C1_AGO_ALTO_STOP_IDX * 1000 );
	
	if ( C1_StopAgo = 0 ) then
	    CamStart := ( 1 * 1000 );
	else
	    CamStart := C1_StopAgo;
	end_if;
	
	CamStop   := CamStart + ( CAM_MODULE * 1000 ) / 4; 
	CamModule := ( CAM_MODULE * 1000 );
	vret := ExecPlcFun( PLC_INIT_ONE_CAM, C1_ID_CAM_AGO_ALTO, INIT_CAM_VQ_IDX );      

        (* Camma Apritensione *)
	CamMode   := ( C1_MODE_APRITENS * 1000 );
	CamAxNum  := ( C1_AsseAGO * 1000 );
	CamDigOut := ( C1_VB_APRITENS * 1000 );
	CamStart  := C1_StartApriTens;
	CamStop   := C1_StopApriTens;
	CamModule := ( CAM_MODULE * 1000 );
	vret := ExecPlcFun( PLC_INIT_ONE_CAM, C1_ID_APRITENS, INIT_CAM_VQ_IDX );      

	CamCmd  := 1000;
	CamPar1 := ( C1_ENA_APRITENS * 1000 );
	vret := ExecPlcFun( PLC_IO_CTL_CAM, C1_ID_APRITENS, IO_CTL_CAM_VQ_IDX );      

    
        (* Camma Rasafilo - Coltello *)   
	CamMode   := ( C1_MODE_COLTELLO * 1000 );
	CamAxNum  := ( C1_AsseAGO * 1000 );
	CamDigOut := ( C1_OUT_COLTELLO * 1000 );
	CamStart  := C1_StartColtello;
	CamStop   := C1_StopColtello;
	CamModule := ( CAM_MODULE * 1000 );
	vret := ExecPlcFun( PLC_INIT_ONE_CAM, C1_ID_COLTELLO, INIT_CAM_VQ_IDX );        

	CamCmd  := 1000;
	CamPar1 := ( C1_ENA_COLTELLO * 1000 );
	vret := ExecPlcFun( PLC_IO_CTL_CAM, C1_ID_COLTELLO, IO_CTL_CAM_VQ_IDX );  
	
	
        (* Camma BloccoFiloINI *)
	CamMode   := ( C1_MODE_BLOCCO_FILO_INI * 1000 );
	CamAxNum  := ( C1_AsseAGO * 1000 );
	CamDigOut := ( C1_VB_BLOCCO_FILO_INI * 1000 );
	CamStart  := C1_StartBloccoFiloINI;
	CamStop   := C1_StopBloccoFiloINI;
	CamModule := ( CAM_MODULE * 1000 );
	vret := ExecPlcFun( PLC_INIT_ONE_CAM, C1_ID_BLOCCO_FILO_INI, INIT_CAM_VQ_IDX );      

	CamCmd  := 1000;
	CamPar1 := ( C1_ENA_BLOCCO_FILO_INI * 1000 );
	vret := ExecPlcFun( PLC_IO_CTL_CAM, C1_ID_BLOCCO_FILO_INI, IO_CTL_CAM_VQ_IDX );      	
	

        (* Camma BloccoFiloEND *)
	CamMode   := ( C1_MODE_BLOCCO_FILO_END * 1000 );
	CamAxNum  := ( C1_AsseAGO * 1000 );
	CamDigOut := ( C1_VB_BLOCCO_FILO_END * 1000 );
	CamStart  := C1_StartBloccoFiloEND;
	CamStop   := C1_StopBloccoFiloEND;
	CamModule := ( CAM_MODULE * 1000 );
	vret := ExecPlcFun( PLC_INIT_ONE_CAM, C1_ID_BLOCCO_FILO_END, INIT_CAM_VQ_IDX );      

	CamCmd  := 1000;
	CamPar1 := ( C1_ENA_BLOCCO_FILO_END * 1000 );
	vret := ExecPlcFun( PLC_IO_CTL_CAM, C1_ID_BLOCCO_FILO_END, IO_CTL_CAM_VQ_IDX );      	

end_if;
 
(* Contatori di attivazione delle uscite di apritensione e coltello *)    

 
RiseApritens(  in := Vb2_C1_Apritensione ); 
if ( RiseApritens.q ) then
	C1_CntApritens := C1_CntApritens + 1;
end_if; 


RiseColtello(  in := o14_C1_rasafilo  );

if ( RiseColtello.q ) then
	C1_CntColtello := C1_CntColtello + 1;
end_if; 

(* camma blocco filo inizio*)
RiseBloccoFiloINI(  in := Vb13_C1_BloccoFiloINI );
FallBloccoFiloINI(  in := Vb13_C1_BloccoFiloINI );

if ( RiseBloccoFiloINI.q ) then
	C1_CntBloccoFiloINI := C1_CntBloccoFiloINI + 1;
end_if; 
if ( FallBloccoFiloINI.q ) then
	 C1_VbEnableCammeIni := FALSE ;	
end_if; 



(* camma blocco filo fine *)
RiseBloccoFiloEND(  in := Vb14_C1_BloccoFiloEND );

if ( RiseBloccoFiloEND.q ) then
	C1_CntBloccoFiloEND := C1_CntBloccoFiloEND + 1;
end_if; 

]]>
					</sourceCode>
				</program>
				<program name="Boot" version="1.0.0" creationDate="0" lastModifiedDate="1715177173" excludeFromBuild="FALSE">
					<vars/>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[(* ========================================================================== 
(* SIPRO - Siax M															  	
(*                                                                            
(* COMPANY:     JAM INTERNATIONAL                                             
(*                                                                            
(* NAME: Boot                                                          
(*
(* TASK BOOT 
(*
(* DESCRIPTION:  Esecuzione delle inizializzazioni di carattere generale
(*                                                                             
(* NOTE:                                NAME:           VER:    DATE:         
(* -------------------------------------------------------------------------  
(* Prima stesura                        gf              1.0     29/04/2021    
(* Ultima modifica                                                            
(* ========================================================================== *)


	(* ------------------------------- *)
	(* FLAG SIMULAZIONE - PER DEBUGGER *)
VbSimulaDbg := FALSE;

	(* Versopne applicativo*) 
case(Vn_ID_macchina)of
	862: App_Ver := 'JT862M - Ver 25.00 - 28.03.2024';	(*25.00 rottura filo con contagiri e non con sensore ago*)
	860: App_Ver := 'JT862HM - Ver 24.00 - 12.05.2023';
	882: App_Ver := 'JT882M - Ver 16.00.00 - 22.11.2023';
end_case;

	(* Emergenza all'accensione *)
vret := ExecPlcFun(PLC_SET_EMERGENZA, 1, 0 );

	(* Inizializzazione camme digitali *)
VbEnableCamme := FALSE;			
vret := ExecPlcFun( PLC_RESET_ALL_CAM, ENABLE_CAMME_IDX, ERR_CODE_CAMME_IDX );
VbEnableCamme := TRUE;

	(* Inizializzazione override assi caricatori ( asse 5 e 10 ) *)
VN_AX5_OVERRIDE  := 1000;
VN_AX10_OVERRIDE := 1000;
VN_CHN3_OVERRIDE_G0 := 1000;
VN_CHN3_OVERRIDE_G1 := 1000;

	(* resetto tutte le variabili in emergenza*)
ResetPrimoCiclo := TRUE ;
Vb42_PrimaTasca_C1 := TRUE;
Vb44_PrimaTasca_C2 := TRUE;

Vb4088_TestDisableRiposizionaAgo := FALSE ;
Vb4089_TestDisableRiposizionaAgoC2 := FALSE ;

(* Interrupt rottura filo *)

Fun202VnParIndx_0 := 1;
Fun202VnParIndx_1 := 202;
Fun202VnParIndx_2 := EnbCountRotturaFiloC1_IDX;
Fun202VnParIndx_3 := ContPuntiRottFiloC1_IDX;
vret := ExecPlcFun( PLC_ADD_FUN_IRQ, 11, 1000 );

Fun202VnParIndx_0 := 1;
Fun202VnParIndx_1 := 202;
Fun202VnParIndx_2 := EnbCountRotturaFiloC2_IDX;
Fun202VnParIndx_3 := ContPuntiRottFiloC2_IDX;
vret := ExecPlcFun( PLC_ADD_FUN_IRQ, 21, 1000 ); 

]]>
					</sourceCode>
				</program>
				<program name="C1_LoadUdf" version="1.0.0" creationDate="0" lastModifiedDate="1697205679" excludeFromBuild="FALSE">
					<vars>
						<localVars>
							<var name="RiseBootDone" type="RiseEdge"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[(* ========================================================================== 
(* SIPRO - Siax M															  	
(*                                                                            
(* COMPANY:     JAM INTERNATIONAL                                             
(*                                                                            
(* NAME: C1_LoadUdf                                                          
(*
(* TASK MAIN	 
(*
(* DESCRIPTION: Load programmi utente ( CUCITRICE 1 ) 
(*
(*		#### NON MODIFICARE ####
(*                                                                             
(* NOTE:                                NAME:           VER:    DATE:         
(* -------------------------------------------------------------------------  
(* Prima stesura                        gf              1.0     29/04/2021    
(* Ultima modifica                                                            
(* ========================================================================== *)


	
	(* Fronte di salita del fine del boot del CN *)
RiseBootDone( in:= VB_SYS_CNC_BOOT_DONE  );

	(* Selezione programma main, load UDF parametri *)
if RiseBootDone.q then
		
		(* Set nome del programma CN *)
	C1_PrgName := 'c:/cnc/prog/C1_Main.obj';
    ipar := ((C1_CHN*1000)+13);
	vret := ExecPlcFun( PLC_WRITE_FORK_VAR, ipar, C1_PRG_NAME_IDX );

		(* Cmd Load programma UDF dei parametri (contesto C1_PAR_CNTX) *)
	C1_CmdLoadParam := TRUE;
end_if;

		(* Load programma UDF dei parametri (contesto C1_PAR_CNTX) *)
if ( C1_CmdLoadParam ) then		
	C1_UdfName := 'c:/cnc/sys/C1_Param.udf';
	
    ipar := ((C1_PAR_CNTX*1000)+30);
    vret := ExecPlcFun( PLC_WRITE_FORK_VAR, ipar, C1_UDF_NAME_IDX );
    
    ipar := ((C1_PAR_CNTX*100)+17);
   	vret := ExecPlcFun( PLC_SET_UDT_CMD, ipar, 0 );	

	C1_CmdLoadParam := FALSE;

		(* Set offset ago tacca *)
	C1_CmdSetOffsetAgoTacca := TRUE;
end_if;


	(* Load UDF tabellone *)
if ( RiseBootDone.q or C1_CmdReloadTabellone ) then
		
		(* Load programma UDF dei parametri dinamici sul contesto impostato in cucitrice.txt) *)
	vret := ExecPlcFun( PLC_CUCI_CMD, 124, C1_TAB_CONTEXT_IDX );

	if ( C1_TabParContext > 0 ) then
   		C1_UdfName := 'c:/cnc/sys/C1_TabPar.udf';
    	ipar := ((C1_TabParContext*1000)+30);
    	vret := ExecPlcFun( PLC_WRITE_FORK_VAR, ipar, C1_UDF_NAME_IDX );
    	
    	ipar := ((C1_TabParContext*100)+21);
    	vret := ExecPlcFun( PLC_SET_UDT_CMD, ipar, 0 );
	end_if;

	if ( C1_CmdReloadTabellone ) then
		C1_CmdReloadTabellone := FALSE;
		vret := ExecPlcFun( PLC_CUCI_CMD, 131, 1 );						(* Abilita info debugger *)
        vret := ExecPlcFun( PLC_CUCI_CMD, 132, C1_WARNING_INFO_IDX );   (* Abilita info warning  *)
	end_if;

end_if;


	(* Save UDF parametri *)
if ( C1_CmdSaveParam ) then
	
		(* Scrive il passo nel contesto *)
	C1_StepNum := 1;	
	C1_MtxNum  := C1_PAR_BASE_MTX; 
	ipar := ((C1_PAR_CNTX*100)+34);
   	vret := ExecPlcFun( PLC_SET_UDT_CMD, ipar, C1_WRITE_PAR_IDX );

		(* Salva il file *)
	ipar := ((C1_PAR_CNTX*100)+26);	
   	vret := ExecPlcFun( PLC_SET_UDT_CMD, ipar, 0 );

	C1_CmdSaveParam   := FALSE;

		(* Set offset ago tacca *)
	C1_CmdSetOffsetAgoTacca := TRUE;
end_if;	 	

]]>
					</sourceCode>
				</program>
				<program name="C1_Cucitrice" version="1.0.0" creationDate="0" lastModifiedDate="1715177116" excludeFromBuild="FALSE">
					<vars>
						<localVars>
							<var name="FallPrgRun" type="FallEdge"/>
							<var name="RisePrgRun" type="RiseEdge"/>
							<var name="RiseSuspend" type="RiseEdge"/>
							<var name="RiseAva" type="RiseEdge"/>
							<var name="RiseInd" type="RiseEdge"/>
							<var name="FlgWaitAgoFermo" type="BOOL"/>
							<var name="CmdStartAgo" type="BOOL"/>
							<var name="MemActPnt" type="DINT"/>
							<var name="RiseAvaNpoint" type="RiseEdge"/>
							<var name="RiseIndNpoint" type="RiseEdge"/>
							<var name="RiseAvaCont" type="RiseEdge"/>
							<var name="RiseIndCont" type="RiseEdge"/>
							<var name="FlgWaitTime" type="BOOL"/>
							<var name="DelayTimer" type="Ton"/>
							<var name="VcdIdx" type="INT"/>
							<var name="RpmFix3" type="DINT"/>
							<var name="Rise_Cambio_C1_NextCode" type="RiseEdge"/>
							<var name="Time_PartenzaSimulaAuto" type="Ton"/>
							<var name="Rise_Partenza_in_simulazione" type="RiseEdge"/>
							<var name="Fall_C1_CuciSimulaAuto" type="FallEdge"/>
							<var name="Forwards" type="BOOL"/>
							<var name="Backwards" type="BOOL"/>
							<var name="StatoIniziale_C1_NextCode" type="INT"/>
							<var name="PartenzaSimulaAuto" type="BOOL"/>
							<var name="Rise_SimulaArrivatoAllaFine" type="RiseEdge"/>
							<var name="Ton_C1_FinitoSimulazione" type="Ton"/>
							<var name="RisePinzeC1" type="RiseEdge"/>
							<var name="FallPinzeC1" type="FallEdge"/>
							<var name="Rise_C1_CuciSimulaAuto" type="RiseEdge"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[ (* ========================================================================== 
(* SIPRO - Siax M                                                               
(*                                                                            
(* COMPANY:     JAM INTERNATIONAL                                             
(*                                                                            
(* NAME: C1_Cucitrice                                                          
(*
(* TASK MAIN     
(*
(* DESCRIPTION: GESTIONE CUCITRICE 1 
(*
(*      #### NON MODIFICARE ####
(*                                                                             
(* NOTE:                                NAME:           VER:    DATE:         
(* -------------------------------------------------------------------------  
(* Prima stesura                        gf              1.0     13/03/2021    
(*
(* Gestione simulazione con movimento sull'ultimo punto
(* #M210323_1GF#                        gf              1.1     23/03/2021 
(*
(* Hold/Release durante la fermata temporanea
(* #M210511_1GF#                        gf              1.2     11/05/2021 
(*   
(* Step+ Step- dopo Hold durante la fermata temporanea
(* #M210513_1GF#                        gf              1.3     13/05/2021 
(*   
(* Ultima modifica                                                            
(* ========================================================================== *)

 (*----------------------   
   Lettura Fase asse AGO 
 ------------------------*)
    ipar := ((C1_AsseAGO * 100)+32);    
    vret := ExecPlcFun( PLC_READ_AX_QUOTE, ipar, C1_FASE_AX_AGO_IDX );

(*----------------------------------------  
  Copia su vb i bit della parola di stato 
 -----------------------------------------*)
vret := ExecPlcFun( PLC_VN_TO_VB, C1_STATUS_WORD_BIT_IDX, C1_VN_STATUS_CUCI_IDX );

(*--------------------------------------------------------- 
 CuciOrMove: lettura della variabile  C1_VbFlgCuciOrMove
             viene usato nel programma CN dopo un hold
 ----------------------------------------------------------*)
vret := ExecPlcFun( PLC_CUCI_CMD, 129, C1_FLG_CUCI_OR_MOVE_IDX );       

(*--------------------------------------------------------- 
 G280Running: lettura della variabile  C1_VbFlgG280Running
  ----------------------------------------------------------*)
vret := ExecPlcFun( PLC_CUCI_CMD, 130, C1_FLG_G280_RUNNING_IDX );       

(*-------------------------------------------------------------- 
 JTaskInfo: lettura delle variabili info Task J - #M210511_1GF#
  ---------------------------------------------------------------*)
vret := ExecPlcFun( PLC_CUCI_CMD, 133, C1_FLG_JTASK_INFO_IDX );     

(*------------------------------ 
 Disabilitazione camme digitali
 -------------------------------*)
if ( ( C1_VbEnableCamme = TRUE ) AND ( C1_FaseAxAgo = 0 ) ) then
    C1_VbEnableCamme := FALSE;
    C1_VbEnableCammeIni := FALSE ;  
end_if;

(*-----------------------
 Flag cucitrice azzerata 
 ------------------------*)
if ( not VB_AX1_ZEROED or not VB_AX2_ZEROED or not VB_AX3_ZEROED or not VB_AX4_ZEROED ) then
(*  C1_AssiAzzerati := TRUE;            messo in azzeramento CN qui non aspetta che arriva in quota di home
else*)
    C1_AssiAzzerati := FALSE;
end_if; 


(*---------------------------------------------------
 Gestione offset tra AGO e tacca di zero dell'encoder 
 ----------------------------------------------------*)
if ( C1_CmdGetOffsetAgoTacca ) then
    ipar := ((C1_CHN * 100)+27);
    vret := ExecPlcFun( PLC_CUCI_CMD, ipar, C1_OFFSET_AGO_TACCA_IDX );  
    C1_CmdGetOffsetAgoTacca := FALSE;
end_if;

if ( C1_CmdSetOffsetAgoTacca ) then
    ipar := ((C1_CHN * 100)+2);
    vret := ExecPlcFun( PLC_CUCI_SET_PARAM, ipar, C1_OFFSET_AGO_TACCA_IDX );    
    C1_CmdSetOffsetAgoTacca := FALSE;
end_if;


(*--------------------------------- 
 Fronte di salita / discesa PrgRun 
 ----------------------------------*)
RisePrgRun( in:= VB_CHN_AUTO_RUNNING );
FallPrgRun( in:= VB_CHN_AUTO_RUNNING );

(*--------------------------------------    
 Inizio esecuzione programma automatico 
 ---------------------------------------*)
if RisePrgRun.q then
    C1_VbSuspendCuci := FALSE;
    C1_PlcStatoAgo := 0;    
    
        (* Reset comando di hold *)
    C1_CmdHoldRelease := FALSE;
    vret := ExecPlcFun( PLC_CUCI_CMD, 104, 1 );     (* Toglie l'hold *)
    
end_if;

(*------------------------------------  
 Fine esecuzione programma automatico 
 -------------------------------------*)
if FallPrgRun.q then
    VN_AX3_OVERRIDE := 1000;
    
        (* Rollover asse ago *)
    RollPlcAgoModule := 360000;
    RollPlcAgoQuo := 0;
    ipar := ((C1_AsseAGO * 100)+0);
    vret := ExecPlcFun( PLC_ROLLOVER_AX, ipar, ROLL_PLC_AGO_IDX );  
    
        (* Verifica se cucitrice ancora abilitata per stop automatico a causa di una emergenza *)   
    if ( C1_VbStEnIrqBit or C1_VbStEnMovBit or C1_VbCuciIsoActive ) then
        vret := ExecPlcFun( PLC_CUCI_CMD, 104, 99 );
    end_if;

    C1_PlcStatoAgo := 0;    

        (* Elimina le forzature di velocita' asse ago *)
    vret := ExecPlcFun( PLC_CUCI_CMD, 108, 0 );     

        (* Azzera il comando di hold e il flag di simulazione *)
    C1_CmdHoldRelease := FALSE;
    C1_CuciSimulaAuto := FALSE;

        (* Invia un comando di release - #M210511_1GF# *)
    VB_CHN_RELEASE := TRUE;
    
end_if;

(*-------------------------------------------
 Variabile START CUCITRICE
 Viene messa a TRUE dall'istruzione ISO G280    
 Il PLC la riporta al valore FALSE
 --------------------------------------------*)
if ( C1_VbStartCuci = TRUE ) then


    C1_VbStartCuci := FALSE;

    if ( C1_CmdHoldRelease = FALSE ) then
        CmdStartAgo := TRUE;
        C1_CuciLastPointEnaStop := FALSE;
    end_if;
end_if;

(*------------------------------------------------------------- 
 Variabile SUSPEND
 Viene messa a TRUE dal firmware quando e' richiesta una 
 sospensione della cucitura.    
 Il PLC la riporta al valore FALSE quando l'asse ago e' fermo
 Verifica HOLD per fermare il task prima che venga interpretato 
 ed effettuato un movimento
 --------------------------------------------------------------*)
 
RiseSuspend( in:= C1_VbSuspendCuci );

if ( RiseSuspend.q ) then

        (* Stop in fase asse ago *)
    StopPlcAgoErrCode := 0;
    StopPlcAgoQuoObj  := C1_StopAgo;
    StopPlcAgoFuture := 0;
    ipar := (C1_AsseAGO*100);
    vret := ExecPlcFun( PLC_CHG_QUO_OBJ_AX, ipar, STOP_PLC_AGO_IDX );       
            
end_if;

if ( ( C1_VbSuspendCuci = TRUE ) and ( C1_FaseAxAgo = 0 ) ) then

    C1_VbSuspendCuci := FALSE;
end_if;


(*------------------------------------------------------------------ 
 SIMULAZIONE CUCITURA   
 Ciclo automatico RUN cucitrice in HOLD e ago fermo
 Sono attivi i movimenti avanti e indietro sul percorso di cucitura
 E' attivo anche il riposizionamento sul punto 
 -------------------------------------------------------------------*)
RiseAva( in := C1_CmdSimulaAva ); 
RiseInd( in := C1_CmdSimulaInd ); 

RiseAvaNpoint( in := C1_CmdSimulaAvaNpoint ); 
RiseIndNpoint( in := C1_CmdSimulaIndNpoint ); 

RiseAvaCont( in := C1_CmdSimulaAvaCont ); 
RiseIndCont( in := C1_CmdSimulaIndCont ); 

if ( C1_CmdHoldRelease and VB_CHN_AUTO_RUNNING and ( C1_FaseAxAgo = 0 ) ) then


    
    
	(* -----------#M210618_DA#  ---------------- *)
	(* MACCHINA A STATI - "SIMULA" SINGLE STEP   *)
	(* ----------------------------------------- *)
	if ( RiseAva.q and mc_stati_C1CmdSimula = 0 ) then 
    	
    	mc_stati_C1CmdSimula := 1;
    	Forwards := TRUE;
    	Backwards := FALSE;
 
    end_if;
    
    if ( RiseInd.q and mc_stati_C1CmdSimula = 0) then
        mc_stati_C1CmdSimula := 1;
    	Forwards := FALSE;
    	Backwards := TRUE;  
    end_if;

	case ( mc_stati_C1CmdSimula ) of
	
		1:
			C1_CuciBufRewind :=FALSE;
			if(Forwards = TRUE and Backwards = FALSE) then
				vret := ExecPlcFun( PLC_CUCI_CMD, 148, C1_RD_NEXT_CODE_IDX );   (* #M210616_1GF# *)
				mc_stati_C1CmdSimula := 2;
			else
				vret := ExecPlcFun( PLC_CUCI_CMD, 149, C1_RD_NEXT_CODE_IDX );   (* #M210616_1GF# *)
				mc_stati_C1CmdSimula := 2;
				
			end_if;
		
			
		2: 	if(C1_NextCode = 0 and not o17_C1_Piedino) then	//se ilprossimo è un G0..alzo il piedino prima di continuare
				C1_CmdPiedinoGiu := FALSE;
            	C1_CmdPiedinoSu  := TRUE;
            	mc_stati_C1CmdSimula := 3;
            else
            
				mc_stati_C1CmdSimula := 5;
			end_if;
		3:
			if ( not C1_CmdPiedinoSu ) then	(* Entro quando il piedino è tornato alto *)
			
				mc_stati_C1CmdSimula := 5;
			end_if;
			
		5:	if(Forwards = TRUE and Backwards = FALSE) then
		
		
				if ( C1_VbFlgJtaskRunning = TRUE ) then                 (* #M210513_1GF# *)
                	VB_CHN_RELEASE := TRUE;                             (* #M210513_1GF# *)
                	if ( C1_VbFlgJtaskLoopHold = TRUE ) then            (* #M210513_1GF# *)
                    	vret := ExecPlcFun( PLC_CUCI_CMD, 104, 81 );    (* #M210513_1GF# *) 
                    	vret := ExecPlcFun( PLC_CUCI_CMD, 150, 0 );     (* #M210513_1GF# *) 
                	end_if;                                             (* #M210513_1GF# *)

            	else
                	vret := ExecPlcFun( PLC_CUCI_CMD, 150, 0 ); 
            	end_if;
            else
             	if ( C1_VbFlgJtaskRunning = TRUE ) then                 (* #M210513_1GF# *)
                	VB_CHN_RELEASE := TRUE;                             (* #M210513_1GF# *)
                	if ( C1_VbFlgJtaskLoopHold = TRUE ) then            (* #M210513_1GF# *)
                    	vret := ExecPlcFun( PLC_CUCI_CMD, 104, 81 );    (* #M210513_1GF# *) 
                    	vret := ExecPlcFun( PLC_CUCI_CMD, 150, 1 );     (* #M210513_1GF# *) 
                	end_if;                                             (* #M210513_1GF# *)

            	else
                	vret := ExecPlcFun( PLC_CUCI_CMD, 150, 1 ); 
            	end_if;
            end_if;
			mc_stati_C1CmdSimula := 0;
			
			(* Default switch case *)
	else
    mc_stati_C1CmdSimula := 0; 
		
	end_case;



	(* ------------#M210618_DA#  ------- *)
	(* "SIMULA" MULTI STEP CON SALTO     *)
	(* --------------------------------- *)


    if ( RiseAvaNpoint.q ) then 
        if ( o17_C1_Piedino and not C1_CmdPiedinoSu) then
            if ( C1_ModoSimulaNpoint ) then
                vret := ExecPlcFun( PLC_CUCI_CMD, 175, C1_SIMULA_NPOINT_IDX );  (* #M210323_1GF# *) 
            else
                vret := ExecPlcFun( PLC_CUCI_CMD, 155, C1_SIMULA_NPOINT_IDX );  
            end_if; 
        else
            C1_CmdPiedinoGiu := FALSE;
            C1_CmdPiedinoSu  := TRUE;
        end_if;         
    end_if;
    
    if ( RiseIndNpoint.q ) then
        if ( o17_C1_Piedino and not C1_CmdPiedinoSu) then
            if ( C1_ModoSimulaNpoint ) then
                vret := ExecPlcFun( PLC_CUCI_CMD, 176, C1_SIMULA_NPOINT_IDX );  (* #M210323_1GF# *)
            else
                vret := ExecPlcFun( PLC_CUCI_CMD, 156, C1_SIMULA_NPOINT_IDX );  
            end_if; 
        else
            C1_CmdPiedinoGiu := FALSE;
            C1_CmdPiedinoSu  := TRUE;
        end_if;         
    end_if;


	(* -------------#M210618_DA#  -------------- *)
	(* MACCHINA A STATI - "SIMULA" STEP CONTINUI *)
	(* ----------------------------------------- *)
	
	C1_CmdSimulaPedaleVel := i2_C1_Pedana;

			
    if ( RiseAvaCont.q ) then 
    

    	Forwards := TRUE;
    	Backwards := FALSE;

    	C1_SimulaContVbIdx := ( C1_SIMULA_AVA_CONT_IDX * 1000 );
       	vret := ExecPlcFun( PLC_CUCI_CMD, 148, C1_RD_NEXT_CODE_IDX );   (* #M210616_1GF# *)
       	vret := ExecPlcFun( PLC_CUCI_CMD, 157, C1_SIMULA_CONT_IDX );  
      	StatoIniziale_C1_NextCode := C1_NextCode;
     	mc_stati_C1CmdSimulaCont := 1;
     	
    	
    end_if;
    
    if ( RiseIndCont.q ) then
    

    	Forwards := FALSE;
    	Backwards := TRUE;

    	C1_SimulaContVbIdx := ( C1_SIMULA_IND_CONT_IDX * 1000 );
       	vret := ExecPlcFun( PLC_CUCI_CMD, 149, C1_RD_NEXT_CODE_IDX );   (* #M210616_1GF# *)
        vret := ExecPlcFun( PLC_CUCI_CMD, 158, C1_SIMULA_CONT_IDX ); 
      	StatoIniziale_C1_NextCode := C1_NextCode;
       	mc_stati_C1CmdSimulaCont := 1;  
    
    
     end_if;
    
    Rise_Cambio_C1_NextCode( in := (mc_stati_C1CmdSimulaCont =1 and (StatoIniziale_C1_NextCode <> C1_NextCode)));
    
        
    case ( mc_stati_C1CmdSimulaCont ) of
    
	
		1:			
			if(Rise_Cambio_C1_NextCode.q or (not o17_C1_Piedino and C1_NextCode = 0) ) then 	//se c'è un cambiamento tra G0 e G1...la simulazione si è fermata..
				mc_stati_C1CmdSimulaCont := 4;  			// continuo gestendo il piedino
				StatoIniziale_C1_NextCode := C1_NextCode;
			
			end_if;
				
			
		4:	
			 if(C1_NextCode = 0 ) then	//se il prossimo è un G0..alzo il piedino prima di continuare
				C1_CmdPiedinoGiu := FALSE;
            	C1_CmdPiedinoSu  := TRUE;
            	mc_stati_C1CmdSimulaCont := 5;	//vado  ad aspettare piedino alto
            else
            
				mc_stati_C1CmdSimulaCont := 7;	//continuo con il piedino alto
			end_if;
			
		5:
			if ( not C1_CmdPiedinoSu ) then	(* Entro quando il piedino è tornato alto *)
			
				mc_stati_C1CmdSimulaCont := 7;
			end_if;
		7: if (C1_CmdSimulaAvaCont) then	//se ancora il tasto avanti è premuto... salto e faccio FALSE e TRUE della variabile per far riscattare il Rise
				mc_stati_C1CmdSimulaCont := 10;
			else
				if (C1_CmdSimulaIndCont) then //se ancora il tasto dietro è premuto... salto e faccio FALSE e TRUE della variabile per far riscattare il Rise
					mc_stati_C1CmdSimulaCont := 12;
				else
					mc_stati_C1CmdSimulaCont := 0;	//se ho lasciato i tasti avanti e dietro mi fermo.
				end_if;

			
			
			end_if;
			
		10:
			if(C1_NextCode >= 0) then 
				C1_CmdSimulaAvaCont := FALSE;
				mc_stati_C1CmdSimulaCont := 11;
			else
				mc_stati_C1CmdSimulaCont := 0;	
			
			end_if;	
			
		11:
			C1_CmdSimulaAvaCont := TRUE;
			mc_stati_C1CmdSimulaCont := 0;	
			
		12:
			if(C1_NextCode >= 0) then 
				C1_CmdSimulaIndCont := FALSE;
				mc_stati_C1CmdSimulaCont := 13;
			else
				mc_stati_C1CmdSimulaCont := 0;	
			
			end_if;					
		13:
		
			C1_CmdSimulaIndCont := TRUE;
			mc_stati_C1CmdSimulaCont := 0;	
		
		
	else
		mc_stati_C1CmdSimulaCont :=0;
	end_case;	
		
		



end_if;

	(* -------------#M210618_DA#  -------------- *)
	(* "PARTENZA CON SIMULAZIONE ATTIVA *)
	(* ----------------------------------------- *)
//Time_PartenzaSimulaAuto (in := PartenzaSimulaAuto , pt:= 1000);
Rise_Partenza_in_simulazione ( in := VB_CHN_AUTO_RUNNING and C1_CuciSimulaAuto and C1_CmdHoldRelease ); 
if(	Rise_Partenza_in_simulazione.q) then

	C1_CmdSimulaAvaCont := FALSE;


end_if;



Fall_C1_CuciSimulaAuto (in := C1_CuciSimulaAuto);
if(Fall_C1_CuciSimulaAuto.q) then
	

	C1_CmdSimulaAvaCont := FALSE;	//ferma simulazione continua
end_if;//flag simulazione arrivata all'ultimo punto
Rise_SimulaArrivatoAllaFine (in := C1_NextCode = -3 and C1_CuciSimulaAuto);
if(Rise_SimulaArrivatoAllaFine.q) then
	C1_FinitoSimulazione := TRUE;
	C1_CmdHoldRelease := FALSE;

	C1_CuciSimulaAuto := FALSE;
	C1_NextCode := -99;
end_if;
Ton_C1_FinitoSimulazione (in := C1_FinitoSimulazione , pt:= 100);
if(Ton_C1_FinitoSimulazione.q) then
	C1_FinitoSimulazione := FALSE;
end_if;
(*-------------------------------------- 
 Riposizionamento sul punto dopo un JOG
 ---------------------------------------*)
if ( C1_CmdRiposiziona and C1_CmdHoldRelease and VB_CHN_AUTO_RUNNING and ( C1_FaseAxAgo = 0 ) ) then
    vret := ExecPlcFun( PLC_CUCI_CMD, 150, 20 );
    C1_CmdRiposiziona := FALSE;
else
    C1_CmdRiposiziona := FALSE;
end_if;


(*-------------------- 
 Attesa tempo: 200 ms
 ---------------------*)
DelayTimer( in := FlgWaitTime, pt := 200 );
if ( DelayTimer.q ) then
    FlgWaitTime := FALSE;
end_if; 


(*---------------------------------------------------------------------------------------- 
 NOTA per la gestione Hold/Release durante la fermata temporanea di cucitura ( stato 0 )
    La funzione PLC_CUCI_CMD comando 4 e parametri 10 e 11 hanno effetto
    solo se la cucitrice e' temporaneamente ferma. In tutti gli altri 
    casi la funzione non ha alcun effetto. 
    
    Hold e Ripresa durante la cucitura sono gestiti da CN
    In questo caso si esce da G280 e VB_RUN e' false.     
 -----------------------------------------------------------------------------------------*)
(* Calcolo velocita' dell'asse ago *)
(* La velocita'impostata nei parametri e' il limite massimo            *)
(* Nell'header del profilo si imposta la velocita' di lavoro           *)
(* Durante la cucitura si puo' cambiare la velocita' scrivendo la VCD1 *)
(* Si puo' impostare una riduzione velocita': C1_VelRiduzioneRPM       *)   

VcdIdx := (C1_CHN*1000)+VCD_RPM_AGO_IDX;
vret := ExecPlcFun( PLC_VCD_TO_VD, VD_TMP_CALC_IDX, VcdIdx );
VdTmpCalc := VdTmpCalc * 1000.0;
C1_RpmAgoInProfilo := 0; (*TO_DINT( VdTmpCalc ); 02/05/2023 modifica insieme al firmware per avere la look ahead con i codici di rallentamento*) 

if ( C1_RpmAgoInProfilo > 0 ) then
    RpmFix3 := C1_RpmAgoInProfilo; 
else
    if ( C1_UdfVelLavRPM > 0 ) then
        RpmFix3 := C1_UdfVelLavRPM;
    else
        RpmFix3 := C1_ParVelLavRPM;
    end_if;
end_if;

if ( ( C1_VelRiduzioneRPM > 0 ) and ( C1_VelRiduzioneRPM < RpmFix3 ) ) then
    RpmFix3 := C1_VelRiduzioneRPM;
end_if;

if ( RpmFix3 > C1_ParVelLavRPM ) then
    C1_VelLimitRPM := TO_INT( C1_ParVelLavRPM / 1000 );
else
    C1_VelLimitRPM := TO_INT( RpmFix3 / 1000 );
end_if;




(* --------------------------- *)
(* MACCHINA A STATI - ASSE AGO *)
(* --------------------------- *)


 
case ( C1_PlcStatoAgo ) of
    
(* Stato 0: Attesa comando di movimento asse ago *)
(*          Se ciclo automatico run: piedino giu *)
(*          Se richiesto hold: passa in stato 5  *)
    0:  if ( VB_CHN_AUTO_RUNNING and ( C1_CmdHoldHMI or C1_CmdHoldRelease ) ) then
            C1_CmdHoldRelease := TRUE;
            vret := ExecPlcFun( PLC_CUCI_CMD, 104, 0 ); (* Ferma il task *)
            if ( C1_VbFlgJtaskRunning = TRUE ) then     (* HOLD - #M210511_1GF# *)
                VB_CHN_STOP_HOLD := TRUE;
            end_if;
            C1_PlcStatoAgo := 3;
        end_if;
                
        if ( CmdStartAgo ) then
       
            CmdStartAgo := FALSE;
   
                    
                (* il ciclo parte solo se automatico run e si deve far partire l'ago *)
            if ( VB_CHN_AUTO_RUNNING ) then
                C1_CmdPiedinoSu  := FALSE;
                C1_CmdPiedinoGiu := TRUE;
            
                    (* Imposta eventuale limite *)
                vret := ExecPlcFun( PLC_CUCI_CMD, 108, C1_VelLimitRPM );                

                C1_PlcStatoAgo := 10;
            end_if; 
        end_if;


(* Stato 3: Stato di HOLD - preapara il timer di attesa prima di accettare un release *)
    3:  FlgWaitTime := TRUE;  
        C1_PlcStatoAgo := 4;


(* Stato 4: Stato di HOLD - attesa timer prima di accettare un release *)
    4:  if ( FlgWaitTime = FALSE ) then   
            vret := ExecPlcFun( PLC_CUCI_CMD, 104, 80 );    (* Forza uscita da G280 - #M210330_1GF# *)
            C1_PlcStatoAgo := 5;
        end_if; 


(* Stato 5: Stato di HOLD - attesa release *)
    5:  if ( ( C1_CmdReleaseHMI = TRUE ) and ( C1_CmdHoldHMI = FALSE ) ) then
            vret := ExecPlcFun( PLC_CUCI_CMD, 104, 80 );    (* Forza uscita da G280 *)
            VB_CHN_RELEASE := TRUE;
            C1_PlcStatoAgo := 6;
        end_if; 


(* Stato 6: Stato di HOLD - attesa uscita da G280 o ingresso nel loop hold *)
(*                          verifica se e' stato ripremuto hold            *)  
    6:  if ( C1_VbFlgJtaskRunning = TRUE and C1_CmdHoldHMI = TRUE ) then
            VB_CHN_STOP_HOLD := TRUE;
            C1_PlcStatoAgo := 5;
        else

            if ( C1_VbFlgG280Running = FALSE or C1_VbFlgJtaskLoopHold = TRUE ) then
                vret := ExecPlcFun( PLC_CUCI_CMD, 104, 1 ); (* Toglie l'hold *)
                C1_CmdHoldRelease := FALSE;
                C1_PlcStatoAgo := 0;
            end_if;
        
        end_if;

    
(* Stato 10: Attesa piedino giu (solo se automatico run ) *)        
    10: if ( VB_CHN_AUTO_RUNNING ) then
            if ( not C1_CmdPiedinoGiu ) then
    
                    (* Start movimento di cucitura dell'asse ago *)
                GoAxPlcAgoErrCode := 0;
                GoAxPlcAgoModule := 360000;
                GoAxPlcAgoVel := -100000;
                ipar := ((C1_AsseAGO*100)+1);
                vret := ExecPlcFun( PLC_MOVE_AX_TONDO, ipar, GOAX_PLC_AGO_IDX );   
                C1_PlcStatoAgo := 20; 
                (* abilito la camma blocco filo *) 
                C1_VbEnableCammeIni := TRUE ;
                  
            end_if;
        else                
            C1_PlcStatoAgo := 0;    
        end_if;


(* Stato 20: Gestisce limite RPM asse ago *)
(*           Attesa ago fermo             *)
(*           Test comando hold            *)  
    20: vret := ExecPlcFun( PLC_CUCI_CMD, 108, C1_VelLimitRPM );
    
        if ( C1_FaseAxAgo = 0 ) then

                (* Rollover asse ago *)
            RollPlcAgoModule := 360000;
            RollPlcAgoQuo := 0;
            ipar := ((C1_AsseAGO * 100)+1);
            vret := ExecPlcFun( PLC_ROLLOVER_AX, ipar, ROLL_PLC_AGO_IDX );   

                (* Movimento a quota di ago alto *)
            MovePlcAgoErrCode := 0;
            MovePlcAgoQuoObj  := C1_AgoAlto;
            MovePlcAgoVel := -100000;
            MovePlcAgoFuture := 0;
            ipar := (C1_AsseAGO*100);
            vret := ExecPlcFun( PLC_MOVE_AX, ipar, MOVE_PLC_AGO_IDX );      

            C1_PlcStatoAgo := 25;   
        end_if;

            (* Hold viene visto solo in fase lineare *)
        if ( ( C1_CmdHoldHMI = TRUE ) and ( C1_FaseAxAgo = 2 ) ) then
            C1_CmdHoldRelease := TRUE;
            vret := ExecPlcFun( PLC_CUCI_CMD, 104, 0 );  (* Ferma il task *)

            vret := ExecPlcFun( PLC_CUCI_CMD, 108, To_Int( C1_RpmRall / 1000 ) );       
            MemActPnt := C1_VqActPntCuci;
            C1_PlcStatoAgo := 40;   
        end_if;     


(* Stato 25: Attesa ago a quota di ago alto *)
(*           Test comando hold              *)
    25: if ( C1_FaseAxAgo = 0 ) then
            C1_CmdPiedinoGiu := FALSE;
            C1_CmdPiedinoSu  := TRUE;
            C1_PlcStatoAgo := 30;   
        end_if;    
        if ( ( C1_CmdHoldRelease = FALSE ) and ( C1_CmdHoldHMI = TRUE ) ) then
            C1_CmdHoldRelease := TRUE;
            vret := ExecPlcFun( PLC_CUCI_CMD, 104, 0 );  (* Ferma il task *)
        end_if;


(* Stato 30: trucco per far avanzare prima il traslatore*)
    30:
        
        if(Vn120_AppEnbScambioPinzeC1_Car2 = 0) then
         	if(Vb4513_AppEnbCucitrice2 = TRUE or (Vb4513_AppEnbCucitrice2 =FALSE and Vb4515_AppEnbScaricatore = TRUE)) then
        		Vb90_AnticipoTrasl_SX := TRUE;
         		
         		
         		
         		if( not VbChn3AutoRun) then
         			VbChn3Start := TRUE ;
				end_if;
         		
         		GoAxPlcCaricErrCode := 0;
				GoAxPlcCariObj := Vq3522_PosizioneTraslCaricoTascaC1 ;
				GoAxPlcCaricVel:= -Vq3530_VelocitaTraslRiposo ; 
				GoAxPlcCaric := 0;
				
				ipar := ((C2_AsseCAR*100)+1);
                vret := ExecPlcFun( PLC_MOVE_AX, ipar, GOAX_PLC_CARIC_IDX );  
         		
         		
         	end_if;
        end_if; 
        C1_PlcStatoAgo := 35;   	
(* Stato 35: Attesa piedino su *)
	 35:
	 	if ( not C1_CmdPiedinoSu ) then
            C1_PlcStatoAgo := 0;
        end_if; 
	
(***********************************)
(* Stato 40: Gestione comando Hold *)
(*           Attende fase dec      *)
    40: if ( C1_FaseAxAgo = 3 ) then
            C1_PlcStatoAgo := 42;   
        end_if; 

            (* Se dovesse perdersi l'evento di asse ago in decelerazione *)
        if ( ( C1_VqActPntCuci - MemActPnt ) >= 3 ) then        
            C1_PlcStatoAgo := 42;   
        end_if; 

            (* Per ogni evenienza, in caso di asse fermo *)
        if ( C1_FaseAxAgo = 0 ) then
            C1_PlcStatoAgo := 46;   
        end_if;


(* Stato 42: Gestione comando Hold *)
(*           Attende fase lin      *)
    42: if ( C1_FaseAxAgo = 2 ) then
            MemActPnt := C1_VqActPntCuci;
            C1_PlcStatoAgo := 44;   
        end_if;     

            (* Per ogni evenienza, in caso di asse fermo *)
        if ( C1_FaseAxAgo = 0 ) then
            C1_PlcStatoAgo := 46;   
        end_if;


(* Stato 44: Gestione comando Hold          *)
(*           Attende punti di rallentamento *)
(*           Viene dato il comando di HOLD  *)
(*           Il CN esce dalla G280          *)       
    44: if ( ( C1_VqActPntCuci - MemActPnt ) >= ( C1_PtRall / 1000 ) ) then
            C1_VbHoldCuci := TRUE;
            C1_PlcStatoAgo := 46;   
        end_if;     

            (* Per ogni evenienza, in caso di asse fermo *)
        if ( C1_FaseAxAgo = 0 ) then
            C1_VbHoldCuci := TRUE;      (* HOLD CUCITRICE *)
            C1_PlcStatoAgo := 46;   
        end_if;


(* Stato 46: Gestione comando Hold  *)
(*           Attesa ago fermo       *)
    46: if ( C1_FaseAxAgo = 0 ) then

                (* Rollover asse ago *)
            RollPlcAgoModule := 360000;
            RollPlcAgoQuo := 0;
            ipar := ((C1_AsseAGO * 100)+1);
            vret := ExecPlcFun( PLC_ROLLOVER_AX, ipar, ROLL_PLC_AGO_IDX );   

                (* Movimento a quota di ago alto *)
            MovePlcAgoErrCode := 0;
            MovePlcAgoQuoObj  := C1_AgoAlto;
            MovePlcAgoVel := -100000;
            MovePlcAgoFuture := 0;
            ipar := (C1_AsseAGO*100);
            vret := ExecPlcFun( PLC_MOVE_AX, ipar, MOVE_PLC_AGO_IDX );      

            C1_PlcStatoAgo := 48;   
        end_if;


(* Stato 48: Gestione comando Hold                     *)
(*           Attesa ago a quota di ago alto            *)
    48: if ( C1_FaseAxAgo = 0 ) then   
            C1_PlcStatoAgo := 3;    
        end_if;


(* Default switch case *)
else
    C1_PlcStatoAgo := 0;    
end_case;

/**/
Rise_C1_CuciSimulaAuto (in:= C1_CuciSimulaAuto);
if(Rise_C1_CuciSimulaAuto.q and Vb42_PrimaTasca_C1) then 
	Vb43_TestCuciPrimaTasca_C1 := TRUE;
end_if;


]]>
					</sourceCode>
				</program>
				<program name="C1_AppMacchina" version="1.0.0" creationDate="0" lastModifiedDate="1702997245" excludeFromBuild="FALSE">
					<vars>
						<localVars>
							<var name="CmdSu" type="BOOL"/>
							<var name="CmdGiu" type="BOOL"/>
							<var name="TimePiedinoSu" type="Ton"/>
							<var name="TimePiedinoGiu" type="Ton"/>
							<var name="RisePiedinoSu" type="RiseEdge"/>
							<var name="RisePiedinoGiu" type="RiseEdge"/>
							<var name="RiseSbloccoAgo" type="RiseEdge"/>
							<var name="FallSbloccoAgo" type="FallEdge"/>
							<var name="ReqStdFoll" type="BOOL"/>
							<var name="ReqGantryFoll" type="BOOL"/>
							<var name="AppAgoAltoC1" type="INT"/>
							<var name="RitOnAsseAgoC1" type="Ton"/>
							<var name="RitOnAsseAgoC1_2" type="Ton"/>
							<var name="Rise_Vn3804_PageID" type="RiseEdge"/>
							<var name="Fall_Vn3804_PageID" type="FallEdge"/>
							<var name="Rise_C1_CmdPiedinoGiu" type="RiseEdge"/>
							<var name="Rise_C1_CmdPiedinoSu" type="RiseEdge"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[(* ========================================================================== 
(* SIPRO - Siax M															  	
(*                                                                            
(* COMPANY:     JAM INTERNATIONAL                                             
(*                                                                            
(* NAME: C1_AppMacchina                                                          
(*
(* TASK MAIN	 
(*
(* DESCRIPTION: APPLICAZIONE SPECIFICA DELLA MACCHINA ( CUCITRICE 1 )
(*
(* NOTE:                                NAME:           VER:    DATE:         
(* -------------------------------------------------------------------------  
(* Prima stesura                        gf              1.0     29/04/2021    
(* Ultima modifica                                                            
(* ========================================================================== *)


	(* Lettura stato asse  per verifica AGO fermo *)
if (( VnStatoAx3 & 2 ) = 2 ) then
	C1_AsseAgoFermo := FALSE ;
else
	C1_AsseAgoFermo := TRUE ;
end_if;


	(* Comandi alza abbassa piedino *)
CmdSu  := ( C1_CmdPiedinoSu  and not C1_CmdPiedinoGiu );
CmdGiu := ( C1_CmdPiedinoGiu and not C1_CmdPiedinoSu  );	

RisePiedinoSu(  in := CmdSu  );
RisePiedinoGiu( in := CmdGiu );

Rise_C1_CmdPiedinoGiu (in:= C1_CmdPiedinoGiu);
Rise_C1_CmdPiedinoSu (in:= C1_CmdPiedinoSu);

if ( RisePiedinoSu.q ) then
	if ( o17_C1_Piedino ) then
		C1_CmdPiedinoSu := FALSE;
		CmdSu := FALSE;
	end_if;
	
	o17_C1_Piedino := TRUE;			
end_if;

if ( RisePiedinoGiu.q ) then
	if ( not o17_C1_Piedino ) then 
		C1_CmdPiedinoGiu := FALSE;
		CmdGiu := FALSE;			
	end_if;
	
	o17_C1_Piedino := FALSE;			
end_if; 

TimePiedinoSu(  in := CmdSu,  pt := To_Udint( C1_TSalitaPiedino ) );	
TimePiedinoGiu( in := CmdGiu, pt := To_Udint(C1_TDiscesaPiedino ) );	

if ( TimePiedinoSu.q ) then
	C1_CmdPiedinoSu := FALSE;		
end_if;

if ( TimePiedinoGiu.q ) then
	C1_CmdPiedinoGiu := FALSE;	
end_if;

(*se arriva un comando piedino giu mentre sto aspettando il ritardo di piedino su...lo annullo*)
if(Rise_C1_CmdPiedinoGiu.q and C1_CmdPiedinoSu) then
		C1_CmdPiedinoGiu := FALSE;

end_if;
(*se arriva un comando piedino su mentre sto aspettando il ritardo di piedino giu...lo annullo*)
if(Rise_C1_CmdPiedinoSu.q and C1_CmdPiedinoGiu) then
		C1_CmdPiedinoSu := FALSE;

end_if;



(* --- Gestione inseguimento crochet --- *)

(* Aggancio inseguimento gantry *)
if ( C1_CmdGantryCrochet ) then
	VN_AX4_FOLL_MODE := 3;
	ipar := ((C1_AsseCRO*100)+71);
	vret := ExecPlcFun( PLC_ENABLE_FOLLOW, ipar, C1_GANTRY_INFO_IDX );      
	C1_CmdGantryCrochet := FALSE;
end_if;

(* Aggancio inseguimento standard 1:1 *)
if ( C1_CmdStdFollowCrochet ) then
	VN_AX4_FOLL_MODE := 1;
	ipar := (C1_AsseCRO*100);
	vret := ExecPlcFun( PLC_ENABLE_FOLLOW, ipar, 0 );      
	C1_CmdStdFollowCrochet := FALSE;
end_if;

(* Sgancio inseguimento gantry *)
if ( C1_CmdSganciaCrochet ) then
	ipar := (C1_AsseCRO*100);
	vret := ExecPlcFun( PLC_DISABLE_FOLLOW, ipar, 0 );      
	C1_CmdSganciaCrochet := FALSE;
end_if;

(* --- Gestione sblocco AGO per movimenti "a mano" se l'asse ago è fermo --- *)
	if ( not C1_AsseAgoFermo or ( VbChn1AutoRun and not C1_CmdHoldRelease ))then 
		C1_CmdSbloccaAgo := FALSE ;
	end_if;

RiseSbloccoAgo(  in := C1_CmdSbloccaAgo and C1_AsseAgoFermo );
FallSbloccoAgo(  in := C1_CmdSbloccaAgo  );
		
if ( RiseSbloccoAgo.q ) then
	C1_CmdSganciaCrochet := TRUE;		(* Sgancia inseguimento *)
	VB_AX3_PID_DISAB     := TRUE;		(* Disabilita PID AGO   *)	
	VN_AX3_CMD_DRIVE     := 1;		 	(* Disabilita drive     *)
	ReqStdFoll           := TRUE;       (* Req inseg. std 1:1   *)
	AppAgoAltoC1		 := 99 ; 		(* azzero variabile riposizionamento ago alto *) (*qui*)
end_if;

if ( ReqStdFoll and not C1_CmdSganciaCrochet ) then
	ReqStdFoll := FALSE;	
	C1_CmdStdFollowCrochet := TRUE;		(* Aggancia inseg. 1:1  *)
end_if;	


if ( FallSbloccoAgo.q ) then
	C1_CmdSganciaCrochet := TRUE;		(* Sgancia inseguimento *)
	VB_AX3_PID_DISAB     := FALSE;		(* Abilita PID AGO      *)	
	VN_AX3_CMD_DRIVE     := 0;		 	(* Abilita drive        *)	
	ReqGantryFoll        := TRUE;		(* Req. inseg. gantry   *)
end_if;

if ( ReqGantryFoll and not C1_CmdSganciaCrochet ) then
	ReqGantryFoll := FALSE;	
	C1_CmdGantryCrochet := TRUE;	    (* Aggancia gantry      *)
	AppAgoAltoC1 := 1 ; 					(* variabile riposizionamento ago alto *) (*qui*)
end_if;	





(* attesa riaggancio asse ago *)
RitOnAsseAgoC1 ( in := ( AppAgoAltoC1 = 1 or Vb4008_AgoSu_C1) ,  pt := 100 );

	if ( RitOnAsseAgoC1.q and (AppAgoAltoC1 = 1 or  Vb4008_AgoSu_C1)) then
		Vb4008_AgoSu_C1 := FALSE;
                (* Rollover asse ago *)
          RollPlcAgoModule := 360000;
          RollPlcAgoQuo := 0;
          ipar := ((C1_AsseAGO*100)+1);
          vret := ExecPlcFun( PLC_ROLLOVER_AX, ipar, ROLL_PLC_AGO_IDX );   

		AppAgoAltoC1 := 2 ; 					
	end_if;
	
RitOnAsseAgoC1_2 (  in := AppAgoAltoC1 = 2 ,  pt := 10 );
	
		(* riposiziono ad ago alto *)	
if ( RitOnAsseAgoC1_2.q and AppAgoAltoC1 = 2 and not Vb4088_TestDisableRiposizionaAgo ) then

	
	if ( PosAx_C1_AsseAGO <= 180000 and AppAgoAltoC1 = 2 )then

                (* Movimento a quota di ago alto *)
            MovePlcAgoErrCode := 0;
            MovePlcAgoQuoObj  := C1_AgoAlto;
            MovePlcAgoVel := -5000;
            MovePlcAgoFuture := 0;
            ipar := (C1_AsseAGO*100);
            vret := ExecPlcFun( PLC_MOVE_AX, ipar, MOVE_PLC_AGO_IDX );      
		AppAgoAltoC1 := 3 ; 					
	end_if;
	
	if ( ( PosAx_C1_AsseAGO > 180000 and PosAx_C1_AsseAGO < ( 360000 + C1_AgoAlto ) ) and AppAgoAltoC1 = 2 )then
                (* Movimento a quota di ago alto *)
            MovePlcAgoErrCode := 0;
            MovePlcAgoQuoObj  := 360000 + C1_AgoAlto;
            MovePlcAgoVel := -5000;
            MovePlcAgoFuture := 0;
            ipar := (C1_AsseAGO*100);
            vret := ExecPlcFun( PLC_MOVE_AX, ipar, MOVE_PLC_AGO_IDX );      

		AppAgoAltoC1 := 3 ; 					
	end_if;

end_if;	
	

if ( AppAgoAltoC1 = 3 and C1_AsseAgoFermo ) then
		AppAgoAltoC1 := 0 ;
end_if;	

(* se non riposiziono l'ago alto resetto tutto *)
if ( AppAgoAltoC1 = 2 and C1_AsseAgoFermo and Vb4088_TestDisableRiposizionaAgo ) then
		AppAgoAltoC1 := 0 ;
end_if;	
(*su questa pagina non faccio il riposizionamento dell'ago*)
Rise_Vn3804_PageID (in:= (Vn3804_PageID = 1004 or Vn3804_PageID = 1002));
Fall_Vn3804_PageID (in:=  (Vn3804_PageID = 1004 or Vn3804_PageID = 1002));
if(Rise_Vn3804_PageID.q) then
	Vb4088_TestDisableRiposizionaAgo := TRUE;
	Vb4075_GiraAgoFaiSpolaC1 := FALSE;
end_if;
if(Fall_Vn3804_PageID.q) then
	Vb4088_TestDisableRiposizionaAgo := FALSE;
end_if;


(* pinza C1 alta per HMI *)

	if ( not i23_C1_PinzaIntBassa and i24_C1_PinzaEstAlta and o18_C1_Pinza_int and o19_C1_Pinza_est )then
		Vb4806_AppPinzaAltaC1 := TRUE ;
	else
		Vb4806_AppPinzaAltaC1 := FALSE ;
	end_if;
	
(* C1 attivo raffreddamento ago quando la velocità supera una soglia *)
if ( Vb4_C1_InCucitura and Vb23_CmdRaffreddamentoAgo_C1 and (C1_VqRpmAgoCuci > C1_SogliaVelRaffAgo ) ) then

	Vb4353_AppAut_o21_C1_RaffreddamentoAgo := TRUE;

else
	
	Vb4353_AppAut_o21_C1_RaffreddamentoAgo := FALSE;

end_if;

(* C2 attivo raffreddamento ago quando la velocità supera una soglia *)
if ( Vb5_C2_InCucitura and Vb24_CmdRaffreddamentoAgo_C2 and (C2_VqRpmAgoCuci > C2_SogliaVelRaffAgo ) ) then

	Vb4385_AppAut_o53_C2_RaffreddamentoAgo := TRUE;

else
	
	Vb4385_AppAut_o53_C2_RaffreddamentoAgo := FALSE;

end_if;
	
	
	


]]>
					</sourceCode>
				</program>
				<program name="C1_CuciRtc" version="1.0.0" creationDate="0" lastModifiedDate="1703066425" excludeFromBuild="FALSE">
					<vars>
						<localVars>
							<var name="Rise_i10_Piegatore_Salito" type="RiseEdge"/>
							<var name="Fall_i10_Piegatore_Salito" type="FallEdge"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[(* ========================================================================== 
(* SIPRO - Siax M															  	
(*                                                                            
(* COMPANY:     JAM INTERNATIONAL                                             
(*                                                                            
(* NAME: C1_CucìRtc                                                          
(*
(* TASK RTC_AX	 
(*
(* DESCRIPTION: Operazioni da eseguire al tick di sistema ( CUCITRICE 1 )
(*
(*		#### NON MODIFICARE ####
(*                                                                             
(* NOTE:                                NAME:           VER:    DATE:         
(* -------------------------------------------------------------------------  
(* Prima stesura                        gf              1.0     29/04/2021    
(* Ultima modifica                                                            
(* ========================================================================== *)


(*---------------------------------------------------------------------------
 Variabile END CUCITRICE
 Viene messa a TRUE dal firmware quando, sul fronte di salita della
 soglia di start movimento, non ci sono piu' punti da eseguire. 
 Viene usata dal firmware per terminare l'esecuzione dell'istruzione G280.	
 Il PLC la riporta al valore FALSE quando anche la VbRunCuci ritorna a FALSE
 ----------------------------------------------------------------------------*)
if ( ( C1_VbEndCuci = TRUE ) and ( C1_VbRunCuci = FALSE ) ) then
	C1_VbEndCuci := FALSE;
end_if;


(*-------------------------------------------------------------------- 
 Variabile RASAFILO
 Viene messa a TRUE dal firmware quando, sul fronte di salita della
 soglia di start movimento, non ci sono piu' punti da eseguire. 	
 Il PLC la riporta al valore FALSE
 ---------------------------------------------------------------------*)
if ( C1_VbRasafCuci = TRUE ) then
	C1_VbRasafCuci := FALSE;

	C1_CuciLastPoint := FALSE;
end_if;

(*-------------------------------------------------------------------- 
 Variabile LAST POINT
 Viene messa a TRUE dal firmware quando, sul fronte di salita della
 soglia di start movimento, viene eseguito l'ultimo punto. 	
 Il PLC la riporta al valore FALSE
 
 C1_CuciLastPointEnaStop abilita lo stop dell'aggo.
 Lo stop avviene quando si entra nella camma di stop ago alto:
 in pratica si attende che l'ago oltrepassi una volta la quota di stop 
 prima di dare il comando di fermata alla quota di stop.
  ---------------------------------------------------------------------*)
if ( C1_VbLastPnt = TRUE ) then
	C1_VbLastPnt := FALSE;

	C1_CuciLastPoint := TRUE;
	C1_CuciLastPointEnaStop := TRUE;
	C1_CuciLastPointAxC := TRUE;
end_if;



(*-------------------------------------------------------------------- 
 Comando di fermata dell'asse ago:
 Dopo il LAST POINT si attende la camma di stop ago alto
 Vengono anche abilitate le camme di apritensione e di coltello
  ---------------------------------------------------------------------*)
if ( C1_CuciLastPointEnaStop and C1_CammaStopAgoAlto ) then
	C1_CuciLastPointEnaStop := FALSE;

			(* Stop in fase asse ago *)
	StopPlcAgoErrCode := 0;
	StopPlcAgoQuoObj  := C1_StopAgo;
	StopPlcAgoFuture  := 0;
	iparRtcAx := (C1_AsseAGO*100);
	vret := ExecPlcFun( PLC_CHG_QUO_OBJ_AX, iparRtcAx, STOP_PLC_AGO_IDX );		

		(* Abilita camme apritensione e coltello *)
	C1_VbEnableCamme := TRUE;
end_if;	

(*-------------------------------------------------------------------- 
cerco di leggere al volo il sensore del piegatore quando sale
 ---------------------------------------------------------------------*)

Rise_i10_Piegatore_Salito (in:= i10_Piegatore_Salito);  
Fall_i10_Piegatore_Salito (in:= i10_Piegatore_Salito);  
if((i10_Piegatore_Salito or Rise_i10_Piegatore_Salito.q or Fall_i10_Piegatore_Salito.q) and  PiegatoreStaSalendo ) then
	Vb84PiegatoreRisalito := TRUE;
end_if;

]]>
					</sourceCode>
				</program>
				<program name="AppMainC3" version="1.0.0" creationDate="0" lastModifiedDate="1715346276" excludeFromBuild="FALSE">
					<vars>
						<localVars>
							<var name="RiseBootDone" type="RiseEdge"/>
							<var name="Par" type="INT"/>
							<var name="RiseAuto" type="RiseEdge"/>
							<var name="RiseVb4510_AppHmiCaricatore" type="RiseEdge"/>
							<var name="RiseVb4508_AppHmiPiegatore" type="RiseEdge"/>
							<var name="RiseVb4514_AppHmiScaricatore" type="RiseEdge"/>
							<var name="RiseVb4512_AppHmiCucitrice2" type="RiseEdge"/>
							<var name="RiseStartPassoPasso" type="RiseEdge"/>
							<var name="RiseVb4516_AppHmiScambioPinzeC1_Car2" type="RiseEdge"/>
							<var name="RiseVbChn1Start" type="RiseEdge"/>
							<var name="Chn1Start" type="BOOL"/>
							<var name="Chn1StartTIM" type="UDINT"/>
							<var name="Rise_Valvolone" type="RiseEdge"/>
							<var name="FallAuto" type="FallEdge"/>
							<var name="RiseVb4510_AppHmiCaricatoreInAuto" type="RiseEdge"/>
							<var name="Rise_Vb4509_AppEnbPiegatore" type="RiseEdge"/>
							<var name="Rise_Vb4521_AppHmiTestPiegatore" type="RiseEdge"/>
							<var name="temp1" type="BOOL"/>
							<var name="temp2" type="BOOL"/>
							<var name="Rise_Vb4007_MemoriaAvviaCaric" type="RiseEdge"/>
							<var name="Sup_PrgName_1" type="STRING" length="32"/>
							<var name="Rise_Vb4512_AppHmiCucitrice2" type="RiseEdge"/>
							<var name="Rise_Vb4522_AppHmiTestTrasl" type="RiseEdge"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[(* ========================================================================== 
(* SIPRO - Siax M															  	
(*                                                                            
(* COMPANY:     JAM INTERNATIONAL                                             
(*                                                                            
(* NAME: AppMainC3                                                          
(*
(* TASK MAIN	 
(*
(* DESCRIPTION: Gestione applicazione Canale 3 
(*
(*                                                                             
(* NOTE:                                NAME:           VER:    DATE:         
(* -------------------------------------------------------------------------  
(* Prima stesura                        Jam             1.0     29/04/2021    
(* Ultima modifica                                                            
(* ========================================================================== *)

	(* Fronte di salita del fine del boot del CN *)
RiseBootDone( in:= VB_SYS_CNC_BOOT_DONE  );

	(* Set nome del programma CN del canale 3 *)
if RiseBootDone.q then
	Sup_PrgName := 'c:/cnc/prog/CicloAutomatico.obj';
	Par := ((SUP_CHN * 1000)+13);
	vret := ExecPlcFun( PLC_WRITE_FORK_VAR, Par, SUP_PRG_NAME_IDX );
end_if;

	(* Lettura posizione assi *)
ipar := ((C1_AsseX*100)+16);	
vret := ExecPlcFun( PLC_READ_AX_QUOTE, ipar, POS_AX_VQ_BASE_IDX + C1_AsseX );

ipar := ((C1_AsseY*100)+16);
vret := ExecPlcFun( PLC_READ_AX_QUOTE, ipar, POS_AX_VQ_BASE_IDX + C1_AsseY );

ipar := ((C1_AsseAGO*100)+16);
vret := ExecPlcFun( PLC_READ_AX_QUOTE, ipar, POS_AX_VQ_BASE_IDX + C1_AsseAGO );

ipar := ((C1_AsseCRO*100)+16);
vret := ExecPlcFun( PLC_READ_AX_QUOTE, ipar, POS_AX_VQ_BASE_IDX + C1_AsseCRO );

ipar := ((C1_AsseCAR*100)+16);
vret := ExecPlcFun( PLC_READ_AX_QUOTE, ipar, POS_AX_VQ_BASE_IDX + C1_AsseCAR );

ipar := ((C2_AsseX*100)+16);	
vret := ExecPlcFun( PLC_READ_AX_QUOTE, ipar, POS_AX_VQ_BASE_IDX + C2_AsseX );

ipar := ((C2_AsseY*100)+16);	
vret := ExecPlcFun( PLC_READ_AX_QUOTE, ipar, POS_AX_VQ_BASE_IDX + C2_AsseY );

ipar := ((C2_AsseAGO*100)+16);	
vret := ExecPlcFun( PLC_READ_AX_QUOTE, ipar, POS_AX_VQ_BASE_IDX + C2_AsseAGO );

ipar := ((C2_AsseCRO*100)+16);	
vret := ExecPlcFun( PLC_READ_AX_QUOTE, ipar, POS_AX_VQ_BASE_IDX + C2_AsseCRO );

ipar := ((C2_AsseCAR*100)+16);	
vret := ExecPlcFun( PLC_READ_AX_QUOTE, ipar, POS_AX_VQ_BASE_IDX + C2_AsseCAR );


	(* Uscita abilitazione assi step *)
o32_Enable_AssiXY_C1 := not VbSimulaDbg and VB_SYS_CNC_ENABLED and VB_SYS_ECAT_OPERATIONAL;
o48_Enable_AssiXY_C2 := o32_Enable_AssiXY_C1;
	(* Flag macchina azzerata *)
case ( Vn_ID_macchina ) of

	882:
		MacchinaAzzerata := C1_AssiAzzerati and C2_AssiAzzerati and VB_AX5_ZEROED and VB_AX10_ZEROED; 
	862: (*862M*)
		MacchinaAzzerata := C1_AssiAzzerati and VB_AX5_ZEROED; 
	860: (*862HM*)
		MacchinaAzzerata := C1_AssiAzzerati and VB_AX5_ZEROED; 
end_case;





(************************************* AGGIUNGERE SOTTO ****************************************************)
(************************************* AGGIUNGERE SOTTO ****************************************************)
(************************************* AGGIUNGERE SOTTO ****************************************************)
(************************************* AGGIUNGERE SOTTO ****************************************************)
(* metto a 1 la vb per capire quando sono in allarme *)
	if (( VN_SYS_OMNI_OPER & 1024 ) = 1024 ) then
		Vb4503_CN_Allarme := TRUE;
	else;
		Vb4503_CN_Allarme := FALSE;
	end_if;



	(* Lettura stato asse  per verifica X  fermo *)
if (( VnStatoAx1 & 2 ) = 2 ) then
	Vb4045_C1_AxXFermo := FALSE ;
else
	Vb4045_C1_AxXFermo := TRUE ;
end_if;

	(* Lettura stato asse  per verifica Y  fermo *)
if (( VnStatoAx2 & 2 ) = 2 ) then
	Vb4046_C1_AxYFermo := FALSE ;
else
	Vb4046_C1_AxYFermo := TRUE ;
end_if;

	(* Lettura stato asse  Ago  fermo *)
if (( VnStatoAx3 & 2 ) = 2 ) then
	Vb4047_C1_AxAgoFermo := FALSE ;
else
	Vb4047_C1_AxAgoFermo := TRUE ;
end_if;

	(* Lettura stato asse  Crochette  fermo *)
if (( VnStatoAx4 & 2 ) = 2 ) then
	Vb4048_C1_AxCroFermo := FALSE ;
else
	Vb4048_C1_AxCroFermo := TRUE ;
end_if;

	(* Lettura stato asse  per verifica caricatore  fermo *)
if (( VnStatoAx5 & 2 ) = 2 ) then
	 Vb4049_C1_AsseCARFermo := FALSE ;
else
	 Vb4049_C1_AsseCARFermo := TRUE ;
end_if;

	(* Lettura stato asse  per verifica X  fermo *)
if (( VnStatoAx6 & 2 ) = 2 ) then
	Vb4050_C2_AxXFermo := FALSE ;
else
	Vb4050_C2_AxXFermo := TRUE ;
end_if;

	(* Lettura stato asse  per verifica Y  fermo *)
if (( VnStatoAx7 & 2 ) = 2 ) then
	Vb4051_C2_AxYFermo := FALSE ;
else
	Vb4051_C2_AxYFermo := TRUE ;
end_if;

	(* Lettura stato asse  Ago  fermo *)
if (( VnStatoAx8 & 2 ) = 2 ) then
	Vb4052_C2_AxAgoFermo := FALSE ;
else
	Vb4052_C2_AxAgoFermo := TRUE ;
end_if;

	(* Lettura stato asse  Crochette  fermo *)
if (( VnStatoAx9 & 2 ) = 2 ) then
	Vb4053_C2_AxCroFermo := FALSE ;
else
	Vb4053_C2_AxCroFermo := TRUE ;
end_if;

	(* Lettura stato asse  per verifica caricatore  fermo *)
if (( VnStatoAx10 & 2 ) = 2 ) then
	 Vb4054_C2_AsseCARFermo := FALSE ;
else
	 Vb4054_C2_AsseCARFermo := TRUE ;
end_if;

	(* cucitrice 1 asse X + Y fermi *)
if ( Vb4045_C1_AxXFermo and Vb4046_C1_AxYFermo ) then
	 Vb4058_C1_AsseX_YFermo := TRUE ;
else
	 Vb4058_C1_AsseX_YFermo := FALSE ;
end_if;

	(* cucitrice 2 asse X + Y fermi *)
if ( Vb4050_C2_AxXFermo and Vb4051_C2_AxYFermo ) then
	 Vb4059_C2_AsseX_YFermo := TRUE  ;
else
	 Vb4059_C2_AsseX_YFermo := FALSE ;
end_if;


(* dopo emergenza controllo lo stato macchina prima di lanciare l'azzeramento *)
(* ritardo pressostato *)
//Riti35_Pressostato( in := (not i35_Pressostato and i21_Emg ), pt := 500 );

//if (Riti106_Pressostato.q) then
	case ( Vn_ID_macchina ) of
	
	882:

		if ( not Vb4503_CN_Allarme  and i5_FcPinzaCaricoAlta and i8_FcPiegatore_DI and i11_FcLancia_DI and i32_C1_ReadyAsseY and i31_C1_ReadyAsseX and  (not i24_C1_PinzaEstAlta or Vb81PremutoResetAccensione)  and i38_FcPinzaTraslAlta and i48_C2_ReadyAsseY and i47_C2_ReadyAsseX )then
			Vb4502_AppPosMacchinaPerZero := TRUE ;
		else
			Vb4502_AppPosMacchinaPerZero := FALSE ;
		end_if;
	862: (*862M*)
		if ( not Vb4503_CN_Allarme  and i5_FcPinzaCaricoAlta and i8_FcPiegatore_DI and i11_FcLancia_DI  and i32_C1_ReadyAsseY and i31_C1_ReadyAsseX and ( not i24_C1_PinzaEstAlta or Vb81PremutoResetAccensione))then
			Vb4502_AppPosMacchinaPerZero := TRUE ;
		
		else
			Vb4502_AppPosMacchinaPerZero := FALSE ;
		end_if;
	860: (*862HM*)
		if ( not Vb4503_CN_Allarme  and i5_FcPinzaCaricoAlta and i8_FcPiegatore_DI and i11_FcLancia_DI  and i32_C1_ReadyAsseY and i31_C1_ReadyAsseX and ( not i24_C1_PinzaEstAlta or Vb81PremutoResetAccensione))then
			Vb4502_AppPosMacchinaPerZero := TRUE ;
		
		else
			Vb4502_AppPosMacchinaPerZero := FALSE ;
		end_if;
	end_case;	
//end_if;	


(* dopo azzeramento controllo lo stato macchina prima di lanciare l'automatico *)
case ( Vn_ID_macchina) of
	
	882:

		if ( not Vb4503_CN_Allarme and i5_FcPinzaCaricoAlta and i8_FcPiegatore_DI and i11_FcLancia_DI  and not i23_C1_PinzaIntBassa and i32_C1_ReadyAsseY and i31_C1_ReadyAsseX and i24_C1_PinzaEstAlta and not i55_C2_FcPinzaIntBassa and i38_FcPinzaTraslAlta and i48_C2_ReadyAsseY and i47_C2_ReadyAsseX and not Vb4506_AppCambioPinzeRun )then
			Vb4504_AppPosMacchinaPerAutomatico := TRUE ;
		else
			Vb4504_AppPosMacchinaPerAutomatico := FALSE ;
		end_if;
	862: (*862M*)
		if ( not Vb4503_CN_Allarme and i5_FcPinzaCaricoAlta and i8_FcPiegatore_DI and i11_FcLancia_DI  and not i23_C1_PinzaIntBassa and i32_C1_ReadyAsseY and i31_C1_ReadyAsseX and i24_C1_PinzaEstAlta and not Vb4506_AppCambioPinzeRun )then
			Vb4504_AppPosMacchinaPerAutomatico := TRUE ;
		else
			Vb4504_AppPosMacchinaPerAutomatico := FALSE ;
		end_if;
	860: (*862HM*)
		if ( not Vb4503_CN_Allarme and i5_FcPinzaCaricoAlta and i8_FcPiegatore_DI and i11_FcLancia_DI  and not i23_C1_PinzaIntBassa and i32_C1_ReadyAsseY and i31_C1_ReadyAsseX and i24_C1_PinzaEstAlta and not Vb4506_AppCambioPinzeRun )then
			Vb4504_AppPosMacchinaPerAutomatico := TRUE ;
		else
			Vb4504_AppPosMacchinaPerAutomatico := FALSE ;
		end_if;
		
end_case;	





	


(* vb manuale automatico *)
RiseAuto( in := Vb4000_Automatico );
FallAuto( in := Vb4000_Automatico );


	if( RiseAuto.q )then
		if ( MacchinaAzzerata and i21_Emg and not Vb4506_AppCambioPinzeRun and not Vb4507_AppManAuto and Vb4504_AppPosMacchinaPerAutomatico )then
			Vb4507_AppManAuto := TRUE ;
		else;
			Vb4507_AppManAuto := FALSE ;
		end_if;
	end_if;
	
	if(FallAuto.q) then
		Vb4507_AppManAuto := FALSE ;
	
	end_if;


	if( Vb4507_AppManAuto )then
		EnbAutomatico := TRUE ;
		EnbManuale := FALSE ;
	else;
		EnbAutomatico := FALSE ;
		EnbManuale := TRUE ;
	end_if;




(* ingresso/uscita automatico *)
RiseEnbAutomatico(  in := Vb4507_AppManAuto );
FallEnbAutomatico(  in := Vb4507_AppManAuto );

(* ingresso/uscita automatico *)
RiseEnbManuale(  in := not Vb4507_AppManAuto );
FallEnbManuale(  in := not Vb4507_AppManAuto );


(* se entro in automatico inizializzo le cucitrici *)(* da togliere deve essere gestito da HMI *)
	if ( RiseEnbAutomatico.q )then
(*		Vb4804_AppReloadParamC1 := TRUE ; *)
(*		Vb4904_AppReloadParamC2 := TRUE ; *)
//		 C1_ReloadParam := TRUE;
//		 C2_ReloadParam := TRUE;
	end_if;



(* start automatico canale 3 per azzeramento *) 
(* se ho tutti i sensori in posizione parto per lo zero *)
Rise_i1_Pulsanti_start (in:= ((i1_Pulsanti_start or (Vb4007_MemoriaAvviaCaric and not VbChn3AutoRun))and not( C1_CuciSimulaAuto and not Vb4509_AppEnbPiegatore and not Vb4511_AppEnbCaricatore ) and not C2_CuciSimulaAuto ));


case ( Vn_ID_macchina ) of

882:

	if (( Vb4501_AppVbChn3StartHMI or Rise_i1_Pulsanti_start.q ) and not Vb4507_AppManAuto and not MacchinaAzzerata and Vb4502_AppPosMacchinaPerZero )then
		if(not Vn3804_PageID <= 1001) then  //pagina test I/O
			VbChn3Start := TRUE ;
		end_if;
	end_if;
	if (( Vb4501_AppVbChn3StartHMI or Rise_i1_Pulsanti_start.q ) and not Vb4507_AppManAuto and not MacchinaAzzerata and Vb4502_AppPosMacchinaPerZero and  not VbChn3AutoRun )then
		VnStatoCuci1 := 0 ;
		VnStatoCuci2 := 0 ;

	end_if;
862: (*862M*)
	if (( Vb4501_AppVbChn3StartHMI or Rise_i1_Pulsanti_start.q ) and not Vb4507_AppManAuto and not MacchinaAzzerata and Vb4502_AppPosMacchinaPerZero )then
		if(not Vn3804_PageID <= 1001) then  //solo pag emergenza e pagina Main
			VbChn3Start := TRUE ;
		end_if;
	
	end_if;
	if (( Vb4501_AppVbChn3StartHMI or Rise_i1_Pulsanti_start.q ) and not Vb4507_AppManAuto and not MacchinaAzzerata and Vb4502_AppPosMacchinaPerZero and  not VbChn3AutoRun )then
		VnStatoCuci1 := 0 ;
		VnStatoCuci2 := 0 ;
	end_if;
860: (*862HM*)	
	if (( Vb4501_AppVbChn3StartHMI or Rise_i1_Pulsanti_start.q ) and not Vb4507_AppManAuto and not MacchinaAzzerata and Vb4502_AppPosMacchinaPerZero )then
	if(not Vn3804_PageID <= 1001) then  //solo pag emergenza e pagina Main
			VbChn3Start := TRUE ;
		end_if;
	
	end_if;
	if (( Vb4501_AppVbChn3StartHMI or Rise_i1_Pulsanti_start.q ) and not Vb4507_AppManAuto and not MacchinaAzzerata and Vb4502_AppPosMacchinaPerZero and  not VbChn3AutoRun )then
		VnStatoCuci1 := 0 ;
		VnStatoCuci2 := 0 ;
	end_if;
end_case;	







	
(* start automatico canale 3 *) 
(*--------------------------piegatore----------------------------*)
(* se sono in step parto con la pedana *)
RiseStartPassoPasso(  in := (i3_C1_PedanaPiegatore and Vb4001_StepPiegatore ) );


(* se ho la lancia avanti in automatico parto prima tasca se utilizzo il piegatore *)
	if ( Vb4509_AppEnbPiegatore )then
		if ((( Rise_i1_Pulsanti_start.q or RiseStartPassoPasso.q ) and o9_Lancia_AD and Vb4507_AppManAuto ))then
			VbChn3Start := TRUE ;
		end_if;
		if (((Rise_i1_Pulsanti_start.q or RiseStartPassoPasso.q ) and o9_Lancia_AD and Vb4507_AppManAuto and  not VbChn3AutoRun  ))then
			VnStatoCuci1 := 0 ;
  			VnStatoCuci2 := 0 ;
		end_if;
	end_if;	
(* se ho la lancia avanti in automatico parto sono gia in ciclo resetto la macchina a stati se utilizzo il piegatore *)
	if ( Vb4509_AppEnbPiegatore )then
		if (((Rise_i1_Pulsanti_start.q or RiseStartPassoPasso.q ) and o9_Lancia_AD and Vb4507_AppManAuto and not Vb4010_PrgPiegatoreRun ))then
			Vb4004_AvvioPiegatore := TRUE ;
		end_if;
	end_if;		

(* abilito il cambio pinze *)
	if ( EnbManuale and MacchinaAzzerata  )then
		Vb4505_AppEnbCambioPinze := TRUE ;
	else;
		Vb4505_AppEnbCambioPinze := FALSE ;
	end_if;
		(* blocco le variabili a OFF *)
	if ( not Vb4505_AppEnbCambioPinze )then
		if(not Vn3804_PageID = 1005) then		//pagina Test IO
			Vb4139_AppMan_o7_Cambio_lame_lateral 	:= FALSE ;
			Vb4338_AppAut_o6_Cambio_lama_front 	:= FALSE ;
			Vb4137_AppMan_o5_Cambio_corpo 			:= FALSE ;
		end_if;
	end_if;


		(* blocco le variabili a OFF *)
	if ( not Vb4505_AppEnbCambioPinze and o18_C1_Pinza_int and o19_C1_Pinza_est and not EnbManuale)then
		Vb4157_AppMan_o25_C1_Cambio_Pinze 		:= FALSE ;
	end_if;



		(* blocco le variabili a OFF *)
	if ( not Vb4505_AppEnbCambioPinze and o50_C2_Pinza_int )then
		Vb4189_AppMan_o57_C2_Cambio_Pinze 		:= FALSE ;
	end_if;




	
(* abilito il cambio pinze *)
	if ( o7_Cambio_lame_lateral or o6_Cambio_lama_front or o5_Cambio_corpo or o25_C1_Cambio_Pinze or o57_C2_Cambio_Pinze )then
		Vb4506_AppCambioPinzeRun := TRUE ;
	else;
		Vb4506_AppCambioPinzeRun := FALSE ;
	end_if;





(* abilitazioni stazioni macchina *)
(*---------------------------------------------------------------------------------------------*)
(* abilitazione caricatore  *)

RiseVb4510_AppHmiCaricatore(  in :=  Vb4510_AppHmiCaricatore  and  Vb4049_C1_AsseCARFermo );


if ( RiseVb4510_AppHmiCaricatore.q and Vb4806_AppPinzaAltaC1 and not Vb4003_RqsStopPiegatore and not VbChn3AutoRun) then


	if(Vb4509_AppEnbPiegatore and not Vb4010_PrgPiegatoreRun and Vb4504_AppPosMacchinaPerAutomatico) then
		Vb4508_AppHmiPiegatore := TRUE;  //spengo piegatore
		Vb4511_AppEnbCaricatore := TRUE;	(* abilitazione caricatore se non era attivo*)
		Vb4510_AppHmiCaricatore := FALSE;
		Vn2CodiceAllarmeXHmi := 0;
		
		Vb4007_MemoriaAvviaCaric := FALSE;
	end_if;

	if(not Vb4507_AppManAuto and not Vb4511_AppEnbCaricatore and Vb4504_AppPosMacchinaPerAutomatico) then
	
		Vb4511_AppEnbCaricatore := TRUE;	(* abilitazione caricatore se non era attivo*)
		Vb4510_AppHmiCaricatore := FALSE;
		Vn2CodiceAllarmeXHmi := 0;
		
		
	else
		if(Vb4511_AppEnbCaricatore) then
			Vb4000_Automatico := FALSE;			(* se era attivo spengo prima Automatico e poi il suo fronte spegne Caricatore*)
			Vb4510_AppHmiCaricatore := FALSE;
		else
			Vb4510_AppHmiCaricatore := FALSE;	
		
			Vb4504_AppPosMacchinaPerAutomatico := FALSE ;
			if ( Vb4503_CN_Allarme) then
				Vn2CodiceAllarmeXHmi := 16;
			end_if;
			if ( not i5_FcPinzaCaricoAlta) then
				Vn2CodiceAllarmeXHmi := 17;
			end_if;
			if ( not i8_FcPiegatore_DI) then
				Vn2CodiceAllarmeXHmi := 18;
			end_if;
			if ( not i11_FcLancia_DI) then
				Vn2CodiceAllarmeXHmi := 19;
			end_if;
			if ( i23_C1_PinzaIntBassa) then
				Vn2CodiceAllarmeXHmi := 20;
			end_if;
			if (not i24_C1_PinzaEstAlta) then
				Vn2CodiceAllarmeXHmi := 21;
			end_if;
			if ( Vb4506_AppCambioPinzeRun) then
				Vn2CodiceAllarmeXHmi := 22;
			end_if;											
		end_if;
	end_if;

end_if;

if ( RiseVb4510_AppHmiCaricatore.q and  VbChn3AutoRun and  Vb4049_C1_AsseCARFermo and VnStatoCuci1 =5 and not VbChn1AutoRun) then

	Vb8_ExitAutomatico := TRUE;
	Vb4000_Automatico := FALSE;	
	Vb4510_AppHmiCaricatore := FALSE;

end_if;



(* se ho tolto Automatico e avevo CAricatore allora spengo caricatore*)	
if(FallAuto.q and Vb4511_AppEnbCaricatore) then
	Vb4511_AppEnbCaricatore := FALSE;
	Vb4356_AppAut_o24_Pinza_carico_Su_Giu := FALSE;
end_if;


(* se ho lancia attiva non faccio inserire il piegatore *)
	if ( Vb4341_AppAut_o9_Lancia_AD or o9_Lancia_AD )then
		Vb4510_AppHmiCaricatore := FALSE ;
		Vb4511_AppEnbCaricatore := FALSE ;
	end_if;

(* se attivo il caricatore .....*)
Rise_Vb4511_AppEnbCaricatore(  in := Vb4511_AppEnbCaricatore  );
Fall_Vb4511_AppEnbCaricatore(  in := Vb4511_AppEnbCaricatore  );
	if ( Rise_Vb4511_AppEnbCaricatore.q )then
		VnStatoCuci1 := 0;
		Vb4000_Automatico := TRUE;			//faccio partire automatico
		Vb4508_AppHmiPiegatore := FALSE ;	//spengo piegatore
		Vb4509_AppEnbPiegatore := FALSE ;
	end_if;
	




(*---------------------------------------------------------------------------------------------*)
(* abilitazione piegatore *)

RiseVb4508_AppHmiPiegatore(  in :=  Vb4508_AppHmiPiegatore and (not VbChn3AutoRun or VnStatoCuci1 = 5 or VnStatoCuci1 = 100) and  Vb4049_C1_AsseCARFermo );

if ( RiseVb4508_AppHmiPiegatore.q and Vb4806_AppPinzaAltaC1 and not Vb4003_RqsStopPiegatore)then


	if(Vb4511_AppEnbCaricatore and not Vb4015_PrgCaricatoreRun and Vb4504_AppPosMacchinaPerAutomatico) then
		Vb4510_AppHmiCaricatore := TRUE;  //spengo caricatore
		Vb4509_AppEnbPiegatore := TRUE;	(* abilitazione piegatore se non era attivo*)
		Vb4508_AppHmiPiegatore := FALSE;
		Vn2CodiceAllarmeXHmi := 0;
	
	end_if;

	if(not Vb4507_AppManAuto and not Vb4509_AppEnbPiegatore and Vb4504_AppPosMacchinaPerAutomatico) then
	
		Vb4509_AppEnbPiegatore := TRUE;	(* abilitazione piegatore se non era attivo*)
		Vb4508_AppHmiPiegatore := FALSE;
		Vn2CodiceAllarmeXHmi := 0;

		
		
	else

		if(Vb4509_AppEnbPiegatore) then
	
			if(not Vb4010_PrgPiegatoreRun ) then		(*se il ciclo piegatore è attivo non faccio spegnere il piegatore, prima premere Reset*)
				Vb4000_Automatico := FALSE;			(* se era attivo spengo prima Automatico e poi il suo fronte spegne Caricatore*)
				Vb4001_StepPiegatore	:= FALSE;
				Vb4002_StepPiegatoreStop := FALSE ;		
				Vb4508_AppHmiPiegatore := FALSE;
			
			end_if;	
		else
			Vb4508_AppHmiPiegatore := FALSE;
		
			Vb4504_AppPosMacchinaPerAutomatico := FALSE ;
			if ( Vb4503_CN_Allarme) then
				Vn2CodiceAllarmeXHmi := 16;
			end_if;
			if ( not i5_FcPinzaCaricoAlta) then
				Vn2CodiceAllarmeXHmi := 17;
			end_if;
			if ( not i8_FcPiegatore_DI) then
				Vn2CodiceAllarmeXHmi := 18;
			end_if;
			if ( not i11_FcLancia_DI) then
				Vn2CodiceAllarmeXHmi := 19;
			end_if;
			if ( i23_C1_PinzaIntBassa) then
				Vn2CodiceAllarmeXHmi := 20;
			end_if;
			if (not i24_C1_PinzaEstAlta) then
				Vn2CodiceAllarmeXHmi := 21;
			end_if;
			if ( Vb4506_AppCambioPinzeRun) then
				Vn2CodiceAllarmeXHmi := 22;
			end_if;	
			
			if(not o50_C2_Pinza_int) then
				Vn2CodiceAllarmeXHmi := 39;
			end_if;
			
			
								
		end_if;
	end_if;
end_if;	
	


(* se attivo il piegatore .....*)
Rise_Vb4509_AppEnbPiegatore(  in := Vb4509_AppEnbPiegatore  );

	if ( Rise_Vb4509_AppEnbPiegatore.q )then
		Vb4000_Automatico := TRUE;			//faccio partire automatico
		Vb4510_AppHmiCaricatore := FALSE ;
		Vb4511_AppEnbCaricatore := FALSE ;
		if(Vb22_device_lentezza_tasca) then
			Vb4355_AppAut_o23_Lentezza_Tasca_AD := TRUE;
		end_if;
	end_if;

	
(* se ho tolto Automatico e avevo Piegatore  allora spengo piegatore*)	
if(FallAuto.q and Vb4509_AppEnbPiegatore) then
	Vb4509_AppEnbPiegatore := FALSE;
	Vb4355_AppAut_o23_Lentezza_Tasca_AD := FALSE;
end_if;

(*  selezione piegatore spengo caricatore *)
Rise_Vb4509_AppEnbPiegatore(  in := Vb4509_AppEnbPiegatore  );
Fall_Vb4509_AppEnbPiegatore(  in := Vb4509_AppEnbPiegatore  );
	if ( Rise_Vb4509_AppEnbPiegatore.q )then
		Vb4510_AppHmiCaricatore := FALSE ;
		Vb4511_AppEnbCaricatore := FALSE ;
	end_if;

(*---------------------------------------------------------------------------------------------*)
(* abilitazione test piegatore *)

Rise_Vb4521_AppHmiTestPiegatore ( in:= Vb4521_AppHmiTestPiegatore );
if(Rise_Vb4521_AppHmiTestPiegatore.q ) then
		//se è spento
	if( not Vb4001_StepPiegatore and Vb4509_AppEnbPiegatore and not VbChn3AutoRun) then
		Vb4001_StepPiegatore := TRUE;
	
	else
		 //se è accseo
		if(  Vb4001_StepPiegatore and Vb4509_AppEnbPiegatore and not VbChn3AutoRun) then
			Vb4001_StepPiegatore := FALSE;
			Vb4002_StepPiegatoreStop := FALSE ;
			
		end_if;	
	end_if;
	
	
end_if;

(*---------------------------------------------------------------------------------------------*)
(* abilitazione traslatore *)

Rise_Vb4522_AppHmiTestTrasl (in:= Vb4522_AppHmiTestTrasl and not Vb4016_PrgTraslatoreRun);
if(Rise_Vb4522_AppHmiTestTrasl.q) then
	if(not Vb4006_StepTraslatore and Vb4513_AppEnbCucitrice2) then
			Vb4006_StepTraslatore := TRUE;
	else 
		if(	 Vb4006_StepTraslatore) then
			Vb4006_StepTraslatore := FALSE;
		end_if;
	end_if;


end_if;




(*---------------------------------------------------------------------------------------------*)
(* abilitazione cucitrice 2 *)

Rise_Vb4512_AppHmiCucitrice2 (in := Vb4512_AppHmiCucitrice2);
if(Rise_Vb4512_AppHmiCucitrice2.q) then
	if(not VB_CHN2_AUTO_RUNNING and not Vb4016_PrgTraslatoreRun) then
		if(not Vb4513_AppEnbCucitrice2) then
			Vb4513_AppEnbCucitrice2 := TRUE;
		else
		
			Vb4513_AppEnbCucitrice2 := FALSE;
		end_if;
	end_if;
else	
	Vb4512_AppHmiCucitrice2 := FALSE;
end_if;


	
(*  selezione cucitrice 2 *)

Rise_Vb4513_AppEnbCucitrice2(  in := Vb4513_AppEnbCucitrice2 );
Fall_Vb4513_AppEnbCucitrice2(  in := Vb4513_AppEnbCucitrice2 ); 

(*---------------------------------------------------------------------------------------------*)
(* abilitazione scaricatore *)


RiseVb4514_AppHmiScaricatore(  in :=  Vb4514_AppHmiScaricatore); // and not VbChn3AutoRun );

	if ( RiseVb4514_AppHmiScaricatore.q )then
		Vb4515_AppEnbScaricatore := not Vb4515_AppEnbScaricatore ;
	end_if;



(* uscita dal ciclo automatico *)

case ( Vn_ID_macchina) of
	
	882:

		if ( AssiFermi and not VbChn1AutoRun and not VbChn2AutoRun and not o9_Lancia_AD and not Vb4010_PrgPiegatoreRun and (( Vn132_DebugPie = 1001 ) or ( Vn132_DebugPie = 1000 )) and (( VnStatoCuci1 = 5 ) or ( VnStatoCuci1 = 100 ) ) and (( VnStatoCuci2 = 10 ) ))then
			//Vb8_ExitAutomatico := TRUE ;
		else;
		//	Vb8_ExitAutomatico := FALSE ;
		end_if;
	862: (*862M*)

		if(Vb4511_AppEnbCaricatore) then
			temp1 := TRUE;
		else
			temp1 := (( Vn132_DebugPie = 1001 ) or ( Vn132_DebugPie = 1000 ));
		end_if;
		
		temp2 := (( VnStatoCuci1 = 5 ) or ( VnStatoCuci1 = 100 ) );
		if ( (AssiFermi and not VbChn1AutoRun and not VbChn2AutoRun and not Vb4015_PrgCaricatoreRun and not o9_Lancia_AD and not Vb4010_PrgPiegatoreRun and temp1 and temp2) or C1_FinitoSimulazione )then
			Vb8_ExitAutomatico := TRUE ;
		
		else;
			Vb8_ExitAutomatico := FALSE ;
		end_if;
	860: (*862HM*)
		if(Vb4511_AppEnbCaricatore) then
			temp1 := TRUE;
		else
			temp1 := (( Vn132_DebugPie = 1001 ) or ( Vn132_DebugPie = 1000 ));
		end_if;
		
		temp2 := (( VnStatoCuci1 = 5 ) or ( VnStatoCuci1 = 100 ) );
		if ( (AssiFermi and not VbChn1AutoRun and not VbChn2AutoRun and not Vb4015_PrgCaricatoreRun and not o9_Lancia_AD and not Vb4010_PrgPiegatoreRun and temp1 and temp2) or C1_FinitoSimulazione )then
			Vb8_ExitAutomatico := TRUE ;
		
		else;
			Vb8_ExitAutomatico := FALSE ;
		end_if;
end_case;	









(* calcolo quota libera pinza cucitrice 1 in base alla velocita del caricatore *)
	if (Vq3510_VelocitaCaricRiposo <= 30000)then
		Vq3504_AppPosizioneCaricLiberaPinzaC1 := Vq3503_PosizioneCaricLiberaPinzaC1 ;	
	end_if;
	if (Vq3510_VelocitaCaricRiposo > 30000 and Vq3510_VelocitaCaricRiposo <= 90000 )then
		Vq3504_AppPosizioneCaricLiberaPinzaC1 := Vq3503_PosizioneCaricLiberaPinzaC1 + ((( Vq3510_VelocitaCaricRiposo - 30000 ) / 100 ) * ( Vq3505_CoeffPosizioneCaricLiberaPinzaC1/ 1000 ));
	end_if;

	if (Vq3510_VelocitaCaricRiposo > 90000)then
		Vq3504_AppPosizioneCaricLiberaPinzaC1 := Vq3503_PosizioneCaricLiberaPinzaC1 + ((( 90000 - 30000 ) / 100 ) * ( Vq3505_CoeffPosizioneCaricLiberaPinzaC1/ 1000 ));
	end_if;

(*---------------------------------------------------------------------------------------------*)
(* abilitazione tipo scambio pinze tra C1 e caricatore C2 *)


(*
	if ( not Vb4507_AppManAuto and not VbChn3AutoRun )then
		RiseVb4516_AppHmiScambioPinzeC1_Car2(  in :=  Vb4516_AppHmiScambioPinzeC1_Car2 );
		if ( RiseVb4516_AppHmiScambioPinzeC1_Car2.q and not Vn120_AppEnbScambioPinzeC1_Car2 = 0 )then
			Vn120_AppEnbScambioPinzeC1_Car2 := 1 ;
		else
			Vn120_AppEnbScambioPinzeC1_Car2 := 0 ;
		end_if;
	end_if;
*)

(* assi fermi *)
	if ( Vb4045_C1_AxXFermo and Vb4046_C1_AxYFermo and Vb4047_C1_AxAgoFermo and Vb4048_C1_AxCroFermo )then
		AssiFermiC1 := TRUE ;
	else;
		AssiFermiC1 := FALSE ;
	end_if;
	
	if ( Vb4050_C2_AxXFermo and Vb4051_C2_AxYFermo and Vb4052_C2_AxAgoFermo and Vb4053_C2_AxCroFermo )then
		AssiFermiC2 := TRUE ;
	else;
		AssiFermiC2 := FALSE ;
	end_if;
	
	if ( Vb4049_C1_AsseCARFermo and Vb4054_C2_AsseCARFermo )then
		AssiFermiC3 := TRUE ;
	else;
		AssiFermiC3 := FALSE ;
	end_if;
	
	if ( AssiFermiC1 and AssiFermiC2 and AssiFermiC3 )then 
		AssiFermi := TRUE ;
	else;
		AssiFermi := FALSE ;
	end_if;




(* uscita valvolone *)

	Vb4165_AppMan_o33_Valvolone := not VbSimulaDbg and VB_SYS_CNC_ENABLED and VB_SYS_ECAT_OPERATIONAL;
	Vb4365_AppAut_o33_Valvolone := not VbSimulaDbg and VB_SYS_CNC_ENABLED and VB_SYS_ECAT_OPERATIONAL;




(* Emergenza orologio*)	

Rise_Valvolone ( in:= Vb4165_AppMan_o33_Valvolone );	
	
if(Rise_Valvolone.q)then
	vret := ExecPlcFun( 103, 0, 240 ); // leggo la data del CN	
	if(Vn246LimiteAnno <> 0 and Vn247LimiteMese <>0 and Vn248LimiteGiorno <>0 ) then
	
		if(Vn240AnnoOrologioPLC > Vn246LimiteAnno ) then
			vret := ExecPlcFun( PLC_SET_EMERGENZA, 7, 0 );
		end_if;
	
		if(Vn240AnnoOrologioPLC = Vn246LimiteAnno and Vn241MeseOrologioPLC > Vn247LimiteMese) then
			vret := ExecPlcFun( PLC_SET_EMERGENZA, 7, 0 );
		end_if;
		
		if(Vn240AnnoOrologioPLC = Vn246LimiteAnno and Vn241MeseOrologioPLC = Vn247LimiteMese and Vn242giornoOrologioPLC > Vn248LimiteGiorno) then
			vret := ExecPlcFun( PLC_SET_EMERGENZA, 7, 0 );
		end_if;
		
		
	end_if;	
end_if;

















































(* sotto togliere serve a testare qualche tempo *)
//RiseVbChn1Start( in:= VbChn1Start );

//if (RiseVbChn1Start.q)then 
//	Chn1Start := TRUE ;
//end_if;
//
//if ( VbTest )then 
//	Chn1StartTIM := Chn1StartTIM + 4 ;
//end_if;

 (* sopra togliere *)


]]>
					</sourceCode>
				</program>
				<program name="C2_Boot" version="1.0.0" creationDate="0" lastModifiedDate="1625153884" excludeFromBuild="FALSE">
					<vars/>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[(* ========================================================================== 
(* SIPRO - Siax M															  	
(*                                                                            
(* COMPANY:     JAM INTERNATIONAL                                             
(*                                                                            
(* NAME: C1_Boot                                                          
(*
(* TASK BOOT
(*
(* DESCRIPTION:  Esecuzione delle inizializzazioni ( CUCITRICE 2 )
(*
(*		#### NON MODIFICARE ####
(*                                                                             
(* NOTE:                                NAME:           VER:    DATE:         
(* -------------------------------------------------------------------------  
(* Prima stesura                        gf              1.0     29/04/2021    
(* Ultima modifica                                                            
(* ========================================================================== *)


	(* NOTA: L'asse ago deve avere il parametro OVERRIDE attivo *)
	(* Imposta override al 100% *)
VN_CHN2_OVERRIDE_G0 := 1000;
VN_CHN2_OVERRIDE_G1 := 1000;
VN_AX6_OVERRIDE := 1000;
VN_AX7_OVERRIDE := 1000;
VN_AX8_OVERRIDE := 1000;
VN_AX9_OVERRIDE := 1000;

	(* Variabili per l'inseguimento gantry Ago - Crochet *)
VN_AX9_FOLL_CONF := 1;
VN_AX9_FOLL_MASTER_NUM := C2_AsseAGO;	
VQ_AX9_FOLL_NUM := 1000;
VQ_AX9_FOLL_DEN := 1000;

	(* Comandi cucitrice *)
C2_VbStartCuci   := FALSE;
C2_VbHoldCuci    := FALSE;           
C2_VbReleaseCuci := FALSE;       
C2_VbEndCuci     := FALSE;        
C2_VbRunCuci     := FALSE;        
C2_VbRallCuci    := FALSE;       
C2_VbRasafCuci   := FALSE;        
C2_VbAgoAzzCuci  := FALSE;        
C2_VbCamMovCuci  := FALSE;        
C2_VbAxMovCuci   := FALSE;        
C2_VbLastPnt     := FALSE;        
C2_VbSuspendCuci := FALSE;        
C2_VbCuciGoto    := FALSE;        

	(* Reset comandi e flags *)
C2_CmdInitCamme   := FALSE;
C2_CmdHoldRelease := FALSE;
C2_CmdHoldHMI     := FALSE;
C2_CmdReleaseHMI  := FALSE;
C2_CmdPiedinoSu   := FALSE;
C2_CmdPiedinoGiu  := FALSE;
C2_CuciSimulaAuto := FALSE;
C2_CuciLastPoint  := FALSE;
C2_CmdRiposiziona := FALSE;
C2_CuciLastPointEnaStop := FALSE;
C2_CmdReloadTabellone   := FALSE;
C2_CmdSaveParam         := FALSE;
C2_CmdGantryCrochet     := FALSE;
C2_CmdStdFollowCrochet  := FALSE;
C2_CmdSganciaCrochet    := FALSE;	
C2_CmdSetOffsetAgoTacca := FALSE;
C2_CmdSbloccaAgo        := FALSE; 
C2_CmdForceLoadProfilo  := TRUE;		(* Forzatura load profilo *)
	
	(* Impstazione default variabili *)
C2_PlcStatoAgo := 0;
C2_VelLimitRPM := 0;
C2_CntApritens := 0;
C2_CntColtello := 0;
C2_VqActPntCuci := 0;

(*tasca dx e sx*)
Vn198_Tasca_DX_C2 :=1;
Vn199_Tasca_SX_C2 :=0;
]]>
					</sourceCode>
				</program>
				<program name="C2_LoadUdf" version="1.0.0" creationDate="0" lastModifiedDate="1619704921" excludeFromBuild="FALSE">
					<vars>
						<localVars>
							<var name="RiseBootDone" type="RiseEdge"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[(* ========================================================================== 
(* SIPRO - Siax M															  	
(*                                                                            
(* COMPANY:     JAM INTERNATIONAL                                             
(*                                                                            
(* NAME: C2_LoadUdf                                                          
(*
(* TASK MAIN	 
(*
(* DESCRIPTION: Load programmi utente ( CUCITRICE 2 ) 
(*
(*		#### NON MODIFICARE ####
(*                                                                             
(* NOTE:                                NAME:           VER:    DATE:         
(* -------------------------------------------------------------------------  
(* Prima stesura                        gf              1.0     29/04/2021    
(* Ultima modifica                                                            
(* ========================================================================== *)


	
	(* Fronte di salita del fine del boot del CN *)
RiseBootDone( in:= VB_SYS_CNC_BOOT_DONE  );

	(* Selezione programma main, load UDF parametri *)
if RiseBootDone.q then
		
		(* Set nome del programma CN *)
	C2_PrgName := 'c:/cnc/prog/C2_Main.obj';
    ipar := ((C2_CHN*1000)+13);
	vret := ExecPlcFun( PLC_WRITE_FORK_VAR, ipar, C2_PRG_NAME_IDX );

		(* Cmd Load programma UDF dei parametri (contesto C2_PAR_CNTX) *)
	C2_CmdLoadParam := TRUE;
end_if;

		(* Load programma UDF dei parametri (contesto C2_PAR_CNTX) *)
if ( C2_CmdLoadParam ) then		
	C2_UdfName := 'c:/cnc/sys/C2_Param.udf';
    ipar := ((C2_PAR_CNTX*1000)+30);
    vret := ExecPlcFun( PLC_WRITE_FORK_VAR, ipar, C2_UDF_NAME_IDX );
    
    ipar := ((C2_PAR_CNTX*100)+17);
   	vret := ExecPlcFun( PLC_SET_UDT_CMD, ipar, 0 );
   	
	C2_CmdLoadParam := FALSE;

		(* Set offset ago tacca *)
	C2_CmdSetOffsetAgoTacca := TRUE;
end_if;   		


	(* Load UDF tabellone *)
if ( RiseBootDone.q or C2_CmdReloadTabellone ) then

		(* Load programma UDF dei parametri dinamici sul contesto impostato in cucitrice.txt) *)
	vret := ExecPlcFun( PLC_CUCI_CMD, 224, C2_TAB_CONTEXT_IDX );

	if ( C2_TabParContext > 0 ) then
   		C2_UdfName := 'c:/cnc/sys/C2_TabPar.udf';
    	ipar := ((C2_TabParContext*1000)+30);
    	vret := ExecPlcFun( PLC_WRITE_FORK_VAR, ipar, C2_UDF_NAME_IDX );
    	
    	ipar := ((C2_TabParContext*100)+21);
    	vret := ExecPlcFun( PLC_SET_UDT_CMD, ipar, 0 );
	end_if;

	if ( C2_CmdReloadTabellone ) then
		C2_CmdReloadTabellone := FALSE;
		vret := ExecPlcFun( PLC_CUCI_CMD, 231, 1 );						(* Abilita info debugger *)
        vret := ExecPlcFun( PLC_CUCI_CMD, 232, C2_WARNING_INFO_IDX );   (* Abilita info warning  *)
	end_if;

end_if;


	(* Save UDF parametri *)
if ( C2_CmdSaveParam ) then
	
		(* Scrive il passo nel contesto *)
	C2_StepNum := 1;	
	C2_MtxNum  := C2_PAR_BASE_MTX;
	ipar := ((C2_PAR_CNTX*100)+34); 
   	vret := ExecPlcFun( PLC_SET_UDT_CMD, ipar, C2_WRITE_PAR_IDX );

		(* Salva il file *)
	ipar := ((C2_PAR_CNTX*100)+26);	
   	vret := ExecPlcFun( PLC_SET_UDT_CMD, ipar, 0 );

	C2_CmdSaveParam   := FALSE;
	
		(* Set offset ago tacca *)
	C2_CmdSetOffsetAgoTacca := TRUE;
end_if;	 	

]]>
					</sourceCode>
				</program>
				<program name="C2_Camme" version="1.0.0" creationDate="0" lastModifiedDate="1702979129" excludeFromBuild="FALSE">
					<vars>
						<localVars>
							<var name="RiseApritens" type="RiseEdge"/>
							<var name="RiseColtello" type="RiseEdge"/>
							<var name="RiseBloccoFiloINI" type="RiseEdge"/>
							<var name="RiseBloccoFiloEND" type="RiseEdge"/>
							<var name="FallBloccoFiloINI" type="FallEdge"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[(* ========================================================================== 
(* SIPRO - Siax M															  	
(*                                                                            
(* COMPANY:     JAM INTERNATIONAL                                             
(*                                                                            
(* NAME: C2_Camme                                                          
(*
(* TASK MAIN	 
(*
(* DESCRIPTION: Programmazione delle camme digitali  ( CUCITRICE 2 ) 
(*
(* NOTE:                                NAME:           VER:    DATE:         
(* -------------------------------------------------------------------------  
(* Prima stesura                        gf              1.0     29/04/2021    
(* Ultima modifica                                                            
(* ========================================================================== *)

	(* Inizializzazione delle Camme digitali *)
if ( C2_CmdInitCamme ) then
	C2_CmdInitCamme := FALSE;
		
	C2_VbEnableCamme := FALSE;
	C2_VbEnableCammeIni := FALSE;

        (* Camma fuori ingombro - senza anticipi *)
	CamMode   := ( C2_MODE_FUORI_ING * 1000 );
	CamAxNum  := ( C2_AsseAGO * 1000 );
	CamDigOut := ( C2_AGO_FUORI_ING_IDX * 1000 );
	CamStart  := C2_SogliaStart;
	CamStop   := C2_SogliaStop; 
	CamModule := ( CAM_MODULE * 1000 );
	vret := ExecPlcFun( PLC_INIT_ONE_CAM, C2_ID_CAM_FUORI_ING, INIT_CAM_VQ_IDX );      

        (* Camma per la fermata sull'ago alto *)
	CamMode   := ( C2_MODE_AGO_ALTO * 1000 );
	CamAxNum  := ( C2_AsseAGO * 1000 );
	CamDigOut := ( C2_AGO_ALTO_STOP_IDX * 1000 );
	
	if ( C2_StopAgo = 0 ) then
	    CamStart := ( 1 * 1000 );
	else
	    CamStart := C2_StopAgo;
	end_if;
	
	CamStop   := CamStart + ( CAM_MODULE * 1000 ) / 4; 
	CamModule := ( CAM_MODULE * 1000 );
	vret := ExecPlcFun( PLC_INIT_ONE_CAM, C2_ID_CAM_AGO_ALTO, INIT_CAM_VQ_IDX );      

        (* Camma Apritensione *)
	CamMode   := ( C2_MODE_APRITENS * 1000 );
	CamAxNum  := ( C2_AsseAGO * 1000 );
	CamDigOut := ( C2_VB_APRITENS * 1000 );
	CamStart  := C2_StartApriTens;
	CamStop   := C2_StopApriTens;
	CamModule := ( CAM_MODULE * 1000 );
	vret := ExecPlcFun( PLC_INIT_ONE_CAM, C2_ID_APRITENS, INIT_CAM_VQ_IDX );      

	CamCmd  := 1000;
	CamPar1 := ( C2_ENA_APRITENS * 1000 );
	vret := ExecPlcFun( PLC_IO_CTL_CAM, C2_ID_APRITENS, IO_CTL_CAM_VQ_IDX );  	    

    
        (* Camma Rasafilo - Coltello *)   
	CamMode   := ( C2_MODE_COLTELLO * 1000 );
	CamAxNum  := ( C2_AsseAGO * 1000 );
	CamDigOut := ( C2_OUT_COLTELLO * 1000 );
	CamStart  := C2_StartColtello;
	CamStop   := C2_StopColtello;
	CamModule := ( CAM_MODULE * 1000 );
	vret := ExecPlcFun( PLC_INIT_ONE_CAM, C2_ID_COLTELLO, INIT_CAM_VQ_IDX );        

	CamCmd  := 1000;
	CamPar1 := ( C2_ENA_COLTELLO * 1000 );
	vret := ExecPlcFun( PLC_IO_CTL_CAM, C2_ID_COLTELLO, IO_CTL_CAM_VQ_IDX );      


        (* Camma BloccoFiloINI *)
	CamMode   := ( C2_MODE_BLOCCO_FILO_INI * 1000 );
	CamAxNum  := ( C2_AsseAGO * 1000 );
	CamDigOut := ( C2_VB_BLOCCO_FILO_INI * 1000 );
	CamStart  := C2_StartBloccoFiloINI;
	CamStop   := C2_StopBloccoFiloINI;
	CamModule := ( CAM_MODULE * 1000 );
	vret := ExecPlcFun( PLC_INIT_ONE_CAM, C2_ID_BLOCCO_FILO_INI, INIT_CAM_VQ_IDX );      

	CamCmd  := 1000;
	CamPar1 := ( C2_ENA_BLOCCO_FILO_INI * 1000 );
	vret := ExecPlcFun( PLC_IO_CTL_CAM, C2_ID_BLOCCO_FILO_INI, IO_CTL_CAM_VQ_IDX );      	
	

        (* Camma BloccoFiloEND *)
	CamMode   := ( C2_MODE_BLOCCO_FILO_END * 1000 );
	CamAxNum  := ( C2_AsseAGO * 1000 );
	CamDigOut := ( C2_VB_BLOCCO_FILO_END * 1000 );
	CamStart  := C2_StartBloccoFiloEND;
	CamStop   := C2_StopBloccoFiloEND;
	CamModule := ( CAM_MODULE * 1000 );
	vret := ExecPlcFun( PLC_INIT_ONE_CAM, C2_ID_BLOCCO_FILO_END, INIT_CAM_VQ_IDX );      

	CamCmd  := 1000;
	CamPar1 := ( C2_ENA_BLOCCO_FILO_END * 1000 );
	vret := ExecPlcFun( PLC_IO_CTL_CAM, C2_ID_BLOCCO_FILO_END, IO_CTL_CAM_VQ_IDX );      	

end_if;
 
(* Contatori di attivazione delle uscite di apritensione e coltello *)    


RiseApritens(  in := Vb3_C2_Apritensione  );

if ( RiseApritens.q ) then
	C2_CntApritens := C2_CntApritens + 1;
end_if; 


RiseColtello(  in := o46_C2_rasafilo  );

if ( RiseColtello.q ) then
	C2_CntColtello := C2_CntColtello + 1;
end_if; 
(* camma blocco filo inizio*)

RiseBloccoFiloINI(  in := Vb15_C2_BloccoFiloINI );
FallBloccoFiloINI(  in := Vb15_C2_BloccoFiloINI );

if ( RiseBloccoFiloINI.q ) then
	C2_CntBloccoFiloINI := C2_CntBloccoFiloINI + 1;
end_if; 

if ( FallBloccoFiloINI.q ) then
	 C2_VbEnableCammeIni := FALSE ;	
end_if; 

(* camma blocco filo fine *)
RiseBloccoFiloEND(  in := Vb16_C2_BloccoFiloEND );

if ( RiseBloccoFiloEND.q ) then
	C2_CntBloccoFiloEND := C2_CntBloccoFiloEND + 1;
end_if; 

]]>
					</sourceCode>
				</program>
				<program name="C2_CuciRtc" version="1.0.0" creationDate="0" lastModifiedDate="1619700920" excludeFromBuild="FALSE">
					<vars/>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[(* ========================================================================== 
(* SIPRO - Siax M															  	
(*                                                                            
(* COMPANY:     JAM INTERNATIONAL                                             
(*                                                                            
(* NAME: C1_CucìRtc                                                          
(*
(* TASK RTC_AX	 
(*
(* DESCRIPTION: Operazioni da eseguire al tick di sistema ( CUCITRICE 2 )
(*
(*		#### NON MODIFICARE ####
(*                                                                             
(* NOTE:                                NAME:           VER:    DATE:         
(* -------------------------------------------------------------------------  
(* Prima stesura                        gf              1.0     29/04/2021    
(* Ultima modifica                                                            
(* ========================================================================== *)


(*---------------------------------------------------------------------------
 Variabile END CUCITRICE
 Viene messa a TRUE dal firmware quando, sul fronte di salita della
 soglia di start movimento, non ci sono piu' punti da eseguire. 
 Viene usata dal firmware per terminare l'esecuzione dell'istruzione G280.	
 Il PLC la riporta al valore FALSE quando anche la VbRunCuci ritorna a FALSE
 ----------------------------------------------------------------------------*)
if ( ( C2_VbEndCuci = TRUE ) and ( C2_VbRunCuci = FALSE ) ) then
	C2_VbEndCuci := FALSE;
end_if;


(*-------------------------------------------------------------------- 
 Variabile RASAFILO
 Viene messa a TRUE dal firmware quando, sul fronte di salita della
 soglia di start movimento, non ci sono piu' punti da eseguire. 	
 Il PLC la riporta al valore FALSE
 ---------------------------------------------------------------------*)
if ( C2_VbRasafCuci = TRUE ) then
	C2_VbRasafCuci := FALSE;

	C2_CuciLastPoint := FALSE;
end_if;

(*-------------------------------------------------------------------- 
 Variabile LAST POINT
 Viene messa a TRUE dal firmware quando, sul fronte di salita della
 soglia di start movimento, viene eseguito l'ultimo punto. 	
 Il PLC la riporta al valore FALSE
 
 C1_CuciLastPointEnaStop abilita lo stop dell'aggo.
 Lo stop avviene quando si entra nella camma di stop ago alto:
 in pratica si attende che l'ago oltrepassi una volta la quota di stop 
 prima di dare il comando di fermata alla quota di stop.
  ---------------------------------------------------------------------*)
if ( C2_VbLastPnt = TRUE ) then
	C2_VbLastPnt := FALSE;

	C2_CuciLastPoint := TRUE;
	C2_CuciLastPointEnaStop := TRUE;
	C2_CuciLastPointAxC := TRUE;
end_if;



(*-------------------------------------------------------------------- 
 Comando di fermata dell'asse ago:
 Dopo il LAST POINT si attende la camma di stop ago alto
 Vengono anche abilitate le camme di apritensione e di coltello
  ---------------------------------------------------------------------*)
if ( C2_CuciLastPointEnaStop and C2_CammaStopAgoAlto ) then
	C2_CuciLastPointEnaStop := FALSE;

			(* Stop in fase asse ago *)
	StopPlcAgoErrCode := 0;
	StopPlcAgoQuoObj  := C2_StopAgo;
	StopPlcAgoFuture  := 0;
	iparRtcAx := (C2_AsseAGO*100);
	vret := ExecPlcFun( PLC_CHG_QUO_OBJ_AX, iparRtcAx, STOP_PLC_AGO_IDX );		

		(* Abilita camme apritensione e coltello *)
	C2_VbEnableCamme := TRUE;
end_if;	

]]>
					</sourceCode>
				</program>
				<program name="C2_Cucitrice" version="1.0.0" creationDate="0" lastModifiedDate="1715177294" excludeFromBuild="FALSE">
					<vars>
						<localVars>
							<var name="FallPrgRun" type="FallEdge"/>
							<var name="RisePrgRun" type="RiseEdge"/>
							<var name="RiseSuspend" type="RiseEdge"/>
							<var name="RiseAva" type="RiseEdge"/>
							<var name="RiseInd" type="RiseEdge"/>
							<var name="FlgWaitAgoFermo" type="BOOL"/>
							<var name="CmdStartAgo" type="BOOL"/>
							<var name="MemActPnt" type="DINT"/>
							<var name="RiseAvaNpoint" type="RiseEdge"/>
							<var name="RiseIndNpoint" type="RiseEdge"/>
							<var name="RiseAvaCont" type="RiseEdge"/>
							<var name="RiseIndCont" type="RiseEdge"/>
							<var name="FlgWaitTime" type="BOOL"/>
							<var name="DelayTimer" type="Ton"/>
							<var name="VcdIdx" type="INT"/>
							<var name="RpmFix3" type="DINT"/>
							<var name="RISE_CAMBIO_C2_NEXTCODE" type="RiseEdge"/>
							<var name="RISE_PARTENZA_IN_SIMULAZIONE" type="RiseEdge"/>
							<var name="FALL_C2_CUCISIMULAAUTO" type="FallEdge"/>
							<var name="RISE_SIMULAARRIVATOALLAFINE" type="RiseEdge"/>
							<var name="TON_C2_FINITOSIMULAZIONE" type="Ton"/>
							<var name="Forwards_C2" type="BOOL"/>
							<var name="BACKWARDS_C2" type="BOOL"/>
							<var name="STATOINIZIALE_C2_NEXTCODE" type="INT"/>
							<var name="Rise_C2_CuciSimulaAuto" type="RiseEdge"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[(* ========================================================================== 
(* SIPRO - Siax M                                                               
(*                                                                            
(* COMPANY:     JAM INTERNATIONAL                                             
(*                                                                            
(* NAME: C2_Cucitrice                                                          
(*
(* TASK MAIN     
(*
(* DESCRIPTION: GESTIONE CUCITRICE 2 
(*
(*      #### NON MODIFICARE ####
(*                                                                             
(* NOTE:                                NAME:           VER:    DATE:         
(* -------------------------------------------------------------------------  
(* Prima stesura                        gf              1.0     13/03/2021    
(*
(* Gestione simulazione con movimento sull'ultimo punto
(* #M210323_1GF#                        gf              1.1     23/03/2021 
(*
(* Hold/Release durante la fermata temporanea
(* #M210511_1GF#                        gf              1.2     11/05/2021 
(*   
(* Step+ Step- dopo Hold durante la fermata temporanea
(* #M210513_1GF#                        gf              1.3     13/05/2021 
(*   
(* Ultima modifica                                                            
(* ========================================================================== *)

 (*----------------------   
   Lettura Fase asse AGO 
 ------------------------*)
    ipar := ((C2_AsseAGO * 100)+32);    
    vret := ExecPlcFun( PLC_READ_AX_QUOTE, ipar, C2_FASE_AX_AGO_IDX );

(*----------------------------------------  
  Copia su vb i bit della parola di stato 
 -----------------------------------------*)
vret := ExecPlcFun( PLC_VN_TO_VB, C2_STATUS_WORD_BIT_IDX, C2_VN_STATUS_CUCI_IDX );

(*--------------------------------------------------------- 
 CuciOrMove: lettura della variabile  C2_VbFlgCuciOrMove
             viene usato nel programma CN dopo un hold
 ----------------------------------------------------------*)
vret := ExecPlcFun( PLC_CUCI_CMD, 229, C2_FLG_CUCI_OR_MOVE_IDX );       

(*--------------------------------------------------------- 
 G280Running: lettura della variabile  C2_VbFlgG280Running
  ----------------------------------------------------------*)
vret := ExecPlcFun( PLC_CUCI_CMD, 230, C2_FLG_G280_RUNNING_IDX );       
(*-------------------------------------------------------------- 
 JTaskInfo: lettura delle variabili info Task J - #M210511_1GF#
  ---------------------------------------------------------------*)
vret := ExecPlcFun( PLC_CUCI_CMD, 233, C2_FLG_JTASK_INFO_IDX );     

(*------------------------------ 
 Disabilitazione camme digitali
 -------------------------------*)
if ( ( C2_VbEnableCamme = TRUE ) AND ( C2_FaseAxAgo = 0 ) ) then
    C2_VbEnableCamme := FALSE;
    C2_VbEnableCammeIni := FALSE;   
end_if;

(*-----------------------
 Flag cucitrice azzerata 
 ------------------------*)
if ( not VB_AX6_ZEROED or not VB_AX7_ZEROED or not VB_AX8_ZEROED or not VB_AX9_ZEROED ) then
    (*C2_AssiAzzerati := TRUE;          messo in azzeramento CN qui non aspetta che arriva in quota di home
else*)
    C2_AssiAzzerati := FALSE;
end_if; 

(*---------------------------------------------------
 Gestione offset tra AGO e tacca di zero dell'encoder 
 ----------------------------------------------------*)
if ( C2_CmdGetOffsetAgoTacca ) then
    ipar := ((C2_CHN*100)+27);
    vret := ExecPlcFun( PLC_CUCI_CMD, ipar, C2_OFFSET_AGO_TACCA_IDX );  
    C2_CmdGetOffsetAgoTacca := FALSE;
end_if;

if ( C2_CmdSetOffsetAgoTacca ) then
    ipar := ((C2_CHN*100)+2);
    vret := ExecPlcFun( PLC_CUCI_SET_PARAM, ipar, C2_OFFSET_AGO_TACCA_IDX );    
    C2_CmdSetOffsetAgoTacca := FALSE;
end_if;

(*--------------------------------- 
 Fronte di salita / discesa PrgRun 
 ----------------------------------*)
RisePrgRun( in:= VB_CHN2_AUTO_RUNNING );
FallPrgRun( in:= VB_CHN2_AUTO_RUNNING );

(*--------------------------------------    
 Inizio esecuzione programma automatico 
 ---------------------------------------*)
if RisePrgRun.q then
    C2_VbSuspendCuci := FALSE;
    C2_PlcStatoAgo := 0;    

        (* Reset comando di hold *)
    C2_CmdHoldRelease := FALSE;
    vret := ExecPlcFun( PLC_CUCI_CMD, 204, 1 );     (* Toglie l'hold *)
    
end_if;

(*------------------------------------  
 Fine esecuzione programma automatico 
 -------------------------------------*)
if FallPrgRun.q then
    VN_AX8_OVERRIDE := 1000;
    
        (* Rollover asse ago *)
    RollPlcAgoModule := 360000;
    RollPlcAgoQuo := 0;
    ipar := ((C2_AsseAGO * 100)+0);
    vret := ExecPlcFun( PLC_ROLLOVER_AX, ipar, ROLL_PLC_AGO_IDX );  
    
        (* Verifica se cucitrice ancora abilitata per stop automatico a causa di una emergenza *)   
    if ( C2_VbStEnIrqBit or C2_VbStEnMovBit or C2_VbCuciIsoActive ) then
        vret := ExecPlcFun( PLC_CUCI_CMD, 204, 99 );
    end_if;

    C2_PlcStatoAgo := 0;    

        (* Elimina le forzature di velocita' asse ago *)
    vret := ExecPlcFun( PLC_CUCI_CMD, 208, 0 );     

        (* Azzera il comando di hold e il flag di simulazione *)
    C2_CmdHoldRelease := FALSE;
    C2_CuciSimulaAuto := FALSE;


        (* Invia un comando di release - #M210511_1GF# *)
    VB_CHN2_RELEASE := TRUE;
    
end_if;

(*-------------------------------------------
 Variabile START CUCITRICE
 Viene messa a TRUE dall'istruzione ISO G280    
 Il PLC la riporta al valore FALSE
 --------------------------------------------*)
if ( C2_VbStartCuci = TRUE ) then
    C2_VbStartCuci := FALSE;

    if ( C2_CmdHoldRelease = FALSE ) then
   
        CmdStartAgo := TRUE;
        C2_CuciLastPointEnaStop := FALSE;
    end_if;
end_if;

(*------------------------------------------------------------- 
 Variabile SUSPEND
 Viene messa a TRUE dal firmware quando e' richiesta una 
 sospensione della cucitura.    
 Il PLC la riporta al valore FALSE quando l'asse ago e' fermo
 Verifica HOLD per fermare il task prima che venga interpretato 
 ed effettuato un movimento
 --------------------------------------------------------------*)
 
RiseSuspend( in:= C2_VbSuspendCuci );

if ( RiseSuspend.q ) then

        (* Stop in fase asse ago *)
    StopPlcAgoErrCode := 0;
    StopPlcAgoQuoObj  := C2_StopAgo;
    StopPlcAgoFuture := 0;
    ipar := (C2_AsseAGO*100);
    vret := ExecPlcFun( PLC_CHG_QUO_OBJ_AX, ipar, STOP_PLC_AGO_IDX );       
            
end_if;

if ( ( C2_VbSuspendCuci = TRUE ) and ( C2_FaseAxAgo = 0 ) ) then

    C2_VbSuspendCuci := FALSE;
end_if;

(*------------------------------------------------------------------ 
 SIMULAZIONE CUCITURA   
 Ciclo automatico RUN cucitrice in HOLD e ago fermo
 Sono attivi i movimenti avanti e indietro sul percorso di cucitura
 E' attivo anche il riposizionamento sul punto 
 -------------------------------------------------------------------*)
RiseAva( in := C2_CmdSimulaAva ); 
RiseInd( in := C2_CmdSimulaInd ); 

RiseAvaNpoint( in := C2_CmdSimulaAvaNpoint ); 
RiseIndNpoint( in := C2_CmdSimulaIndNpoint ); 

RiseAvaCont( in := C2_CmdSimulaAvaCont ); 
RiseIndCont( in := C2_CmdSimulaIndCont ); 

if ( C2_CmdHoldRelease and VB_CHN2_AUTO_RUNNING and ( C2_FaseAxAgo = 0 ) ) then


    
    
	(* -----------#M210618_DA#  ---------------- *)
	(* MACCHINA A STATI - "SIMULA" SINGLE STEP   *)
	(* ----------------------------------------- *)
	if ( RiseAva.q and mc_stati_C2CmdSimula = 0 ) then 
    	
    	mc_stati_C2CmdSimula := 1;
    	Forwards_C2 := TRUE;
    	Backwards_C2 := FALSE;
 
    end_if;
    
    if ( RiseInd.q and mc_stati_C2CmdSimula = 0) then
        mc_stati_C2CmdSimula := 1;
    	Forwards_C2 := FALSE;
    	Backwards_C2 := TRUE;  
    end_if;

	case ( mc_stati_C2CmdSimula ) of
	
		1:
			C2_CuciBufRewind :=FALSE;
			if(Forwards_C2 = TRUE and Backwards_C2 = FALSE) then
				vret := ExecPlcFun( PLC_CUCI_CMD, 248, C2_RD_NEXT_CODE_IDX );   (* #M210616_1GF# *)
				mc_stati_C2CmdSimula := 2;
			else
				vret := ExecPlcFun( PLC_CUCI_CMD, 249, C2_RD_NEXT_CODE_IDX );   (* #M210616_1GF# *)
				mc_stati_C2CmdSimula := 2;
				
			end_if;
		
			
		2: 	if(C2_NextCode = 0 and not o49_C2_Piedino) then	//se ilprossimo è un G0..alzo il piedino prima di continuare
				C2_CmdPiedinoGiu := FALSE;
            	C2_CmdPiedinoSu  := TRUE;
            	mc_stati_C2CmdSimula := 3;
            else
            
				mc_stati_C2CmdSimula := 5;
			end_if;
		3:
			if ( not C2_CmdPiedinoSu ) then	(* Entro quando il piedino è tornato alto *)
			
				mc_stati_C2CmdSimula := 5;
			end_if;
			
		5:	if(Forwards_C2 = TRUE and Backwards_C2 = FALSE) then
		
		
				if ( C2_VbFlgJtaskRunning = TRUE ) then                 (* #M210513_1GF# *)
                	VB_CHN_RELEASE := TRUE;                             (* #M210513_1GF# *)
                	if ( C2_VbFlgJtaskLoopHold = TRUE ) then            (* #M210513_1GF# *)
                    	vret := ExecPlcFun( PLC_CUCI_CMD, 204, 81 );    (* #M210513_1GF# *) 
                    	vret := ExecPlcFun( PLC_CUCI_CMD, 250, 0 );     (* #M210513_1GF# *) 
                	end_if;                                             (* #M210513_1GF# *)

            	else
                	vret := ExecPlcFun( PLC_CUCI_CMD, 250, 0 ); 
            	end_if;
            else
             	if ( C2_VbFlgJtaskRunning = TRUE ) then                 (* #M210513_1GF# *)
                	VB_CHN_RELEASE := TRUE;                             (* #M210513_1GF# *)
                	if ( C2_VbFlgJtaskLoopHold = TRUE ) then            (* #M210513_1GF# *)
                    	vret := ExecPlcFun( PLC_CUCI_CMD, 204, 81 );    (* #M210513_1GF# *) 
                    	vret := ExecPlcFun( PLC_CUCI_CMD, 250, 1 );     (* #M210513_1GF# *) 
                	end_if;                                             (* #M210513_1GF# *)

            	else
                	vret := ExecPlcFun( PLC_CUCI_CMD, 250, 1 ); 
            	end_if;
            end_if;
			mc_stati_C2CmdSimula := 0;
			
			(* Default switch case *)
	else
    mc_stati_C2CmdSimula := 0; 
		
	end_case;



	(* ------------#M210618_DA#  ------- *)
	(* "SIMULA" MULTI STEP CON SALTO     *)
	(* --------------------------------- *)


    if ( RiseAvaNpoint.q ) then 
        if ( o49_C2_Piedino and not C2_CmdPiedinoSu) then
            if ( C2_ModoSimulaNpoint ) then
                vret := ExecPlcFun( PLC_CUCI_CMD, 275, C2_SIMULA_NPOINT_IDX );  (* #M210323_1GF# *) 
            else
                vret := ExecPlcFun( PLC_CUCI_CMD, 255, C2_SIMULA_NPOINT_IDX );  
            end_if; 
        else
            C2_CmdPiedinoGiu := FALSE;
            C2_CmdPiedinoSu  := TRUE;
        end_if;         
    end_if;
    
    if ( RiseIndNpoint.q ) then
        if ( o49_C2_Piedino and not C2_CmdPiedinoSu) then
            if ( C2_ModoSimulaNpoint ) then
                vret := ExecPlcFun( PLC_CUCI_CMD, 276, C2_SIMULA_NPOINT_IDX );  (* #M210323_1GF# *)
            else
                vret := ExecPlcFun( PLC_CUCI_CMD, 256, C2_SIMULA_NPOINT_IDX );  
            end_if; 
        else
            C2_CmdPiedinoGiu := FALSE;
            C2_CmdPiedinoSu  := TRUE;
        end_if;         
    end_if;


	(* -------------#M210618_DA#  -------------- *)
	(* MACCHINA A STATI - "SIMULA" STEP CONTINUI *)
	(* ----------------------------------------- *)
	
	C2_CmdSimulaPedaleVel := i33_C2_Pedana;

			
    if ( RiseAvaCont.q ) then 
    

    	Forwards_C2 := TRUE;
    	Backwards_C2 := FALSE;

    	C2_SimulaContVbIdx := ( C2_SIMULA_AVA_CONT_IDX * 1000 );
       	vret := ExecPlcFun( PLC_CUCI_CMD, 248, C2_RD_NEXT_CODE_IDX );   (* #M210616_1GF# *)
       	vret := ExecPlcFun( PLC_CUCI_CMD, 257, C2_SIMULA_CONT_IDX );  
      	StatoIniziale_C2_NextCode := C2_NextCode;
     	mc_stati_C2CmdSimulaCont := 1;
     	
    	
    end_if;
    
    if ( RiseIndCont.q ) then
    

    	Forwards_C2 := FALSE;
    	Backwards_C2 := TRUE;

    	C2_SimulaContVbIdx := ( C2_SIMULA_IND_CONT_IDX * 1000 );
       	vret := ExecPlcFun( PLC_CUCI_CMD, 249, C2_RD_NEXT_CODE_IDX );   (* #M210616_1GF# *)
        vret := ExecPlcFun( PLC_CUCI_CMD, 258, C2_SIMULA_CONT_IDX ); 
      	StatoIniziale_C2_NextCode := C2_NextCode;
       	mc_stati_C2CmdSimulaCont := 1;  
    
    
     end_if;
    
    Rise_Cambio_C2_NextCode( in := (mc_stati_C2CmdSimulaCont =1 and (StatoIniziale_C2_NextCode <> C2_NextCode)));
    
        
    case ( mc_stati_C2CmdSimulaCont ) of
    
	
		1:			
			if(Rise_Cambio_C2_NextCode.q or (not o49_C2_Piedino and C2_NextCode = 0) ) then 	//se c'è un cambiamento tra G0 e G1...la simulazione si è fermata..
				mc_stati_C2CmdSimulaCont := 4;  			// continuo gestendo il piedino
				StatoIniziale_C2_NextCode := C2_NextCode;
			
			end_if;
				
			
		4:	
			 if(C2_NextCode = 0 ) then	//se il prossimo è un G0..alzo il piedino prima di continuare
				C2_CmdPiedinoGiu := FALSE;
            	C2_CmdPiedinoSu  := TRUE;
            	mc_stati_C2CmdSimulaCont := 5;	//vado  ad aspettare piedino alto
            else
            
				mc_stati_C2CmdSimulaCont := 7;	//continuo con il piedino alto
			end_if;
			
		5:
			if ( not C2_CmdPiedinoSu ) then	(* Entro quando il piedino è tornato alto *)
			
				mc_stati_C2CmdSimulaCont := 7;
			end_if;
		7: if (C2_CmdSimulaAvaCont) then	//se ancora il tasto avanti è premuto... salto e faccio FALSE e TRUE della variabile per far riscattare il Rise
				mc_stati_C2CmdSimulaCont := 10;
			else
				if (C2_CmdSimulaIndCont) then //se ancora il tasto dietro è premuto... salto e faccio FALSE e TRUE della variabile per far riscattare il Rise
					mc_stati_C2CmdSimulaCont := 12;
				else
					mc_stati_C2CmdSimulaCont := 0;	//se ho lasciato i tasti avanti e dietro mi fermo.
				end_if;

			
			
			end_if;
			
		10:
			if(C2_NextCode >= 0) then 
				C2_CmdSimulaAvaCont := FALSE;
				mc_stati_C2CmdSimulaCont := 11;
			else
				mc_stati_C2CmdSimulaCont := 0;	
			
			end_if;	
			
		11:
			C2_CmdSimulaAvaCont := TRUE;
			mc_stati_C2CmdSimulaCont := 0;	
			
		12:
			if(C2_NextCode >= 0) then 
				C2_CmdSimulaIndCont := FALSE;
				mc_stati_C2CmdSimulaCont := 13;
			else
				mc_stati_C2CmdSimulaCont := 0;	
			
			end_if;					
		13:
		
			C2_CmdSimulaIndCont := TRUE;
			mc_stati_C2CmdSimulaCont := 0;	
		
		
	else
		mc_stati_C2CmdSimulaCont :=0;
	end_case;	
		
		



end_if;

	(* -------------#M210618_DA#  -------------- *)
	(* "PARTENZA CON SIMULAZIONE ATTIVA *)
	(* ----------------------------------------- *)
//Time_PartenzaSimulaAuto (in := PartenzaSimulaAuto , pt:= 1000);
Rise_Partenza_in_simulazione ( in := VB_CHN2_AUTO_RUNNING and C2_CuciSimulaAuto and C2_CmdHoldRelease ); 
if(	Rise_Partenza_in_simulazione.q) then

	C2_CmdSimulaAvaCont := FALSE;


end_if;



Fall_C2_CuciSimulaAuto (in := C2_CuciSimulaAuto);
if(Fall_C2_CuciSimulaAuto.q) then
	

	C2_CmdSimulaAvaCont := FALSE;	//ferma simulazione continua
end_if;//flag simulazione arrivata all'ultimo punto
Rise_SimulaArrivatoAllaFine (in := C2_NextCode = -3 and C2_CuciSimulaAuto);
if(Rise_SimulaArrivatoAllaFine.q) then
	C2_FinitoSimulazione := TRUE;
	C2_CmdHoldRelease := FALSE;

	C2_CuciSimulaAuto := FALSE;
	C2_NextCode := -99;
end_if;
Ton_C2_FinitoSimulazione (in := C2_FinitoSimulazione , pt:= 100);
if(Ton_C2_FinitoSimulazione.q) then
	C2_FinitoSimulazione := FALSE;
end_if;



(*-------------------------------------- 
 Riposizionamento sul punto dopo un JOG
 ---------------------------------------*)
if ( C2_CmdRiposiziona and C2_CmdHoldRelease and VB_CHN2_AUTO_RUNNING and ( C2_FaseAxAgo = 0 ) ) then
    vret := ExecPlcFun( PLC_CUCI_CMD, 250, 20 );
    C2_CmdRiposiziona := FALSE;
else
    C2_CmdRiposiziona := FALSE;
end_if;


(*-------------------- 
 Attesa tempo: 200 ms
 ---------------------*)
DelayTimer( in := FlgWaitTime, pt := 200 );
if ( DelayTimer.q ) then
    FlgWaitTime := FALSE;
end_if; 


(*---------------------------------------------------------------------------------------- 
 NOTA per la gestione Hold/Release durante la fermata temporanea di cucitura ( stato 0 )
    La funzione PLC_CUCI_CMD comando 4 e parametri 10 e 11 hanno effetto
    solo se la cucitrice e' temporaneamente ferma. In tutti gli altri 
    casi la funzione non ha alcun effetto. 
    
    Hold e Ripresa durante la cucitura sono gestiti da CN
    In questo caso si esce da G280 e VB_RUN e' false.     
 -----------------------------------------------------------------------------------------*)
(* Calcolo velocita' dell'asse ago *)
(* La velocita'impostata nei parametri e' il limite massimo            *)
(* Nell'header del profilo si imposta la velocita' di lavoro           *)
(* Durante la cucitura si puo' cambiare la velocita' scrivendo la VCD1 *)
(* Si puo' impostare una riduzione velocita': C2_VelRiduzioneRPM       *)   

VcdIdx := (C2_CHN*1000)+VCD_RPM_AGO_IDX;
vret := ExecPlcFun( PLC_VCD_TO_VD, VD_TMP_CALC_IDX, VcdIdx );
VdTmpCalc := VdTmpCalc * 1000.0;
C2_RpmAgoInProfilo := TO_DINT( VdTmpCalc );

if ( C2_RpmAgoInProfilo > 0 ) then
    RpmFix3 := C2_RpmAgoInProfilo;
else
    if ( C2_UdfVelLavRPM > 0 ) then
        RpmFix3 := C2_UdfVelLavRPM;
    else
        RpmFix3 := C2_ParVelLavRPM;
    end_if;
end_if;

if ( ( C2_VelRiduzioneRPM > 0 ) and ( C2_VelRiduzioneRPM < RpmFix3 ) ) then
    RpmFix3 := C2_VelRiduzioneRPM;
end_if;

if ( RpmFix3 > C2_ParVelLavRPM ) then
    C2_VelLimitRPM := TO_INT( C2_ParVelLavRPM / 1000 );
else
    C2_VelLimitRPM := TO_INT( RpmFix3 / 1000 );
end_if;


(* --------------------------- *)
(* MACCHINA A STATI - ASSE AGO *)
(* --------------------------- *)


 
case ( C2_PlcStatoAgo ) of
    
(* Stato 0: Attesa comando di movimento asse ago *)
(*          Se ciclo automatico run: piedino giu *)
(*          Se richiesto hold: passa in stato 5  *)
    0:  if ( VB_CHN2_AUTO_RUNNING and ( C2_CmdHoldHMI or C2_CmdHoldRelease ) ) then
            C2_CmdHoldRelease := TRUE;
            vret := ExecPlcFun( PLC_CUCI_CMD, 204, 0 );  (* Ferma il task *)
            if ( C2_VbFlgJtaskRunning = TRUE ) then     (* HOLD - #M210511_1GF# *)
                VB_CHN2_STOP_HOLD := TRUE;
            end_if;
            C2_PlcStatoAgo := 3;
        end_if;
                
        if ( CmdStartAgo ) then
            CmdStartAgo := FALSE;
                    
                (* il ciclo parte solo se automatico run e si deve far partire l'ago *)
            if ( VB_CHN2_AUTO_RUNNING ) then
                C2_CmdPiedinoSu  := FALSE;
                C2_CmdPiedinoGiu := TRUE;
            
                    (* Imposta eventuale limite *)
                vret := ExecPlcFun( PLC_CUCI_CMD, 208, C2_VelLimitRPM );                

                C2_PlcStatoAgo := 10;
            end_if; 
        end_if;


(* Stato 3: Stato di HOLD - preapara il timer di attesa prima di accettare un release *)
    3:  FlgWaitTime := TRUE;  
        C2_PlcStatoAgo := 4;


(* Stato 4: Stato di HOLD - attesa timer prima di accettare un release *)
    4:  if ( FlgWaitTime = FALSE ) then   
            vret := ExecPlcFun( PLC_CUCI_CMD, 204, 80 );    (* Forza uscita da G280 - #M210330_1GF# *)
            C2_PlcStatoAgo := 5;
        end_if; 


(* Stato 5: Stato di HOLD - attesa release *)
    5:  if ( ( C2_CmdReleaseHMI = TRUE ) and ( C2_CmdHoldHMI = FALSE ) ) then
            vret := ExecPlcFun( PLC_CUCI_CMD, 204, 80 );    (* Forza uscita da G280 *)
            VB_CHN2_RELEASE := TRUE;
            C2_PlcStatoAgo := 6;
        end_if; 


(* Stato 6: Stato di HOLD - attesa uscita da G280 o ingresso nel loop hold *)
(*                          verifica se e' stato ripremuto hold            *)  
    6:  if ( C2_VbFlgJtaskRunning = TRUE and C2_CmdHoldHMI = TRUE ) then
            VB_CHN2_STOP_HOLD := TRUE;
            C2_PlcStatoAgo := 5;
        else

            if ( C2_VbFlgG280Running = FALSE or C2_VbFlgJtaskLoopHold = TRUE ) then
                vret := ExecPlcFun( PLC_CUCI_CMD, 204, 1 ); (* Toglie l'hold *)
                C2_CmdHoldRelease := FALSE;
                C2_PlcStatoAgo := 0;
            end_if;
        
        end_if;

    
(* Stato 10: Attesa piedino giu (solo se automatico run ) *)        
    10: if ( VB_CHN2_AUTO_RUNNING ) then
            if ( not C2_CmdPiedinoGiu ) then
    
                    (* Start movimento di cucitura dell'asse ago *)
                GoAxPlcAgoErrCode := 0;
                GoAxPlcAgoModule := 360000;
                GoAxPlcAgoVel := -100000;
                ipar := ((C2_AsseAGO*100)+1);
                vret := ExecPlcFun( PLC_MOVE_AX_TONDO, ipar, GOAX_PLC_AGO_IDX );      
                C2_PlcStatoAgo := 20;  

                (* abilito la camma blocco filo *) 
                C2_VbEnableCammeIni := TRUE ;
            end_if;
        else                
            C2_PlcStatoAgo := 0;    
        end_if;


(* Stato 20: Gestisce limite RPM asse ago *)
(*           Attesa ago fermo             *)
(*           Test comando hold            *)  
    20: vret := ExecPlcFun( PLC_CUCI_CMD, 208, C2_VelLimitRPM );
    
        if ( C2_FaseAxAgo = 0 ) then

                (* Rollover asse ago *)
            RollPlcAgoModule := 360000;
            RollPlcAgoQuo := 0;
            ipar := ((C2_AsseAGO*100)+1);
            vret := ExecPlcFun( PLC_ROLLOVER_AX, ipar, ROLL_PLC_AGO_IDX );   

                (* Movimento a quota di ago alto *)
            MovePlcAgoErrCode := 0;
            MovePlcAgoQuoObj  := C2_AgoAlto;
            MovePlcAgoVel := -100000;
            MovePlcAgoFuture := 0;
            ipar := (C2_AsseAGO*100);
            vret := ExecPlcFun( PLC_MOVE_AX, ipar, MOVE_PLC_AGO_IDX );      

            C2_PlcStatoAgo := 25;   
        end_if;

            (* Hold viene visto solo in fase lineare *)
        if ( ( C2_CmdHoldHMI = TRUE ) and ( C2_FaseAxAgo = 2 ) ) then
            C2_CmdHoldRelease := TRUE;
            vret := ExecPlcFun( PLC_CUCI_CMD, 204, 0 );  (* Ferma il task *)

            vret := ExecPlcFun( PLC_CUCI_CMD, 208, To_Int( C2_RpmRall / 1000 ) );       
            MemActPnt := C2_VqActPntCuci;
            C2_PlcStatoAgo := 40;   
        end_if;     


(* Stato 25: Attesa ago a quota di ago alto *)
(*           Test comando hold              *)
    25: if ( C2_FaseAxAgo = 0 ) then
            C2_CmdPiedinoGiu := FALSE;
            C2_CmdPiedinoSu  := TRUE;

            C2_PlcStatoAgo := 30;   
        end_if;

        if ( ( C2_CmdHoldRelease = FALSE ) and ( C2_CmdHoldHMI = TRUE ) ) then
            C2_CmdHoldRelease := TRUE;
            vret := ExecPlcFun( PLC_CUCI_CMD, 204, 0 );  (* Ferma il task *)
        end_if;


(* Stato 30: Attesa piedino su *)
    30: if ( not C2_CmdPiedinoSu ) then
            C2_PlcStatoAgo := 0;
        end_if; 


(***********************************)
(* Stato 40: Gestione comando Hold *)
(*           Attende fase dec      *)
    40: if ( C2_FaseAxAgo = 3 ) then
            C2_PlcStatoAgo := 42;   
        end_if; 

            (* Se dovesse perdersi l'evento di asse ago in decelerazione *)
        if ( ( C2_VqActPntCuci - MemActPnt ) >= 3 ) then        
            C2_PlcStatoAgo := 42;   
        end_if; 

            (* Per ogni evenienza, in caso di asse fermo *)
        if ( C2_FaseAxAgo = 0 ) then
            C2_PlcStatoAgo := 46;   
        end_if;


(* Stato 42: Gestione comando Hold *)
(*           Attende fase lin      *)
    42: if ( C2_FaseAxAgo = 2 ) then
            MemActPnt := C2_VqActPntCuci;
            C2_PlcStatoAgo := 44;   
        end_if;     

            (* Per ogni evenienza, in caso di asse fermo *)
        if ( C2_FaseAxAgo = 0 ) then
            C2_PlcStatoAgo := 46;   
        end_if;


(* Stato 44: Gestione comando Hold          *)
(*           Attende punti di rallentamento *)
(*           Viene dato il comando di HOLD  *)
(*           Il CN esce dalla G280          *)       
    44: if ( ( C2_VqActPntCuci - MemActPnt ) >= ( C2_PtRall / 1000 ) ) then
            C2_VbHoldCuci := TRUE;
            C2_PlcStatoAgo := 46;   
        end_if;     

            (* Per ogni evenienza, in caso di asse fermo *)
        if ( C2_FaseAxAgo = 0 ) then
            C2_VbHoldCuci := TRUE;      (* HOLD CUCITRICE *)
            C2_PlcStatoAgo := 46;   
        end_if;


(* Stato 46: Gestione comando Hold  *)
(*           Attesa ago fermo       *)
    46: if ( C2_FaseAxAgo = 0 ) then

                (* Rollover asse ago *)
            RollPlcAgoModule := 360000;
            RollPlcAgoQuo := 0;
            ipar := ((C2_AsseAGO*100)+1);
            vret := ExecPlcFun( PLC_ROLLOVER_AX, ipar, ROLL_PLC_AGO_IDX );   

                (* Movimento a quota di ago alto *)
            MovePlcAgoErrCode := 0;
            MovePlcAgoQuoObj  := C2_AgoAlto;
            MovePlcAgoVel := -100000;
            MovePlcAgoFuture := 0;
            ipar := (C2_AsseAGO*100);
            vret := ExecPlcFun( PLC_MOVE_AX, ipar, MOVE_PLC_AGO_IDX );      

            C2_PlcStatoAgo := 48;   
        end_if;


(* Stato 48: Gestione comando Hold                     *)
(*           Attesa ago a quota di ago alto            *)
    48: if ( C2_FaseAxAgo = 0 ) then
            C2_PlcStatoAgo := 3;    
        end_if;


(* Default switch case *)
else
    C2_PlcStatoAgo := 0;    
end_case;

/**/
Rise_C2_CuciSimulaAuto (in:= C2_CuciSimulaAuto);
if(Rise_C2_CuciSimulaAuto.q and Vb44_PrimaTasca_C2) then 
	Vb45_TestCuciPrimaTasca_C2 := TRUE;
end_if;	


]]>
					</sourceCode>
				</program>
				<program name="C2_AppMacchina" version="1.0.0" creationDate="0" lastModifiedDate="1702979200" excludeFromBuild="FALSE">
					<vars>
						<localVars>
							<var name="CmdSu" type="BOOL"/>
							<var name="CmdGiu" type="BOOL"/>
							<var name="TimePiedinoSu" type="Ton"/>
							<var name="TimePiedinoGiu" type="Ton"/>
							<var name="RisePiedinoSu" type="RiseEdge"/>
							<var name="RisePiedinoGiu" type="RiseEdge"/>
							<var name="RiseSbloccoAgo" type="RiseEdge"/>
							<var name="FallSbloccoAgo" type="FallEdge"/>
							<var name="ReqStdFoll" type="BOOL"/>
							<var name="ReqGantryFoll" type="BOOL"/>
							<var name="AppAgoAltoC2" type="INT"/>
							<var name="RitOnAsseAgoC2" type="Ton"/>
							<var name="RitOnAsseAgoC2_2" type="Ton"/>
							<var name="Rise_Vn3804_PageID" type="RiseEdge"/>
							<var name="Fall_Vn3804_PageID" type="FallEdge"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[(* ========================================================================== 
(* SIPRO - Siax M															  	
(*                                                                            
(* COMPANY:     JAM INTERNATIONAL                                             
(*                                                                            
(* NAME: C2_AppMacchina                                                          
(*
(* TASK MAIN	 
(*
(* DESCRIPTION: APPLICAZIONE SPECIFICA DELLA MACCHINA ( CUCITRICE 2 )
(*
(* NOTE:                                NAME:           VER:    DATE:         
(* -------------------------------------------------------------------------  
(* Prima stesura                        gf              1.0     29/04/2021    
(* Ultima modifica                                                            
(* ========================================================================== *)


	(* Lettura stato asse  per verifica AGO fermo *)
if (( VnStatoAx8 & 2 ) = 2 ) then
	C2_AsseAgoFermo := FALSE ;
else
	C2_AsseAgoFermo := TRUE ;
end_if;
		

	(* Comandi alza abbassa piedino *)
CmdSu  := ( C2_CmdPiedinoSu  and not C2_CmdPiedinoGiu );
CmdGiu := ( C2_CmdPiedinoGiu and not C2_CmdPiedinoSu  );	

RisePiedinoSu(  in := CmdSu  );
RisePiedinoGiu( in := CmdGiu );

if ( RisePiedinoSu.q ) then
	if ( o49_C2_Piedino ) then
		C2_CmdPiedinoSu := FALSE;
		CmdSu := FALSE;
	end_if;
	
	o49_C2_Piedino := TRUE;			
end_if;

if ( RisePiedinoGiu.q ) then
	if ( not o49_C2_Piedino ) then 
		C2_CmdPiedinoGiu := FALSE;
		CmdGiu := FALSE;			
	end_if;
	
	o49_C2_Piedino := FALSE;			
end_if;

TimePiedinoSu(  in := CmdSu,  pt := To_Udint( C2_TSalitaPiedino ) );	
TimePiedinoGiu( in := CmdGiu, pt := To_Udint(C2_TDiscesaPiedino ) );	

if ( TimePiedinoSu.q ) then
	C2_CmdPiedinoSu := FALSE;	
end_if;

if ( TimePiedinoGiu.q ) then
	C2_CmdPiedinoGiu := FALSE;	
end_if;


(* --- Gestione inseguimento crochet --- *)

(* Aggancio inseguimento gantry *)
if ( C2_CmdGantryCrochet ) then
	VN_AX9_FOLL_MODE := 3;
	ipar := ((C2_AsseCRO*100)+71);
	vret := ExecPlcFun( PLC_ENABLE_FOLLOW, ipar, C2_GANTRY_INFO_IDX );      
	C2_CmdGantryCrochet := FALSE;
end_if;

(* Aggancio inseguimento standard 1:1 *)
if ( C2_CmdStdFollowCrochet ) then
	VN_AX9_FOLL_MODE := 1;
	ipar := (C2_AsseCRO*100);
	vret := ExecPlcFun( PLC_ENABLE_FOLLOW, ipar, 0 );      
	C2_CmdStdFollowCrochet := FALSE;
end_if;

(* Sgancio inseguimento gantry *)
if ( C2_CmdSganciaCrochet ) then
	ipar := (C2_AsseCRO*100);
	vret := ExecPlcFun( PLC_DISABLE_FOLLOW, ipar, 0 );      
	C2_CmdSganciaCrochet := FALSE;
end_if;

(* --- Gestione sblocco AGO per movimenti "a mano" se l'asse ago è fermo --- *)
	if ( not C2_AsseAgoFermo or ( VbChn2AutoRun and not C2_CmdHoldRelease ))then 
		C2_CmdSbloccaAgo := FALSE ;
	end_if;

RiseSbloccoAgo(  in := C2_CmdSbloccaAgo and C2_AsseAgoFermo );
FallSbloccoAgo(  in := C2_CmdSbloccaAgo  );

if ( RiseSbloccoAgo.q ) then
	C2_CmdSganciaCrochet := TRUE;		(* Sgancia inseguimento *)
	VB_AX8_PID_DISAB     := TRUE;		(* Disabilita PID AGO   *)	
	VN_AX8_CMD_DRIVE     := 1;		 	(* Disabilita drive     *)
	ReqStdFoll           := TRUE;       (* Req inseg. std 1:1   *)		
	AppAgoAltoC2 		 := 99 ; 		(* azzero variabile riposizionamento ago alto *) (*qui*)
end_if;

if ( ReqStdFoll and not C2_CmdSganciaCrochet ) then
	ReqStdFoll := FALSE;	
	C2_CmdStdFollowCrochet := TRUE;		(* Aggancia inseg. 1:1  *)
end_if;	


if ( FallSbloccoAgo.q ) then
	C2_CmdSganciaCrochet := TRUE;		(* Sgancia inseguimento *)
	VB_AX8_PID_DISAB     := FALSE;		(* Abilita PID AGO      *)	
	VN_AX8_CMD_DRIVE     := 0;		 	(* Abilita drive        *)	
	ReqGantryFoll        := TRUE;		(* Req. inseg. gantry   *)
end_if;

if ( ReqGantryFoll and not C2_CmdSganciaCrochet ) then
	ReqGantryFoll := FALSE;	
	C2_CmdGantryCrochet := TRUE;	    (* Aggancia gantry      *)
	AppAgoAltoC2 := 1 ; 					(* variabile riposizionamento ago alto *) (*qui*)
end_if;	





(* attesa riaggancio asse ago *)
RitOnAsseAgoC2 ( in := ( AppAgoAltoC2 = 1) ,  pt := 100 );

	if ( RitOnAsseAgoC2.q and AppAgoAltoC2 = 1 ) then
                (* Rollover asse ago *)
          RollPlcAgoModule := 360000;
          RollPlcAgoQuo := 0;
          ipar := ((C2_AsseAGO*100)+ 1);
          vret := ExecPlcFun( PLC_ROLLOVER_AX, ipar, ROLL_PLC_AGO_IDX );   
		AppAgoAltoC2 := 2 ; 					
	end_if;
	
RitOnAsseAgoC2_2 (  in := AppAgoAltoC2 = 2 ,  pt := 10 );
	
		(* riposiziono ad ago alto *)	
	
if ( RitOnAsseAgoC2_2.q and AppAgoAltoC2 = 2 and not Vb4089_TestDisableRiposizionaAgoC2 ) then
	
	if ( PosAx_C2_AsseAGO <= 180000 and AppAgoAltoC2 = 2 )then
                (* Movimento a quota di ago alto *)
            MovePlcAgoErrCode := 0;
            MovePlcAgoQuoObj  := C2_AgoAlto;
            MovePlcAgoVel := -5000;
            MovePlcAgoFuture := 0;
            ipar := (C2_AsseAGO*100);
            vret := ExecPlcFun( PLC_MOVE_AX, ipar, MOVE_PLC_AGO_IDX );      
		AppAgoAltoC2 := 3 ; 					
	end_if;
	
	if ( ( PosAx_C2_AsseAGO > 180000 and PosAx_C2_AsseAGO < ( 360000 + C2_AgoAlto ) ) and AppAgoAltoC2 = 2 )then
                (* Movimento a quota di ago alto *)
            MovePlcAgoErrCode := 0;
            MovePlcAgoQuoObj  := 360000 + C2_AgoAlto;
            MovePlcAgoVel := -5000;
            MovePlcAgoFuture := 0;
            ipar := (C2_AsseAGO*100);
            vret := ExecPlcFun( PLC_MOVE_AX, ipar, MOVE_PLC_AGO_IDX );      

		AppAgoAltoC2 := 3 ; 					
	end_if;

end_if;	
	

if ( AppAgoAltoC2 = 3 and C2_AsseAgoFermo ) then
		AppAgoAltoC2 := 0 ;
end_if;	

(* se non riposiziono l'ago alto resetto tutto *)
if ( AppAgoAltoC2 = 2 and C2_AsseAgoFermo and Vb4089_TestDisableRiposizionaAgoC2 ) then
		AppAgoAltoC2 := 0 ;
end_if;	

(*su questa pagina non faccio il riposizionamento dell'ago*)
Rise_Vn3804_PageID (in:= (Vn3804_PageID = 1004 or Vn3804_PageID = 1002));
Fall_Vn3804_PageID (in:=  (Vn3804_PageID = 1004 or Vn3804_PageID = 1002));
if(Rise_Vn3804_PageID.q) then
	Vb4089_TestDisableRiposizionaAgoC2 := TRUE;
	Vb4076_GiraAgoFaiSpolaC2 := FALSE;
end_if;
if(Fall_Vn3804_PageID.q) then
	Vb4089_TestDisableRiposizionaAgoC2 := FALSE;
end_if;

(* pinza C2 alta per HMI *)

	if ( not i55_C2_FcPinzaIntBassa  and o50_C2_Pinza_int )then
		Vb4906_AppPinzaIntAltaC2 := TRUE ;
	else
		Vb4906_AppPinzaIntAltaC2 := FALSE ;
	end_if;
	
	



]]>
					</sourceCode>
				</program>
				<program name="Piegatore" version="1.0.0" creationDate="0" lastModifiedDate="1715592782" excludeFromBuild="FALSE">
					<vars>
						<localVars>
							<var name="RiseLanciaAvDi" type="RiseEdge"/>
							<var name="RiseStep" type="RiseEdge"/>
							<var name="Rise_i25_PulsResetFolder" type="RiseEdge"/>
							<var name="FallVb4509_AppEnbPiegatore" type="FallEdge"/>
							<var name="RiseLanciaAvDiStepOFF" type="RiseEdge"/>
							<var name="RiseLanciaAvDiStepON" type="RiseEdge"/>
							<var name="Timi3_C1_PedanaPiegatore" type="Ton"/>
							<var name="FallTimi3_C1_PedanaPiegatore" type="FallEdge"/>
							<var name="Rise_Vb4021_Piegatore1" type="RiseEdge"/>
							<var name="Rise_Vb4022_Piegatore2" type="RiseEdge"/>
							<var name="Rise_Vb4023_Piegatore3" type="RiseEdge"/>
							<var name="Rise_Vb4024_Piegatore4" type="RiseEdge"/>
							<var name="Rise_Vb4025_Piegatore1_OFF" type="RiseEdge"/>
							<var name="Rise_Vb4026_Piegatore2_OFF" type="RiseEdge"/>
							<var name="Rise_Vb4027_Piegatore3_OFF" type="RiseEdge"/>
							<var name="Rise_Vb4028_Piegatore4_OFF" type="RiseEdge"/>
							<var name="mc_stati_pedala_lancia" type="INT"/>
							<var name="Ton_antirimbalzo_lancia" type="Ton"/>
							<var name="Ton_lentezza_tasca_avanti" type="Ton"/>
							<var name="Ton_lentezza_tasca_aspiratore" type="Ton"/>
							<var name="Ton_lentezza_tasca_aspiratore_passo_passo" type="Ton"/>
							<var name="FallPiegatoreBasso" type="FallEdge"/>
							<var name="RisePiegatoreGiu" type="RiseEdge"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[(* ========================================================================== 
(* SIPRO - Siax M															  	
(*                                                                            
(* COMPANY:     JAM INTERNATIONAL                                             
(*                                                                            
(* NAME: Piegatore                                                          
(*
(* TASK MAIN	 
(*
(* DESCRIPTION: Gestione piegatore 
(*
(*                                                                             
(* NOTE:                                NAME:           VER:    DATE:         
(* -------------------------------------------------------------------------  
(* Prima stesura                        Jam             1.0     29/04/2021    
(* Ultima modifica                                                            
(* ========================================================================== *)

	(* Reset su ingresso automatico *)
if ( RiseEnbAutomatico.q )then
	mc_stati_pedala_lancia :=1;	
end_if;


	(* Reset su uscita automatico *)
if ( FallEnbAutomatico.q )then
	Vb4341_AppAut_o9_Lancia_AD := FALSE ;
	Vb4507_AppManAuto := FALSE ;
	Vb4347_AppAut_o15_EvAspiratore := FALSE;	

end_if;

	
	(* pulsante stop piegatore *)
Rise_i25_PulsResetFolder ( in:= ( (Vb4010_PrgPiegatoreRun or Vb4015_PrgCaricatoreRun) and i25_PulsResetFolder and not Vb4003_RqsStopPiegatore and  Vb4010_PrgPiegatoreRun ));
if ( Rise_i25_PulsResetFolder.q ) then
	Vb4003_RqsStopPiegatore := TRUE ; 		
end_if;


	(* gestione stop piegatore su macchina a stati canale 3 *)
if ( not Vb4003_RqsStopPiegatore and not Vb4001_StepPiegatore )then
	Vb10_StepResetCanale3 := TRUE ;
else;
	Vb10_StepResetCanale3 := FALSE ;
end_if;



(* lancia in automatico *)
Ton_lentezza_tasca_avanti(in := Vb4355_AppAut_o23_Lentezza_Tasca_AD , pt:=500);
Ton_lentezza_tasca_aspiratore(in := (Vb4355_AppAut_o23_Lentezza_Tasca_AD and mc_stati_pedala_lancia = 3), pt:= TO_UDINT(Vq3091_TimeAsp_Lentezza));
 
	case ( mc_stati_pedala_lancia ) of
	
		1:
			RiseLanciaAvDi(  in := ( i3_C1_PedanaPiegatore and not Vb4010_PrgPiegatoreRun and not Vb4013_DisableLancia and Vb4509_AppEnbPiegatore and ( PosAx_C1_AsseCAR < ( Vq3500_PosizioneCaricRiposo + 5 ) )));
			if ( RiseLanciaAvDi.q and EnbAutomatico and not Vb4001_StepPiegatore)then
				PiegatoreStaSalendo := FALSE;
				if(not Vb22_device_lentezza_tasca) then	(*se il kit lentezza tasca è disattivato continuo e faccio avanzare la lancia*)
					mc_stati_pedala_lancia :=4;
					Vb4355_AppAut_o23_Lentezza_Tasca_AD := FALSE;	
				
				else
					if(not Vb4341_AppAut_o9_Lancia_AD) then 	(*se il kit lentezza tasca è attivato controllo se la lancia è avanti o dietro*)
					 	Vb4355_AppAut_o23_Lentezza_Tasca_AD := TRUE;
					 	mc_stati_pedala_lancia :=2;	
					
					else
						Vb4355_AppAut_o23_Lentezza_Tasca_AD := FALSE;	
						mc_stati_pedala_lancia :=4;
					end_if;
				
				end_if;
		
			end_if;
			
		2:
			if(Ton_lentezza_tasca_avanti.q) then
				Vb4341_AppAut_o9_Lancia_AD := not Vb4341_AppAut_o9_Lancia_AD ;
				mc_stati_pedala_lancia :=3;
			
			end_if;
			
		3:
			if(Ton_lentezza_tasca_aspiratore.q) then
				Vb4347_AppAut_o15_EvAspiratore := Vb4341_AppAut_o9_Lancia_AD ;
			
				mc_stati_pedala_lancia :=5;
			
			end_if;
			
		4:
		
			Vb4341_AppAut_o9_Lancia_AD := not Vb4341_AppAut_o9_Lancia_AD ;
			Vb4347_AppAut_o15_EvAspiratore := Vb4341_AppAut_o9_Lancia_AD ;
			if(Vb170KitTascaCargo) then
				Vb4345_AppAut_o13_Lancia_Cargo_Aperta := not Vb4345_AppAut_o13_Lancia_Cargo_Aperta;	
				Vb4348_AppAut_o16_Lancia_Cargo_Chiusa := not Vb4345_AppAut_o13_Lancia_Cargo_Aperta;			
			end_if;
			mc_stati_pedala_lancia :=5;
			
			
		5:
			Ton_antirimbalzo_lancia(in := not i3_C1_PedanaPiegatore, pt:=200);
			if(Ton_antirimbalzo_lancia.q) then
				mc_stati_pedala_lancia:=1;
			
			end_if;

	else
    	mc_stati_pedala_lancia := 0; 
		
	end_case;

(* lancia in automatico abbasso piegatore e spengo il vuoto 25/03/2024*)

	Timi3_C1_PedanaPiegatore( in := (i3_C1_PedanaPiegatore and not Vb4010_PrgPiegatoreRun and o9_Lancia_AD) , pt := 500 );

		if ( Timi3_C1_PedanaPiegatore.q and EnbAutomatico and not Vb4001_StepPiegatore)then
			Vb4344_AppAut_o12_Bilanciere_Su_Giu := TRUE ;
			Vb4347_AppAut_o15_EvAspiratore := FALSE ;
		
		end_if;

	FallTimi3_C1_PedanaPiegatore( in:= Timi3_C1_PedanaPiegatore.q );	
		if ( FallTimi3_C1_PedanaPiegatore.q and not Vb4010_PrgPiegatoreRun)then
			Vb4344_AppAut_o12_Bilanciere_Su_Giu := FALSE ;
			Vb4347_AppAut_o15_EvAspiratore := TRUE ;
		
		end_if;



(* lancia in passo-passo *)

RiseLanciaAvDiStepON(  in := ( i3_C1_PedanaPiegatore and not Vb4010_PrgPiegatoreRun and not Vb4013_DisableLancia and Vb4509_AppEnbPiegatore and ( PosAx_C1_AsseCAR < ( Vq3500_PosizioneCaricRiposo + 5 ) )));

	if ( RiseLanciaAvDiStepON.q and EnbAutomatico and Vb4001_StepPiegatore and not Vb4341_AppAut_o9_Lancia_AD )then

		if(Vb22_device_lentezza_tasca) then (* controllo se attivo il device lentezza *)	
			if(not Vb4355_AppAut_o23_Lentezza_Tasca_AD) then
		
				Vb4355_AppAut_o23_Lentezza_Tasca_AD := TRUE;
				
			else
				Vb4341_AppAut_o9_Lancia_AD := TRUE ;
								
			end_if;
		else	
	
	
			Vb4341_AppAut_o9_Lancia_AD := TRUE ;
			if(Vb170KitTascaCargo) then
				Vb4345_AppAut_o13_Lancia_Cargo_Aperta := TRUE;
			end_if;	
			Vb4347_AppAut_o15_EvAspiratore := Vb4341_AppAut_o9_Lancia_AD ;
			
		end_if;
	end_if;
(* in passo-passo se ho attivo il device lentezza ritardo l'attivazione dell'aspiratore *)	
Ton_lentezza_tasca_aspiratore_passo_passo (in:= (not Vb4347_AppAut_o15_EvAspiratore and Vb4355_AppAut_o23_Lentezza_Tasca_AD and Vb4341_AppAut_o9_Lancia_AD and EnbAutomatico and Vb4001_StepPiegatore),pt:=TO_UDINT(Vq3091_TimeAsp_Lentezza));	
	if(Ton_lentezza_tasca_aspiratore_passo_passo.q) then
	
		Vb4347_AppAut_o15_EvAspiratore := TRUE ;
		
	
	end_if;


(* se sono in passo passo spengo la lancia con il reset piegatore *)
RiseLanciaAvDiStepOFF(  in := ( Vb4001_StepPiegatore and not VbChn3AutoRun and Vb4341_AppAut_o9_Lancia_AD and i25_PulsResetFolder));

	if ( RiseLanciaAvDiStepOFF.q and EnbAutomatico )then
		Vb4341_AppAut_o9_Lancia_AD := FALSE ;
		Vb4347_AppAut_o15_EvAspiratore := FALSE ;
		Vb4355_AppAut_o23_Lentezza_Tasca_AD := FALSE;
		
	end_if;

(* ordine piegatori da programma cucitura *)
	(* CHIUSURA *)
	Vn104_Piegatore4_CH := MOD (Vn109_OrdinePiegCH,10);
	Vn103_Piegatore3_CH := MOD ((Vn109_OrdinePiegCH / 10 ),10);
	Vn102_Piegatore2_CH := MOD ((Vn109_OrdinePiegCH / 100 ),10);
	Vn101_Piegatore1_CH := MOD ((Vn109_OrdinePiegCH / 1000 ),10);
	(* APERTURA *)
	Vn108_Piegatore4_AP	:= MOD (Vn110_OrdinePiegAP,10);		
	Vn107_Piegatore3_AP := MOD ((Vn110_OrdinePiegAP / 10 ),10);		
	Vn106_Piegatore2_AP	:= MOD ((Vn110_OrdinePiegAP / 100 ),10);		
	Vn105_Piegatore1_AP := MOD ((Vn110_OrdinePiegAP / 1000 ),10);
		
		


(* associo le vb scelte alle uscite  *)

Rise_Vb4021_Piegatore1(in:= Vb4021_Piegatore1_ON);
Rise_Vb4022_Piegatore2(in:= Vb4022_Piegatore2_ON);
Rise_Vb4023_Piegatore3(in:= Vb4023_Piegatore3_ON);
Rise_Vb4024_Piegatore4(in:= Vb4024_Piegatore4_ON);
Rise_Vb4025_Piegatore1_OFF(in:= Vb4025_Piegatore1_OFF);
Rise_Vb4026_Piegatore2_OFF(in:= Vb4026_Piegatore2_OFF);
Rise_Vb4027_Piegatore3_OFF(in:= Vb4027_Piegatore3_OFF);
Rise_Vb4028_Piegatore4_OFF(in:= Vb4028_Piegatore4_OFF);

(* primo piegatore *)			
	if ( Rise_Vb4021_Piegatore1.q ) then
		Vb4021_Piegatore1_ON :=FALSE;
		if ( Vn101_Piegatore1_CH = 1 )then			(* Piegatore 1 *)
			Vb4333_AppAut_o1_Piegatore_1 := TRUE ;
		end_if;
		if ( Vn101_Piegatore1_CH = 2 )then			(* Piegatore 2 *)
			Vb4334_AppAut_o2_Piegatore_2 := TRUE ;
		end_if;
		if ( Vn101_Piegatore1_CH = 3 )then			(* Piegatore 3 *)
			Vb4335_AppAut_o3_Piegatore_3 := TRUE ;
		end_if;
		if ( Vn101_Piegatore1_CH = 4 )then			(* Piegatore 4 *)
			Vb4336_AppAut_o4_Piegatore_4 := TRUE ;
		end_if;
	end_if;
	if ( Rise_Vb4025_Piegatore1_OFF.q ) then
		Vb4025_Piegatore1_OFF := FALSE;
		if ( Vn105_Piegatore1_AP = 1 )then			(* Piegatore 1 *)
			Vb4333_AppAut_o1_Piegatore_1 := FALSE ;
		end_if;
		if ( Vn105_Piegatore1_AP = 2 )then			(* Piegatore 2 *)
			Vb4334_AppAut_o2_Piegatore_2 := FALSE ;
		end_if;
		if ( Vn105_Piegatore1_AP = 3 )then			(* Piegatore 3 *)
			Vb4335_AppAut_o3_Piegatore_3 := FALSE ;
		end_if;
		if ( Vn105_Piegatore1_AP = 4 )then			(* Piegatore 4 *)
			Vb4336_AppAut_o4_Piegatore_4 := FALSE ;
		end_if;
	end_if;
(* secondo piegatore *)			
	if ( Rise_Vb4022_Piegatore2.q ) then
		Vb4022_Piegatore2_ON :=FALSE;
		if ( Vn102_Piegatore2_CH = 1 )then			(* Piegatore 1 *)
			Vb4333_AppAut_o1_Piegatore_1 := TRUE ;
		end_if;
		if ( Vn102_Piegatore2_CH = 2 )then			(* Piegatore 2 *)
			Vb4334_AppAut_o2_Piegatore_2 := TRUE ;
		end_if;
		if ( Vn102_Piegatore2_CH = 3 )then			(* Piegatore 3 *)
			Vb4335_AppAut_o3_Piegatore_3 := TRUE ;
		end_if;
		if ( Vn102_Piegatore2_CH = 4 )then			(* Piegatore 4 *)
			Vb4336_AppAut_o4_Piegatore_4 := TRUE ;
		end_if;
	end_if;
	if ( Rise_Vb4026_Piegatore2_OFF.q ) then
		Vb4026_Piegatore2_OFF :=FALSE;
		if ( Vn106_Piegatore2_AP = 1 )then			(* Piegatore 1 *)
			Vb4333_AppAut_o1_Piegatore_1 := FALSE ;
		end_if;
		if ( Vn106_Piegatore2_AP = 2 )then			(* Piegatore 2 *)
			Vb4334_AppAut_o2_Piegatore_2 := FALSE ;
		end_if;
		if ( Vn106_Piegatore2_AP = 3 )then			(* Piegatore 3 *)
			Vb4335_AppAut_o3_Piegatore_3 := FALSE ;
		end_if;
		if ( Vn106_Piegatore2_AP = 4 )then			(* Piegatore 4 *)
			Vb4336_AppAut_o4_Piegatore_4 := FALSE ;
		end_if;
	end_if;

(* terzo piegatore *)			
	if ( Rise_Vb4023_Piegatore3.q ) then
		Vb4023_Piegatore3_ON := FALSE;
		if ( Vn103_Piegatore3_CH = 1 )then			(* Piegatore 1 *)
			Vb4333_AppAut_o1_Piegatore_1 := TRUE ;
		end_if;
		if ( Vn103_Piegatore3_CH = 2 )then			(* Piegatore 2 *)
			Vb4334_AppAut_o2_Piegatore_2 := TRUE ;
		end_if;
		if ( Vn103_Piegatore3_CH = 3 )then			(* Piegatore 3 *)
			Vb4335_AppAut_o3_Piegatore_3 := TRUE ;
		end_if;
		if ( Vn103_Piegatore3_CH = 4 )then			(* Piegatore 4 *)
			Vb4336_AppAut_o4_Piegatore_4 := TRUE ;
		end_if;
	end_if;
	if ( Rise_Vb4027_Piegatore3_OFF.q ) then
		Vb4027_Piegatore3_OFF := FALSE;
		if ( Vn107_Piegatore3_AP = 1 )then			(* Piegatore 1 *)
			Vb4333_AppAut_o1_Piegatore_1 := FALSE ;
		end_if;
		if ( Vn107_Piegatore3_AP = 2 )then			(* Piegatore 2 *)
			Vb4334_AppAut_o2_Piegatore_2 := FALSE ;
		end_if;
		if ( Vn107_Piegatore3_AP = 3 )then			(* Piegatore 3 *)
			Vb4335_AppAut_o3_Piegatore_3 := FALSE ;
		end_if;
		if ( Vn107_Piegatore3_AP = 4 )then			(* Piegatore 4 *)
			Vb4336_AppAut_o4_Piegatore_4 := FALSE ;
		end_if;
	end_if;

(* quarto piegatore *)			
	if ( Rise_Vb4024_Piegatore4.q ) then
		Vb4024_Piegatore4_ON := FALSE;
		if ( Vn104_Piegatore4_CH = 1 )then			(* Piegatore 1 *)
			Vb4333_AppAut_o1_Piegatore_1 := TRUE ;
		end_if;
		if ( Vn104_Piegatore4_CH = 2 )then			(* Piegatore 2 *)
			Vb4334_AppAut_o2_Piegatore_2 := TRUE ;
		end_if;
		if ( Vn104_Piegatore4_CH = 3 )then			(* Piegatore 3 *)
			Vb4335_AppAut_o3_Piegatore_3 := TRUE ;
		end_if;
		if ( Vn104_Piegatore4_CH = 4 )then			(* Piegatore 4 *)
			Vb4336_AppAut_o4_Piegatore_4 := TRUE ;
		end_if;
	end_if;
	if ( Rise_Vb4028_Piegatore4_OFF.q ) then
		Vb4028_Piegatore4_OFF := FALSE;
		if ( Vn108_Piegatore4_AP = 1 )then			(* Piegatore 1 *)
			Vb4333_AppAut_o1_Piegatore_1 := FALSE ;
		end_if;
		if ( Vn108_Piegatore4_AP = 2 )then			(* Piegatore 2 *)
			Vb4334_AppAut_o2_Piegatore_2 := FALSE ;
		end_if;
		if ( Vn108_Piegatore4_AP = 3 )then			(* Piegatore 3 *)
			Vb4335_AppAut_o3_Piegatore_3 := FALSE ;
		end_if;
		if ( Vn108_Piegatore4_AP = 4 )then			(* Piegatore 4 *)
			Vb4336_AppAut_o4_Piegatore_4 := FALSE ;
		end_if;
	end_if;


(* il piegatore risale, prendo al volo il fronte sensore *)
FallPiegatoreBasso (in:= o11_Piegatore_Su_Giu and  VbChn3AutoRun);
RisePiegatoreGiu  (in:= o11_Piegatore_Su_Giu and  VbChn3AutoRun);

if(RisePiegatoreGiu.q) then
	PiegatoreStaSalendo := FALSE;
	Vb84PiegatoreRisalito := FALSE;

end_if;

				
if(FallPiegatoreBasso.q) then
	PiegatoreStaSalendo := TRUE;

end_if;	
]]>
					</sourceCode>
				</program>
				<program name="Uscite" version="1.0.0" creationDate="0" lastModifiedDate="1715273847" excludeFromBuild="FALSE">
					<vars/>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[(* ========================================================================== 
(* SIPRO - Siax M															  	
(*                                                                            
(* COMPANY:     JAM INTERNATIONAL                                             
(*                                                                            
(* NAME: Uscite                                                          
(*
(* TASK MAIN	 
(*
(* DESCRIPTION: Gestione uscite 
(*
(*                                                                             
(* NOTE:                                NAME:           VER:    DATE:         
(* -------------------------------------------------------------------------  
(* Prima stesura                        Jam             1.0     29/04/2021    
(* Ultima modifica                                                            
(* ========================================================================== *)

											(* caricatore *)
(* O33 Piegatore 1 *)
	if (( EnbManuale and Vb4133_AppMan_o1_Piegatore_1 ) or ( EnbAutomatico and Vb4333_AppAut_o1_Piegatore_1 ))then 
		o1_Piegatore_1 := TRUE ;	
	else;
		o1_Piegatore_1 := FALSE ;	
	end_if;

(* o2 Piegatore 2 *)
	if (( EnbManuale and Vb4134_AppMan_o2_Piegatore_2 ) or ( EnbAutomatico and Vb4334_AppAut_o2_Piegatore_2 ))then 
		o2_Piegatore_2 := TRUE ;	
	else;
		o2_Piegatore_2 := FALSE ;	
	end_if;

(* o3 Piegatore 3 *)
	if (( EnbManuale and Vb4135_AppMan_o3_Piegatore_3 ) or ( EnbAutomatico and Vb4335_AppAut_o3_Piegatore_3 ))then 
		o3_Piegatore_3 := TRUE ;	
	else;
		o3_Piegatore_3 := FALSE ;	
	end_if;

(* o9 lancia *)
	if (( EnbManuale and Vb4141_AppMan_o9_Lancia_AD ) or ( ( EnbAutomatico or Vb7_TestManutRun ) and Vb4341_AppAut_o9_Lancia_AD ))then 
		o9_Lancia_AD := TRUE ;	
	else;
		o9_Lancia_AD := FALSE ;	
	end_if;

(* o10 Piegatore Avanti Dietro *)
	if (( EnbManuale and Vb4142_AppMan_o10_Piegatore_AD ) or ( EnbAutomatico and Vb4342_AppAut_o10_Piegatore_AD ))then 
		o10_Piegatore_AD := TRUE ;	
	else;
		o10_Piegatore_AD := FALSE ;	
	end_if;

(* o11 Piegatore Su Giu *)
	if (( EnbManuale and Vb4143_AppMan_o11_Piegatore_Su_Giu ) or ( EnbAutomatico and Vb4343_AppAut_o11_Piegatore_Su_Giu ))then 
		o11_Piegatore_Su_Giu := TRUE ;	
	else;
		o11_Piegatore_Su_Giu := FALSE ;	
	end_if;

(* o12 Bilanciere Su Giu *)
	if (( EnbManuale and Vb4144_AppMan_o12_Bilanciere_Su_Giu ) or ( ( EnbAutomatico or Vb7_TestManutRun ) and Vb4344_AppAut_o12_Bilanciere_Su_Giu ))then 
		o12_Bilanciere_Su_Giu := TRUE ;	
	else;
		o12_Bilanciere_Su_Giu := FALSE ;	
	end_if;

(* o4 Piegatore 4 *)
	if ((( EnbManuale or Vb7_TestManutRun ) and Vb4136_AppMan_o4_Piegatore_4 ) or ( EnbAutomatico and ( Vb4336_AppAut_o4_Piegatore_4 or Vb9_ChiudePiegatore4 )))then 
		o4_Piegatore_4 := TRUE ;	
	else;
		o4_Piegatore_4 := FALSE ;	
	end_if;

(* o24_Pinza_carico_Su_Giu *)
	if (( EnbManuale and Vb4156_AppMan_o24_Pinza_carico_Su_Giu ) or ( ( EnbAutomatico or Vb7_TestManutRun ) and Vb4356_AppAut_o24_Pinza_carico_Su_Giu ))then 
		o24_Pinza_carico_Su_Giu := TRUE ;	
	else;
		o24_Pinza_carico_Su_Giu := FALSE ;	
	end_if;



(* o7_Cambio_lame_lateral *)
	if (( EnbManuale and Vb4139_AppMan_o7_Cambio_lame_lateral and ( o25_C1_Cambio_Pinze or Vn3804_PageID = 1005) ))then 
		o7_Cambio_lame_lateral := TRUE ;	
	else;
		o7_Cambio_lame_lateral := FALSE ;	
	end_if;

(* o6_Cambio_lama_front *)
	if (( EnbManuale and Vb4138_AppMan_o6_Cambio_lama_front  and ( o25_C1_Cambio_Pinze or Vn3804_PageID = 1005) ))then 
		o6_Cambio_lama_front := TRUE ;	
	else;
		o6_Cambio_lama_front := FALSE ;	
	end_if;

(* o5_Cambio_corpo *)
	if (( EnbManuale and Vb4137_AppMan_o5_Cambio_corpo  and ( o25_C1_Cambio_Pinze or Vn3804_PageID = 1005) ))then 
		o5_Cambio_corpo := TRUE ;	
	else;
		o5_Cambio_corpo := FALSE ;	
	end_if;
	
(* o8_Cambio_Lamelle_4_5 *)
	if (( EnbManuale and Vb4140_AppMan_o8_Cambio_Lamelle_4_5  and ( o25_C1_Cambio_Pinze or Vn3804_PageID = 1005) ))then 
		o8_Cambio_Lamelle_4_5 := TRUE ;	
	else;
		o8_Cambio_Lamelle_4_5 := FALSE ;	
	end_if;	
	
	
	
	

(* o15 aspiratore *)
	if ((( EnbManuale or Vb7_TestManutRun ) and Vb4147_AppMan_o15_EvAspiratore ) or ( EnbAutomatico and Vb4347_AppAut_o15_EvAspiratore ))then 
		o15_EvAspiratore := TRUE ;	
	else;
		o15_EvAspiratore := FALSE ;	
	end_if;



											(* cucitrice 1 *)
											
(* o17_C1_Piedino *)
	if(Vn3804_PageID = 1005) then
		if ( EnbManuale and Vb4149_AppMan_o17_C1_Piedino  )then 
			o17_C1_Piedino := TRUE ;	
		else;
			o17_C1_Piedino := FALSE ;	
		end_if;	
	end_if;											
			
			
(* o49_C2_Piedino *)
	if(Vn3804_PageID = 1005) then
		if ( EnbManuale and Vb4181_AppMan_o49_C2_Piedino  )then 
			o49_C2_Piedino := TRUE ;	
		else;
			o49_C2_Piedino := FALSE ;	
		end_if;	
	end_if;	 											
											
(* o18_C1_Pinza_int *)
	if (( EnbManuale and Vb4150_AppMan_o18_C1_Pinza_int ) or ( Vb4350_AppAut_o18_C1_Pinza_int ))then 
		o18_C1_Pinza_int := TRUE ;	

	else;
		o18_C1_Pinza_int := FALSE ;	

	end_if;

(* o19_C1_Pinza_est *)
	if (( EnbManuale and Vb4151_AppMan_o19_C1_Pinza_est ) or ( Vb4351_AppAut_o19_C1_Pinza_est ))then 
		o19_C1_Pinza_est := TRUE ;	
	else;
		o19_C1_Pinza_est := FALSE ;	
	end_if;

(* o25_C1_Cambio_Pinze *)
	if(not EnbManuale) then
		if ( (o8_Cambio_Lamelle_4_5 or o5_Cambio_corpo or o6_Cambio_lama_front or o7_Cambio_lame_lateral)and not Vn3804_PageID = 1005 )then
			Vb4157_AppMan_o25_C1_Cambio_Pinze := TRUE ; 
		end_if;
	
		if ( not o25_C1_Cambio_Pinze )then
			if(not Vn3804_PageID = 1005) then		//pagina Test IO
				Vb4139_AppMan_o7_Cambio_lame_lateral := FALSE ;
				Vb4338_AppAut_o6_Cambio_lama_front := FALSE ;
				Vb4137_AppMan_o5_Cambio_corpo := FALSE ;
				Vb4140_AppMan_o8_Cambio_Lamelle_4_5 := FALSE ;
			end_if;	
		end_if;		
	end_if;
		

	if (( EnbManuale and Vb4157_AppMan_o25_C1_Cambio_Pinze ))then 
		o25_C1_Cambio_Pinze := TRUE ;	
	else;
		o25_C1_Cambio_Pinze := FALSE ;	
	end_if;


(* o14_C1_rasafilo *)
	if(Vn3804_PageID = 1005) then
		if ( EnbManuale and Vb4146_AppMan_o14_C1_rasafilo  )then 
			o14_C1_rasafilo := TRUE ;	
		else;
			o14_C1_rasafilo := FALSE ;	
		end_if;	
	end_if;	
	
(* o32_Enable_AssiXY_C1 
	if(Vn3804_PageID = 1005) then
		if ( EnbManuale and Vb4165_AppMan_o33_Valvolone  )then 
			o32_Enable_AssiXY_C1 := TRUE ;	
		else;
			o32_Enable_AssiXY_C1 := FALSE ;	
		end_if;	
	end_if;	
*)	
	

											(* cucitrice 2 *)
(* o46_C2_rasafilo *)
	if(Vn3804_PageID = 1005) then
		if ( EnbManuale and Vb4178_AppMan_o46_C2_rasafilo  )then 
			o46_C2_rasafilo := TRUE ;	
		else;
			o46_C2_rasafilo := FALSE ;	
		end_if;	
	end_if;	
				
				
(* o48_Enable_AssiXY_C2 
	if (EnbManuale and Vb4180_AppMano_48_Enable_AssiXY_C2 )then 
	
		o48_Enable_AssiXY_C2 := TRUE ;		
	else;
	
		o48_Enable_AssiXY_C2 := FALSE ;	


	end_if;					
				
*)				
												
(* o50_C2_Pinza_int *)
	if (( EnbManuale and Vb4182_AppMan_o50_C2_Pinza_int ) or ( Vb4382_AppAut_o50_C2_Pinza_int ))then 
		o50_C2_Pinza_int := TRUE ;	
		
		if(Vn2CodiceAllarmeXHmi = 39) then
			Vn2CodiceAllarmeXHmi := 0;
		end_if;
	else;
		o50_C2_Pinza_int := FALSE ;	
	end_if;

(* o57_C2_Cambio_Pinze *)
	if (( EnbManuale and Vb4189_AppMan_o57_C2_Cambio_Pinze ))then 
		o57_C2_Cambio_Pinze := TRUE ;	
	else;
		o57_C2_Cambio_Pinze := FALSE ;	
	end_if;



									(* traslatore *)

(* o56_Piza_tras_su_giu *)
	if (( EnbManuale and Vb4188_AppMan_o56_Piza_tras_su_giu ) or ( Vb4388_AppAut_o56_Pinza_tras_su_giu ))then 
		o56_Pinza_tras_su_giu := TRUE ;	
	else;
		o56_Pinza_tras_su_giu := FALSE ;	
	end_if;




									(* Scaricatore *)

(* o54_Scaric_dx_sx *)
	if (( EnbManuale and Vb4186_AppMan_o54_Scaric_dx_sx ) or ( Vb4386_AppAut_o54_Scaric_dx_sx ))then 
			
			o54_Scaric_dx_sx:= TRUE ;			
	else;	
			o54_Scaric_dx_sx:= FALSE ;			
	end_if;

(* o60_Prima_barra *)
	if (( EnbManuale and Vb4192_AppMan_o60_Prima_barra ) or ( Vb4392_AppAut_o60_Prima_barra ))then 
	
			o60_Prima_barra:= TRUE ;
	else;
		
			o60_Prima_barra:= FALSE ;

	end_if;


(* o61_Seconda_barra *)
	if (( EnbManuale and Vb4193_AppMan_o61_Seconda_barra ) or ( Vb4393_AppAut_o61_Seconda_barra ))then 
	
			o61_Seconda_barra := TRUE ;	
	else;
	
			o61_Seconda_barra := FALSE ;	

	end_if;

	
	
(* o31_C1_bloccaFiloMagente *)
if(Vn3804_PageID = 1005) then
	if (EnbManuale and Vb4163_AppMan_o31_C1_bloccaFiloMagente )then 
		o31_C1_bloccaFiloMagente := TRUE ;	
		
	else;
		o31_C1_bloccaFiloMagente := FALSE ;	

			
	end_if;
end_if;

(* o63_C2_bloccaFiloMagente *)
if(Vn3804_PageID = 1005) then
	if ( EnbManuale and Vb4195_AppMan_C2_bloccaFiloMagente )then 
		o63_C2_bloccaFiloMagente := TRUE ;	
		
	else;
		o63_C2_bloccaFiloMagente := FALSE ;	

			
	end_if;	
	
end_if;		
(* o32_Enable_AssiXY_C1 
	if (EnbManuale and Vb4164_AppMan_o32_Enable_AssiXY_C1)then 
	
		o32_Enable_AssiXY_C1 := TRUE ;		
	else;
	
		o32_Enable_AssiXY_C1 := FALSE ;	


	end_if;	
*)	

(* o33_Valvolone *)
//	if (( EnbManuale and Vb4165_AppMan_o33_Valvolone ) or ( Vb4365_AppAut_o33_Valvolone ))then ..
	if ( Vb4365_AppAut_o33_Valvolone )then 
		o33_Valvolone := TRUE ;	
	else;
		o33_Valvolone := FALSE ;	
	end_if;

	
									(* OP1 testa 1 *)

(* o20_C1_Retrattile_AC *)
	if (( EnbManuale and Vb4152_AppMan_o20_C1_Retrattile_AC ) or ( Vb4352_AppAut_o20_C1_Retrattile_AC ))then 
		o20_C1_Retrattile_AC := TRUE ;	
	else;
		o20_C1_Retrattile_AC := FALSE ;	
	end_if;

	
									(* OP2 testa 1 *)

(* o27_C1_Ranocchia_retrat *)
	if (( EnbManuale and Vb4159_AppMan_o27_C1_Ranocchia_retrat ) or ( Vb4359_AppAut_o27_C1_Ranocchia_retrat ))then 
		o27_C1_Ranocchia_retrat := TRUE ;	
	else;
		o27_C1_Ranocchia_retrat := FALSE ;	
	end_if;


									(* OP3 testa 1 *)

(* o26_C1_Scalino_Piedino *)
	if (( EnbManuale and Vb4158_AppMan_o26_C1_Scalino_Piedino ) or ( Vb4358_AppAut_o26_C1_Scalino_Piedino ))then 
		o26_C1_Scalino_Piedino := TRUE ;	
	else;
		o26_C1_Scalino_Piedino := FALSE ;	
	end_if;

									(* OP3 testa 2 *)

(* o58_C2_Scalino_Piedino *)
	if (( EnbManuale and Vb4190_AppMan_o58_C2_Scalino_Piedino ) or ( Vb4390_AppAut_o58_C2_Scalino_Piedino ))then 
		o58_C2_Scalino_Piedino := TRUE ;	
	else;
		o58_C2_Scalino_Piedino := FALSE ;	
	end_if;



(* raffreddamento ago *)
(* cucitrice 1 *)
	if (( EnbManuale and Vb4153_AppMan_o21_C1_RaffreddamentoAgo ) or ( Vb4353_AppAut_o21_C1_RaffreddamentoAgo ))then 
		o21_C1_RaffreddamentoAgo := TRUE ;
	else;
		o21_C1_RaffreddamentoAgo := FALSE ;
	end_if;

(* cucitrice 2 *)
	if (( EnbManuale and Vb4185_AppMan_o53_C2_RaffreddamentoAgo ) or ( Vb4385_AppAut_o53_C2_RaffreddamentoAgo ))then 
		o53_C2_RaffreddamentoAgo := TRUE ;
	else;
		o53_C2_RaffreddamentoAgo := FALSE ;
	end_if;
	
	

(* o23 Lentezza_Tasca_AD *)
	if (( EnbManuale and Vb4155_AppMan_o23_Lentezza_Tasca_AD ) or ( Vb4355_AppAut_o23_Lentezza_Tasca_AD ))then 
		o23_Lentezza_Tasca_AD := TRUE ;
	else;
		o23_Lentezza_Tasca_AD := FALSE ;
	end_if;	
(* o51_PinzaPattina_1 *)

if (( EnbManuale and Vb4183_AppMan_o51_PinzaPattina_1 ) or ( Vb4383_AppAut_o51_PinzaPattina_1 ))then 
	o51_PinzaPattina_1 := TRUE ;
else;
	o51_PinzaPattina_1 := FALSE ;
end_if;	

(* o52_PinzaPattina_2 *)

if (( EnbManuale and Vb4184_AppMan_o52_PinzaPattina_2 ) or ( Vb4384_AppAut_o52_PinzaPattina_2 ))then 
	o52_PinzaPattina_2 := TRUE ;
else;
	o52_PinzaPattina_2 := FALSE ;
end_if;	

(* o13_Lancia_Cargo_Aperta *)

if (( EnbManuale and Vb4145_AppMan_o13_Lancia_Cargo_Aperta ) or ( Vb4345_AppAut_o13_Lancia_Cargo_Aperta  ))then 
	o13_Lancia_Cargo_Aperta := TRUE ;
else;
	o13_Lancia_Cargo_Aperta := FALSE ;
end_if;	
(* o16_Lancia_Cargo_Chiusa *)

if (( EnbManuale and Vb4148_AppMan_o16_Lancia_Cargo_Chiusa ) or ( Vb4348_AppAut_o16_Lancia_Cargo_Chiusa  ))then 
	o16_Lancia_Cargo_Chiusa := TRUE ;
else;
	o16_Lancia_Cargo_Chiusa := FALSE ;
end_if;	

(* o34_CarPat_FrontBack *)

if (( EnbManuale and Vb4166_AppMan_o34_CarPat_FrontBack ) or ( Vb4366_AppAut_o34_CarPat_FrontBack  ))then 
	o34_CarPat_FrontBack := TRUE ;
else;
	o34_CarPat_FrontBack := FALSE ;
end_if;	

(* o35_CarPat_Aghi *)

if (( EnbManuale and Vb4167_AppMan_o35_CarPat_Aghi ) or ( Vb4367_AppAut_o35_CarPat_Aghi  ))then 
	o35_CarPat_Aghi := TRUE ;
else;
	o35_CarPat_Aghi := FALSE ;
end_if;	

(* o36_CarPat_SoffioAghi *)

if (( EnbManuale and Vb4168_AppMan_o36_CarPat_SoffioAghi ) or ( Vb4368_AppAut_o36_CarPat_SoffioAghi  ))then 
	o36_CarPat_SoffioAghi := TRUE ;
else;
	o36_CarPat_SoffioAghi := FALSE ;
end_if;	

(* o37_CarPat_SoffiPattina *)

if (( EnbManuale and Vb4169_AppMan_o37_CarPat_SoffiPattina ) or ( Vb4369_AppAut_o37_CarPat_SoffiPattina  ))then 
	o37_CarPat_SoffiPattina := TRUE ;
else;
	o37_CarPat_SoffiPattina := FALSE ;
end_if;

(* o38_CarPat_DCGiu *)

if (( EnbManuale and Vb4170_AppMan_o38_CarPat_DCGiu ) or ( Vb4370_AppAut_o38_CarPat_DCGiu  ))then 
	o38_CarPat_DCGiu := TRUE ;
else;
	o38_CarPat_DCGiu := FALSE ;
end_if;	

(* o39_CarPat_DCSu *)

if (( EnbManuale and Vb4171_AppMan_o39_CarPat_DCSu ) or ( Vb4371_AppAut_o39_CarPat_DCSu  ))then 
	o39_CarPat_DCSu := TRUE ;
else;
	o39_CarPat_DCSu := FALSE ;
end_if;	
]]>
					</sourceCode>
				</program>
				<program name="RitSensori" version="1.0.0" creationDate="0" lastModifiedDate="1702997448" excludeFromBuild="FALSE">
					<vars>
						<localVars>
							<var name="Riti24_C1_PinzaEstAlta" type="Ton"/>
							<var name="Rit_i49_FcPinzaTraslBassa" type="Ton"/>
							<var name="Rit_i23_C1_PinzaIntBassa" type="Ton"/>
							<var name="Rise_i49_PinzaTrasloAlta" type="RiseEdge"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[(* ========================================================================== 
(* SIPRO - Siax M															  	
(*                                                                            
(* COMPANY:     JAM INTERNATIONAL                                             
(*                                                                            
(* NAME: RitSensori                                                          
(*
(* TASK MAIN	 
(*
(* DESCRIPTION: Gestione ritardi sensori ciclo automatico
(*
(*                                                                             
(* NOTE:                                NAME:           VER:    DATE:         
(* -------------------------------------------------------------------------  
(* Prima stesura                        Jam             1.0     29/04/2021    
(* Ultima modifica                                                            
(* ========================================================================== *)

(* sensore C1 pinza esterna bassa *)
Riti24_C1_PinzaEstAlta( in := ( not i24_C1_PinzaEstAlta and ( VnStatoCuci1 = 16 ) and not Vb4351_AppAut_o19_C1_Pinza_est ), pt := TO_UDINT(Vq3050_RitC1_Pinza_est_OFF) );

	if ( Riti24_C1_PinzaEstAlta.q )then
		Vb4601_AppRit_i24_C1_PinzaEstAlta := TRUE ;
	else;
		Vb4601_AppRit_i24_C1_PinzaEstAlta := FALSE ;
	end_if;		

(* sensore C1 pinza interna alta *)
Rit_i23_C1_PinzaIntBassa( in := ( not i23_C1_PinzaIntBassa and ( VnStatoCuci2 = 22 ) and  Vb4350_AppAut_o18_C1_Pinza_int ), pt := TO_UDINT(Vq3052_RitC1_Pinza_int_ON) );

	if ( Rit_i23_C1_PinzaIntBassa.q )then
		Vb4603_AppRit_i23_C1_PinzaIntBassa := TRUE ;
	else;
		Vb4603_AppRit_i23_C1_PinzaIntBassa := FALSE ;
	end_if;		










	

(* ritardo pinza traslatore bassa *)
Rit_i49_FcPinzaTraslBassa( in := ( not i38_FcPinzaTraslAlta and ( VnStatoCuci2 = 21 or VnStatoCuci2 = 200) and  Vb4388_AppAut_o56_Pinza_tras_su_giu ), pt := TO_UDINT(Vq3070_RitPinzaTraslatore_ON) );

	if ( Rit_i49_FcPinzaTraslBassa.q )then
		Vb4602_AppRit_i49_FcPinzaTraslBassa := TRUE ;
//	else;
//		Vb4602_AppRit_i49_FcPinzaTraslBassa := FALSE ;
	end_if;	
	
Rise_i49_PinzaTrasloAlta( in :=i38_FcPinzaTraslAlta);
	if(Rise_i49_PinzaTrasloAlta.q) then
		Vb4602_AppRit_i49_FcPinzaTraslBassa := FALSE ;
	end_if;



]]>
					</sourceCode>
				</program>
				<program name="AppMainC1" version="1.0.0" creationDate="0" lastModifiedDate="1710429098" excludeFromBuild="FALSE">
					<vars>
						<localVars>
							<var name="RisePinzeC1" type="RiseEdge"/>
							<var name="RiseStartC1" type="RiseEdge"/>
							<var name="RiseStopC1" type="RiseEdge"/>
							<var name="RiseReleaseC1" type="RiseEdge"/>
							<var name="RiseAbortC1" type="RiseEdge"/>
							<var name="RitAbort" type="Ton"/>
							<var name="TimScatafilo" type="Ton"/>
							<var name="RiseVb4035" type="RiseEdge"/>
							<var name="RisePinzeC1_Emerg" type="RiseEdge"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[(* ========================================================================== 
(* SIPRO - Siax M															  	
(*                                                                            
(* COMPANY:     JAM INTERNATIONAL                                             
(*                                                                            
(* NAME: AppMainC1                                                          
(*
(* TASK MAIN	 
(*
(* DESCRIPTION: Programma Main ( canale 1 ) 
(*
(* NOTE:                                NAME:           VER:    DATE:         
(* -------------------------------------------------------------------------  
(* Prima stesura                        gf              1.0     13/03/2021    
(* Macchina a stati scartafilo          Jam             1.1     13/03/2021    
(* Ultima modifica                                                            
(* ========================================================================== *)

(* main funzioni su cucitrice canale 1 *)
(* sono in manuale attivo la pinza *)

(* comando pinze con pedana in manuale *)
RisePinzeC1(  in := ( (i2_C1_Pedana or VbSimulazionePedanaC1) and not Vb4507_AppManAuto and MacchinaAzzerata and not Vb4506_AppCambioPinzeRun and not Vb86In_Azzeramento_C1));
							
	if ( RisePinzeC1.q and not Vb4803_AppResetHmiC1 and not C1_VbRunCuci and (PosAx_C2_AsseCAR < (Vq3521_PosizioneTraslAspCaricoTascaC1+5)) and not RichiestaStartCuci2)then
		VbSimulazionePedanaC1 := FALSE;
		if (Vn3804_PageID = 1001  and Vb4045_C1_AxXFermo and Vb4046_C1_AxYFermo ) then		//se sono in Hold non alzo e abbasso le pinze
		
			if(not C1_CmdHoldRelease) then 
		
				if ( not Vb4350_AppAut_o18_C1_Pinza_int ) then
					
				 	Vb4350_AppAut_o18_C1_Pinza_int := TRUE;
				 	Vb4351_AppAut_o19_C1_Pinza_est := TRUE;
				 	C1_CmdPiedinoGiu :=FALSE;
				 	C1_CmdPiedinoSu := TRUE ;
				 	
				 else	
				 
				 	Vb4350_AppAut_o18_C1_Pinza_int := FALSE;
				 	Vb4351_AppAut_o19_C1_Pinza_est := FALSE;
				 	C1_CmdPiedinoSu := FALSE ;
				 	C1_CmdPiedinoGiu := TRUE ;
			
				end_if;
			else
			
			if(Vb4045_C1_AxXFermo and Vb4046_C1_AxYFermo) then
				(* piedino C1*)
				if ( not o17_C1_Piedino )then
					C1_CmdPiedinoSu := TRUE ;
				end_if;
				if ( o17_C1_Piedino)then
					C1_CmdPiedinoGiu := TRUE ;
				end_if;
			end_if;			
				
				
			end_if;
		end_if;
		
		
		if(Vn3804_PageID > 0 and Vb4045_C1_AxXFermo and Vb4046_C1_AxYFermo) then
				(* piedino C1*)
				if ( not o17_C1_Piedino )then
					C1_CmdPiedinoSu := TRUE ;
				end_if;
				if ( o17_C1_Piedino)then
					C1_CmdPiedinoGiu := TRUE ;
				end_if;
			end_if;			
		
		
		(*
			Vb4350_AppAut_o18_C1_Pinza_int := not Vb4350_AppAut_o18_C1_Pinza_int ;
			Vb4351_AppAut_o19_C1_Pinza_est := Vb4350_AppAut_o18_C1_Pinza_int ;
		end_if;
		if(Vb4045_C1_AxXFermo and Vb4046_C1_AxYFermo) then
				(* piedino C1*)
	(*		if ( not o17_C1_Piedino )then
				C1_CmdPiedinoSu := TRUE ;
			end_if;
			if ( o17_C1_Piedino)then
				C1_CmdPiedinoGiu := TRUE ;
			end_if;
		end_if;
		*)
			
	end_if;
(* pagina emergenza, macchina armata, e non ancora azzerata  *)
RisePinzeC1_Emerg ( in:=(i2_C1_Pedana and not MacchinaAzzerata and VN_SYS_PAGE_ID = 0 and Vb4045_C1_AxXFermo and Vb4046_C1_AxYFermo and not Vb86In_Azzeramento_C1));
if(RisePinzeC1_Emerg.q ) then

		Vb4350_AppAut_o18_C1_Pinza_int := not Vb4350_AppAut_o18_C1_Pinza_int ;
		Vb4351_AppAut_o19_C1_Pinza_est := Vb4350_AppAut_o18_C1_Pinza_int ;
end_if;
(* comando start macchina con pulsanti in manuale tolto  *)

RiseStartC1(  in := ( ( i1_Pulsanti_start or Vb4801_PulsStartHmiC1 ) and not VB_CHN_AUTO_RUNNING and not Vb4507_AppManAuto and MacchinaAzzerata and not Vb4350_AppAut_o18_C1_Pinza_int and not Vb4351_AppAut_o19_C1_Pinza_est  and not Vb4506_AppCambioPinzeRun));

	if ( RiseStartC1.q and Vn2CodiceAllarmeXHmi = 0 and Vn3804_PageID <= 1001)then  (*Daniele: permetto partenza se non ci sono errore HMI*)
	
		VbChn1Start := TRUE ;
		Vn16GoCuci := 1;
		Vb4801_PulsStartHmiC1 := FALSE ;

	end_if;
	(*
	if ( RiseStartC1.q and not VbChn3AutoRun )then
		//	 VnStatoCuci1 := 30 ;
		//	VbChn3Start := TRUE ;
			 
			Vn16GoCuci := 1;
			Vb4015_PrgCaricatoreRun := FALSE;		 
			 
			 
			 
  			 VnStatoCuci2 := 0 ;
	end_if;
*)

(* comando stop/hold C1 *)
RiseStopC1(  in := ( VB_CHN_AUTO_RUNNING and not C1_CmdHoldRelease and i26_C1_PulsStopTesta ));
	if ( RiseStopC1.q )then
		C1_CmdHoldHMI := TRUE ;
	end_if;
		if ( C1_CmdHoldHMI and C1_CmdHoldRelease)then
			C1_CmdHoldHMI := FALSE ;
		end_if;

(* comando Restart/release C1 *)
RiseReleaseC1(  in := (VB_CHN_AUTO_RUNNING and C1_CmdHoldRelease and not C1_CuciSimulaAuto and ( i1_Pulsanti_start or Vb4801_PulsStartHmiC1 and not Vn3804_PageID = 1005) ));
	if ( RiseReleaseC1.q and Vn2CodiceAllarmeXHmi = 0)then (*Daniele: permetto ripartenza se non ci sono errore HMI*)
		C1_CmdReleaseHMI := TRUE ;
		Vb4801_PulsStartHmiC1 := FALSE ;
	end_if;
	
		if ( C1_CmdReleaseHMI and not C1_CmdHoldRelease)then
			C1_CmdReleaseHMI := FALSE ;
		end_if;

(* comando di reset per tagliare il programma *)
(* comando reset/abort C1 *)
RiseAbortC1(  in := (VB_CHN_AUTO_RUNNING and C1_CmdHoldRelease and Vb4802_PulsResetHmiC1 ));
	if ( RiseAbortC1.q )then
	
		
		VbChn1Reset := TRUE ;
		Vb4803_AppResetHmiC1 := TRUE ; 
		Vb4802_PulsResetHmiC1 := FALSE ;
		if(Vn2CodiceAllarmeXHmi = 2) then
			Vn2CodiceAllarmeXHmi :=0;   (*Daniele HMI*)
		end_if;
		vret := ExecPlcFun( PLC_CUCI_CMD, 153,0);   (*Daniele Restart estrazione punti dal buffer di cucitura*)
	end_if;
	
(* faccio partire il canale 1 dopo il reset *)
RitAbort( in := Vb4803_AppResetHmiC1 , pt := 50 );
	if ( RitAbort.q )then
		VbChn1Start := TRUE ;
	end_if;



 	



(* ----------------------------- *)
(* MACCHINA A STATI - SCARTAFILO *)
(* ----------------------------- *)

case ( C1_PlcStatoScartafilo ) of

(*          abbasso il piedino : passa in stato 5  	*)
    0:  if ( Vb4038_Scatena_scartafilo ) then
			    C1_CmdPiedinoSu  := FALSE;
                C1_CmdPiedinoGiu := TRUE;
            C1_PlcStatoScartafilo := 5;
        end_if;

(*	aspetto il piedino basso per attivare il soffio *)
    5:  if ( not C1_CmdPiedinoGiu ) then
			Vb4353_AppAut_o21_C1_RaffreddamentoAgo := TRUE ;
			C1_PlcStatoScartafilo := 10;
        end_if; 
        
(*	aspetto il tempo soffio per attivare il piedino *)
    10:  if ( TimScatafilo.q ) then
				Vb4353_AppAut_o21_C1_RaffreddamentoAgo := FALSE ;
			    C1_CmdPiedinoGiu := FALSE;
                C1_CmdPiedinoSu  := TRUE;
			C1_PlcStatoScartafilo := 15;
        end_if;

(*	aspetto il piedino altoo *)
    15:  if ( not C1_CmdPiedinosu ) then
			Vb4038_Scatena_scartafilo := FALSE ;
			Vb4035_Sync_scartafilo := FALSE ;
			C1_PlcStatoScartafilo := 0;
        end_if;


(* Default switch case *)
else
    C1_PlcStatoScartafilo := 0;    
end_case;


(* timer soffio scartafilo *)
TimScatafilo( in := C1_PlcStatoScartafilo = 10 , pt := TO_UDINT(Vq3053_Tim_C1_Scartafilo) );


(* ritorno della chiamata Scartafilo dal programma cucitura *)
(*Daniele 05/05/21*)
RiseVb4035  ( in :=Vb4035_Sync_scartafilo and ( Vn14TipoScartafiloC1 = 0 or Vn14TipoScartafiloC1 = 1));
if ( RiseVb4035.q )then
		Vb4035_Sync_scartafilo := FALSE ;
	end_if;
]]>
					</sourceCode>
				</program>
				<program name="AppMainC2" version="1.0.0" creationDate="0" lastModifiedDate="1715274322" excludeFromBuild="FALSE">
					<vars>
						<localVars>
							<var name="RisePinzeC2" type="RiseEdge"/>
							<var name="RiseStartC2" type="RiseEdge"/>
							<var name="RiseStopC2" type="RiseEdge"/>
							<var name="RiseReleaseC2" type="RiseEdge"/>
							<var name="RiseAbortC2" type="RiseEdge"/>
							<var name="RitAbort" type="Ton"/>
							<var name="TimScatafilo" type="Ton"/>
							<var name="RisePinzeC2_Emerg" type="RiseEdge"/>
							<var name="RisePinzeC1" type="RiseEdge"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[(* ========================================================================== 
(* SIPRO - Siax M															  	
(*                                                                            
(* COMPANY:     JAM INTERNATIONAL                                             
(*                                                                            
(* NAME: AppMainC21                                                          
(*
(* TASK MAIN	 
(*
(* DESCRIPTION: Programma Main ( canale 2 ) 
(*
(* NOTE:                                NAME:           VER:    DATE:         
(* -------------------------------------------------------------------------  
(* Prima stesura                        gf              1.0     13/03/2021    
(* Macchina a stati scartafilo          Jam             1.1     13/03/2021    
(* Ultima modifica                                                            
(* ========================================================================== *)

(* main funzioni su cucitrice canale 2 *)
(* sono in manuale attivo la pinza *)

(* comando pinze con pedana in manuale *)
RisePinzeC2(  in := ( ( i33_C2_Pedana or Vb4904_AppPedaleHmiC2 or VbSimulazionePedanaC2 ) and not Vb4507_AppManAuto and MacchinaAzzerata and not Vb4506_AppCambioPinzeRun and not Vb4006_StepTraslatore and not Vb87In_Azzeramento_C2  and not C2_CuciSimulaAuto));

	if ( RisePinzeC2.q and not Vb4903_AppResetHmiC2 and not C2_VbRunCuci)then
		VbSimulazionePedanaC2 := FALSE;
		if (Vn3804_PageID = 1001) then		//se sono in Hold non alzo e abbasso le pinze	
			if( not C2_CmdHoldRelease ) then
			
				if ( not Vb4382_AppAut_o50_C2_Pinza_int ) then
				 	Vb4382_AppAut_o50_C2_Pinza_int := TRUE;
	
				 	C2_CmdPiedinoGiu :=FALSE;
				 	C2_CmdPiedinoSu := TRUE ;
				 	
				 else	
				 	
				 	Vb4382_AppAut_o50_C2_Pinza_int := FALSE;
	
				 	C2_CmdPiedinoSu := FALSE ;
				 	C2_CmdPiedinoGiu := TRUE ;
				end_if;
			else
			
				if(Vb4050_C2_AxXFermo and Vb4051_C2_AxYFermo) then
					(* piedino C2*)
					if ( not o49_C2_Piedino )then
						C2_CmdPiedinoSu := TRUE ;
					end_if;
					if ( o49_C2_Piedino)then
						C2_CmdPiedinoGiu := TRUE ;
					end_if;	
				end_if;	
			end_if;	
		end_if;	
		
		if(Vn3804_PageID > 0 and Vb4050_C2_AxXFermo and Vb4051_C2_AxYFermo) then
					(* piedino C2*)
					if ( not o49_C2_Piedino )then
						C2_CmdPiedinoSu := TRUE ;
					end_if;
					if ( o49_C2_Piedino)then
						C2_CmdPiedinoGiu := TRUE ;
					end_if;	
		end_if;		
	end_if;
(* se abbasso la pinza della prima testa, in alcuni casi abbasso anche quella della seconda *)	
RisePinzeC1(  in := (i2_C1_Pedana and not VbChn2AutoRun and not Vb4350_AppAut_o18_C1_Pinza_int and not Vb4016_PrgTraslatoreRun));
	if(RisePinzeC1.q and not Vb4523_C2_PinzaDietroUnaTesta and not Vb30_C1_InCucitura and not  C1_CmdHoldRelease) then
		Vb4382_AppAut_o50_C2_Pinza_int := FALSE;
			C2_CmdPiedinoGiu := TRUE ;
	end_if;		

(* pagina emergenza, macchina armata, e non ancora azzerata  *)
RisePinzeC2_Emerg ( in:=((i33_C2_Pedana or Vb4904_AppPedaleHmiC2) and not MacchinaAzzerata and VN_SYS_PAGE_ID = 0 and Vb4051_C2_AxYFermo and Vb4050_C2_AxXFermo and not Vb87In_Azzeramento_C2));
if(RisePinzeC2_Emerg.q ) then
	
		Vb4382_AppAut_o50_C2_Pinza_int := not Vb4382_AppAut_o50_C2_Pinza_int ;
	
end_if;


(* comando start macchina con pulsanti in manuale *)

RiseStartC2(  in := ( Vb4901_PulsStartHmiC2 and not VB_CHN2_AUTO_RUNNING and not Vb4507_AppManAuto and MacchinaAzzerata and not Vb4382_AppAut_o50_C2_Pinza_int  and not Vb4506_AppCambioPinzeRun and not Vb4523_C2_PinzaDietroUnaTesta ));

	
	if ( RiseStartC2.q )then
		if(i55_C2_FcPinzaIntBassa) then
			VbChn2Start := TRUE ;
			Vb4901_PulsStartHmiC2 := FALSE ;
			Vn200_Tipo_DXSX_Ultima_cucita_su_C1 :=0; //se parto con il tasto, l'aternanza programma tasca Dx/Sx non viene forzato dalla C1 
		
		else
			Vn2CodiceAllarmeXHmi :=33;	//segnalo allarme sensore pinza interno non acceso
		end_if;					
	end_if;	

(*
	if ( RiseStartC2.q )then
		VbChn3Start := TRUE ;
		Vb4901_PulsStartHmiC2 := FALSE ;
	end_if;

	if ( RiseStartC2.q and not VbChn3AutoRun )then
			 VnStatoCuci1 := 5 ;
  			 VnStatoCuci2 := 30 ;
	end_if;
*)



(* comando stop/hold C2 *)
RiseStopC2(  in := (VB_CHN2_AUTO_RUNNING and not C2_CmdHoldRelease and (i27_C2_PulsStopTesta or i58_C2_PulsStopTesta) ));
	if ( RiseStopC2.q )then
		C2_CmdHoldHMI := TRUE ;
	end_if;
		if ( C2_CmdHoldHMI and C2_CmdHoldRelease)then
			C2_CmdHoldHMI := FALSE ;
		end_if;

(* comando Restart/release C2 *)
RiseReleaseC2(  in := (VB_CHN2_AUTO_RUNNING and C2_CmdHoldRelease and Vb4901_PulsStartHmiC2 and not C2_CuciSimulaAuto));
	if ( RiseReleaseC2.q )then
		C2_CmdReleaseHMI := TRUE ;
		Vb4901_PulsStartHmiC2 := FALSE ;
	end_if;
	
		if ( C2_CmdReleaseHMI and not C2_CmdHoldRelease)then
			C2_CmdReleaseHMI := FALSE ;
		end_if;

(* comando di reset per tagliare il programma *)
(* comando reset/abort C1 *)
RiseAbortC2(  in := (VB_CHN2_AUTO_RUNNING and C2_CmdHoldRelease and Vb4902_PulsResetHmiC2 ));
	if ( RiseAbortC2.q )then
	

		VbChn2Reset := TRUE ;
		Vb4903_AppResetHmiC2 := TRUE ; 
		Vb4902_PulsResetHmiC2 := FALSE ;
		
		if(Vn2CodiceAllarmeXHmi = 38) then		//rottura filo
			Vn2CodiceAllarmeXHmi :=0;   (*Daniele HMI*)
		end_if;	
		vret := ExecPlcFun( PLC_CUCI_CMD, 253,0);   (*Daniele Restart estrazione punti dal buffer di cucitura*)
	end_if;
	
(* faccio partire il canale 2 dopo il reset *)
RitAbort( in := Vb4903_AppResetHmiC2 , pt := 50 );
	if ( RitAbort.q )then
		VbChn2Start := TRUE ;
	end_if;

	
	
	
(* scartafilo C2 *)
(* se disabilitato forzo a 0 *)
	if ( not Vb4095_EnbScartafiloC2 )then
		Vb4097_AppOnScartafiloC2 := FALSE ;
		Vb4099_OnSeqScartafiloC2 := FALSE ;	
	end_if;

(*  cucitura *)
	if ( Vb4097_AppOnScartafiloC2 )then
		Vb4099_OnSeqScartafiloC2 := TRUE ;	
	end_if;

 	 
 	 


(* ----------------------------- *)
(* MACCHINA A STATI - SCARTAFILO *)
(* ----------------------------- *)

case ( C2_PlcStatoScartafilo ) of

(*          abbasso il piedino : passa in stato 5  	*)
    0:  if ( Vb4099_OnSeqScartafiloC2 ) then
			    C2_CmdPiedinoSu  := FALSE;
                C2_CmdPiedinoGiu := TRUE;
            C2_PlcStatoScartafilo := 5;
        end_if;

(*	aspetto il piedino basso per attivare il soffio *)
    5:  if ( not C2_CmdPiedinoGiu ) then
				Vb4385_AppAut_o53_C2_RaffreddamentoAgo := TRUE ;
			C2_PlcStatoScartafilo := 10;
        end_if; 
        
(*	aspetto il tempo soffio per attivare il piedino *)
    10:  if ( TimScatafilo.q ) then
				Vb4385_AppAut_o53_C2_RaffreddamentoAgo := FALSE ;
			    C2_CmdPiedinoGiu := FALSE;
                C2_CmdPiedinoSu  := TRUE;
			C2_PlcStatoScartafilo := 15;
        end_if;

(*	aspetto il piedino basso per attivare il soffio *)
    15:  if ( not C2_CmdPiedinosu ) then
				Vb4099_OnSeqScartafiloC2 := FALSE ;
				Vb4097_AppOnScartafiloC2 := FALSE ;
			C2_PlcStatoScartafilo := 0;
        end_if;


(* Default switch case *)
else
    C2_PlcStatoScartafilo := 0;    
end_case;


(* timer soffio scartafilo *)
TimScatafilo( in := C2_PlcStatoScartafilo = 10 , pt := TO_UDINT(Vq3063_Tim_C2_Scartafilo) );


]]>
					</sourceCode>
				</program>
				<program name="Caricatore" version="1.0.0" creationDate="0" lastModifiedDate="1702996566" excludeFromBuild="FALSE">
					<vars>
						<localVars>
							<var name="RisePinzaSuGiu" type="RiseEdge"/>
							<var name="Rise_i1_Pulsanti_start_caricatore" type="RiseEdge"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[(* ========================================================================== 
(* SIPRO - Siax M															  	
(*                                                                            
(* COMPANY:     JAM INTERNATIONAL                                             
(*                                                                            
(* NAME: Caricatore                                                          
(*
(* TASK MAIN	 
(*
(* DESCRIPTION: Gestione caricatore
(*
(*                                                                             
(* NOTE:                                NAME:           VER:    DATE:         
(* -------------------------------------------------------------------------  
(* Prima stesura                        Jam             1.0     29/04/2021    
(* Ultima modifica                                                            
(* ========================================================================== *)


(* Reset su ingresso automatico *)
	if ( RiseEnbAutomatico.q )then
				
	end_if;


(* Reset su uscita automatico *)
	if ( FallEnbAutomatico.q )then
	end_if;

(* gestione caricatore automatico *)


(* posiziono caricatore  



(* posiziono caricatore alla quota carico  *)

	if ( Rise_Vb4511_AppEnbCaricatore.q )then
                    (* Start movimento asse caricatore *)
				GoAxPlcCaricErrCode := 0;
				GoAxPlcCariObj := Vq3501_PosizioneCaricCaricoTasca ;
				GoAxPlcCaricVel:= Vq3512_VelocitaCaricTastiPieCar * -1  ;
				GoAxPlcCaric := 0;
				
				ipar := ((C1_AsseCAR*100)+1);
                vret := ExecPlcFun( PLC_MOVE_AX, ipar, GOAX_PLC_CARIC_IDX ); 
                
                Vb4015_PrgCaricatoreRun := FALSE;
                
	end_if;



(* posiziono caricatore alla quota riposo  *)

	if ( Fall_Vb4511_AppEnbCaricatore.q )then
                    (* Start movimento asse caricatore *)
				GoAxPlcCaricErrCode := 0;
				GoAxPlcCariObj := Vq3500_PosizioneCaricRiposo ;
				GoAxPlcCaricVel:= Vq3512_VelocitaCaricTastiPieCar * -1  ;
				GoAxPlcCaric := 0;
				
				ipar := ((C1_AsseCAR*100)+1);
                vret := ExecPlcFun( PLC_MOVE_AX, ipar, GOAX_PLC_CARIC_IDX );      
	end_if;


(* abbassa pinza caricatore *)
RisePinzaSuGiu(  in := ( i3_C1_PedanaPiegatore and not Vb4015_PrgCaricatoreRun and Vb4511_AppEnbCaricatore )and Vb4049_C1_AsseCARFermo);

	if ( RisePinzaSuGiu.q and EnbAutomatico )then
		Vb4356_AppAut_o24_Pinza_carico_Su_Giu := not Vb4356_AppAut_o24_Pinza_carico_Su_Giu ;
	end_if;




(* start ciclo caricatore tasca prestirata*)
Rise_i1_Pulsanti_start_caricatore (in:= i1_Pulsanti_start and o24_Pinza_carico_Su_Giu and Vb4507_AppManAuto);
	if ( (Rise_i1_Pulsanti_start_caricatore.q or Vb4005_AvvioCaricatore)  and Vb4511_AppEnbCaricatore )then
	
		if (not VbChn3AutoRun )then
			Vb4007_MemoriaAvviaCaric := FALSE;
			VbChn3Start := TRUE ;
			Vb4005_AvvioCaricatore := TRUE ;
		else
			Vb4007_MemoriaAvviaCaric := FALSE;
			Vb4005_AvvioCaricatore := TRUE ;
		end_if;
		
	end_if;	
	
	//se premo start e sto già cucendo la tasca prima allora me lo tengo in memoria per poi caricare appena ha finito di cucire
	if(i1_Pulsanti_start and o24_Pinza_carico_Su_Giu and VbChn3AutoRun) then
		Vb4007_MemoriaAvviaCaric := TRUE;
	
	end_if;
	//se mi ero memorizzato uno start e alzo la pinza carico allora annullo la memorizzazione
	if(Vb4007_MemoriaAvviaCaric and not o24_Pinza_carico_Su_Giu) then
		Vb4007_MemoriaAvviaCaric := FALSE;
	end_if;
	
	
		


]]>
					</sourceCode>
				</program>
				<program name="Scaricatore" version="1.0.0" creationDate="0" lastModifiedDate="1702997612" excludeFromBuild="FALSE">
					<vars>
						<localVars>
							<var name="Rit_o32_Scaric_dx_sx" type="Ton"/>
							<var name="Rit_o30_Seconda_barra" type="Ton"/>
							<var name="Rit_o32_Scaric_dx_sxOFF" type="Ton"/>
							<var name="Rit_Scaric_OFF" type="Ton"/>
							<var name="Punti_avanza_scaricatore" type="DINT"/>
							<var name="Rit_Caricatore_Avanti" type="Ton"/>
							<var name="Rise_Barra2" type="RiseEdge"/>
							<var name="Ton_Barra1_Scaricatore_su_rasafilo" type="Ton"/>
							<var name="RisePinzaOffC2Dw" type="RiseEdge"/>
							<var name="RisePinzaOnC2Dw" type="RiseEdge"/>
							<var name="Rit_MoveAsseY_C2_ON" type="Ton"/>
							<var name="Rise_Vb4519_AppScaricoCortiConPinza" type="RiseEdge"/>
							<var name="Fall_Vb4519_AppScaricoCortiConPinza" type="FallEdge"/>
							<var name="Rise_Vb4515_AppEnbScaricatore" type="RiseEdge"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[(* ========================================================================== 
(* SIPRO - Siax M															  	
(*                                                                            
(* COMPANY:     JAM INTERNATIONAL                                             
(*                                                                            
(* NAME: Scaricatore                                                          
(*
(* TASK MAIN	 
(*
(* DESCRIPTION: Gestione scaricatore
(*
(*                                                                             
(* NOTE:                                NAME:           VER:    DATE:         
(* -------------------------------------------------------------------------  
(* Prima stesura                        Jam             1.0     29/04/2021    
(* Ultima modifica                                                            
(* ========================================================================== *)

case ( Vn_ID_macchina) of
	
	882:
(* se ho il caricatore abilitato aziono valvola dx sx *)
	if ( Vb4515_AppEnbScaricatore )then
		if ((Vq3540_PuntiAvvioDxSx > ( C2_VqTotPntCuci - C2_VqActPntCuci ) ) and VbChn2AutoRun and C2_VbRunCuci ) then
			Vb4386_AppAut_o54_Scaric_dx_sx := TRUE ;
		
		end_if;	
	end_if;
	
	862: (*862M*)
	if ( Vb4515_AppEnbScaricatore )then
		Punti_avanza_scaricatore := C1_VqTotPntCuci -Vq3540_PuntiAvvioDxSx;
		
		if (Punti_avanza_scaricatore <  1 ) then
			Punti_avanza_scaricatore := 1 ;
		end_if;
		
		if ((Punti_avanza_scaricatore <  C1_VqActPntCuci ) and VbChn1AutoRun ) then
			Vb4386_AppAut_o54_Scaric_dx_sx := TRUE ;
		end_if;	
	end_if;
	860: (*862HM*)
	if ( Vb4515_AppEnbScaricatore )then
		Punti_avanza_scaricatore := C1_VqTotPntCuci -Vq3540_PuntiAvvioDxSx;
		
		if (Punti_avanza_scaricatore <  1 ) then
			Punti_avanza_scaricatore := 1 ;
		end_if;
		
		if ((Punti_avanza_scaricatore <  C1_VqActPntCuci ) and VbChn1AutoRun ) then
			Vb4386_AppAut_o54_Scaric_dx_sx := TRUE ;
		end_if;	
	end_if;
	
end_case;	

Rise_Vb4515_AppEnbScaricatore (in:= Vb4515_AppEnbScaricatore);


(* ritardo ok per scaricatore dx sx on *)
Rit_o32_Scaric_dx_sx( in := ( Vb4386_AppAut_o54_Scaric_dx_sx and Vb4515_AppEnbScaricatore ) , pt := TO_UDINT(Vq3080_RitScaricatoreDxSx_ON_OK) );

	if ( Rit_o32_Scaric_dx_sx.q )then
		Vb4031_AppScaricatoreInPos := TRUE ;
	else;
		Vb4031_AppScaricatoreInPos := FALSE ;
	end_if;		



(* ritardo prima barra *)
Ton_Barra1_Scaricatore_su_rasafilo( in := ( Vb4032_AppScaricatoreStrBarre and Vb4515_AppEnbScaricatore  ) , pt := TO_UDINT(Vq3085_RitPrimaBarra_ScarSuRasafilo) );

	if (not Vb4034_ScaricOnSuRasafilo) then

		if ( Vb4032_AppScaricatoreStrBarre and Vb4515_AppEnbScaricatore )then
			Vb4392_AppAut_o60_Prima_barra := TRUE ;
		end_if;
	else
		if(	Ton_Barra1_Scaricatore_su_rasafilo.q) then
			Vb4392_AppAut_o60_Prima_barra := TRUE ;
		end_if;	
		
	end_if;		
	
(* ritardo seconda barra *)
(*Rit_o30_Seconda_barra( in := ( Vb4392_AppAut_o60_Prima_barra and Vb4515_AppEnbScaricatore and o18_C1_Pinza_int and o19_C1_Pinza_est) , pt := TO_UDINT( Vq3082_RitScaricatorePrimaBarra ) );*)
Rit_o30_Seconda_barra( in := ( Vb4392_AppAut_o60_Prima_barra and Vb4515_AppEnbScaricatore) , pt := TO_UDINT( Vq3082_RitScaricatorePrimaBarra ) );

	if ( Rit_o30_Seconda_barra.q )then
		Vb4393_AppAut_o61_Seconda_barra := TRUE;
	end_if;		

(* ritardo OFF scaricatore dx sx on *)
Rit_o32_Scaric_dx_sxOFF( in := ( Vb4393_AppAut_o61_Seconda_barra and Vb4515_AppEnbScaricatore ) , pt := TO_UDINT( Vq3083_RitScaricatoreSecondaBarra ) );

	if ( Rit_o32_Scaric_dx_sxOFF.q )then
		Vb4386_AppAut_o54_Scaric_dx_sx := FALSE ;
	end_if;		


(* ritardo OFF scaricatore  *)
Rit_Scaric_OFF( in := ( Rit_o32_Scaric_dx_sxOFF.q or not Vb4515_AppEnbScaricatore ) , pt := TO_UDINT( Vq3081_RitScaricatoreDxSx_OFF ) );

	if ( Rit_Scaric_OFF.q )then
			Vb4386_AppAut_o54_Scaric_dx_sx := FALSE ;
			Vb4392_AppAut_o60_Prima_barra := FALSE ;
			Vb4393_AppAut_o61_Seconda_barra := FALSE ;
			Vb4032_AppScaricatoreStrBarre := FALSE ;
			
		
	end_if;		



(* ritardo avanzata caricatore sotto le pinze di cucitura *)
Rise_Barra2( in := ( Vb4032_AppScaricatoreStrBarre ));

	if ( Rise_Barra2.q )then
		Vb4033_RitardoAvanzataCaricatore := TRUE;
	end_if;
Rit_Caricatore_Avanti( in := ( Vb4033_RitardoAvanzataCaricatore ) , pt := TO_UDINT( Vq3025_RitCarRispettoBarra2 ) );

	if ( Rit_Caricatore_Avanti.q )then
		Vb4033_RitardoAvanzataCaricatore := FALSE;
	end_if;		



(**** SCARICATORE con esclusa TESTA 2 ****************
(* esclusione testa 2 *)
	(* mando la pinza C2 indietro se ho lo scaricatore attivo + cucitura 1 testa *)
	if ( (Fall_Vb4513_AppEnbCucitrice2.q and Vb4515_AppEnbScaricatore) or (not Vb4513_AppEnbCucitrice2 and Rise_Vb4515_AppEnbScaricatore.q) and not VB_CHN2_AUTO_RUNNING )then
		EnbMoveAsseY_C2_ON := TRUE ;
		C2_CmdPiedinoSu := TRUE ;
		Vb4382_AppAut_o50_C2_Pinza_int := TRUE ;	
	end_if;

(* aspetto pinza bassa  *)




RisePinzaOffC2Dw(  in := ( EnbMoveAsseY_C2_ON and not Vb4513_AppEnbCucitrice2));
 

(* posiziono asse Y indietro  *)

	if ( (RisePinzaOffC2Dw.q or Fall_Vb4519_AppScaricoCortiConPinza.q)  and i21_Emg)then
                    (* Start movimento asse Y cucitrice 2 *)
				GoAxPlcCaricErrCode := 0;
				GoAxPlcCariObj := Vq3550_PosAsseY_C2_OFF ;
				GoAxPlcCaricVel:=  -50000 ;  (*C2_Udf_FeedG0  ;*)
				GoAxPlcCaric := 0;
			
				ipar := ((C2_AsseY*100)+1);
                vret := ExecPlcFun( PLC_MOVE_AX, ipar, GOAX_PLC_CARIC_IDX ); 
			MoveAsseY_C2_ON := TRUE ;
			Vb4523_C2_PinzaDietroUnaTesta := TRUE;
			
		
			
	end_if;




(* posiziono asse Y indietro  *)
	(* abbasso la pinza *)
	if ( Rise_Vb4513_AppEnbCucitrice2.q and i21_Emg )then;
		EnbMoveAsseY_C2_ON := TRUE ;
		C2_CmdPiedinoSu := TRUE ;

		Vb4382_AppAut_o50_C2_Pinza_int := TRUE;

	end_if;

(* posiziono asse Y avanti   *)
(*RisePinzaOnC2Dw(  in := ( EnbMoveAsseY_C2_ON and i102_C2_FcPinzaIntBassa and not Vb4382_AppAut_o50_C2_Pinza_int and Vb4513_AppEnbCucitrice2));*)
RisePinzaOnC2Dw(  in := ( EnbMoveAsseY_C2_ON and Rise_Vb4513_AppEnbCucitrice2.q and not VB_CHN2_AUTO_RUNNING));

	if ( (RisePinzaOnC2Dw.q or Rise_Vb4519_AppScaricoCortiConPinza.q) and i21_Emg)then
                    (* Start movimento asse Y cucitrice 2 *)
				GoAxPlcCaricErrCode := 0;
				GoAxPlcCariObj := C2_QuoHomeY ;
				GoAxPlcCaricVel:= -50000 ;  (*C2_Udf_FeedG0  ;*)
				GoAxPlcCaric := 0;
				
				ipar := ((C2_AsseY*100)+1);
                vret := ExecPlcFun( PLC_MOVE_AX, ipar, GOAX_PLC_CARIC_IDX );  
            MoveAsseY_C2_ON := TRUE ;   
            Vb4523_C2_PinzaDietroUnaTesta := FALSE;
      
            	
	end_if;


(* appena fermo alzo la pinza *)
Rit_MoveAsseY_C2_ON( in := ( MoveAsseY_C2_ON and VbFlgPosAx7 ) , pt := 20 );


	if (  Rit_MoveAsseY_C2_ON.q and i21_Emg)then

			EnbMoveAsseY_C2_ON := FALSE ;
            MoveAsseY_C2_ON := FALSE ;    
            C2_CmdPiedinoSu := TRUE ;
			Vb4382_AppAut_o50_C2_Pinza_int := TRUE ;
	
			
		
	end_if;

	

(************* PEZZI CORTI ****************

(*pezzi corti*)
	
Rise_Vb4519_AppScaricoCortiConPinza (in := Vb4519_AppScaricoCortiConPinza and not Vb4513_AppEnbCucitrice2 and not VbChn2AutoRun and not Vb4016_PrgTraslatoreRun);
 
Fall_Vb4519_AppScaricoCortiConPinza(in := Vb4519_AppScaricoCortiConPinza);	

]]>
					</sourceCode>
				</program>
				<program name="Param_Delta" version="1.0.0" creationDate="0" lastModifiedDate="1619702712" excludeFromBuild="FALSE">
					<vars/>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[(* ========================================================================== 
(* SIPRO - Siax M															  	
(*                                                                            
(* COMPANY:     JAM INTERNATIONAL                                             
(*                                                                            
(* NAME: Param_Delta                                                          
(*
(* TASK MAIN	 
(*
(* DESCRIPTION:  Lettura e scrittura del parametri dell'azionamento Delta ADSDA-A2
(*
(*		#### NON MODIFICARE ####
(*                                                                             
(* NOTE:                                NAME:           VER:    DATE:         
(* -------------------------------------------------------------------------  
(* Prima stesura                        gf              1.0     29/04/2021    
(* Ultima modifica                                                            
(* ========================================================================== *)


(* -------------------------------------------- *)
(* Status del canale di comunicazione SDO       *)
(* 1 = canale di comunicazione non disponibile  *)
(* 0 = canale di comunicazione attivo           *)
(* -------------------------------------------- *)
(* NOTA: aggiungere tutte le condizioni di      *)
(*       canale non disponibile                 *)
(*       Esempio: automatico run ...            *)  
if ( ( C1_SDO_ErrCode > 0 ) or ( VB_CHN_AUTO_RUNNING ) or ( VB_CHN2_AUTO_RUNNING ) or ( VB_CHN3_AUTO_RUNNING ) ) then
    C1_SetParamStatus := 1;
else    
    C1_SetParamStatus := 0;
end_if; 


(* Error Code *)
if ( C1_SDO_ErrCode < 0 ) then
    C1_SetParamErrCode := -C1_SDO_ErrCode;
else    
    C1_SetParamErrCode := 0;
end_if;

(* Comando di lettura / scrittura SDO *)
(*  1 = lettura                       *)
(*  2 = scrittura                     *)
 
if ( C1_SetParamCmd > 0 ) then
    if ( C1_SetParamStatus = 0 ) then

            (* Imposta un numero di nodo non valido *)
        C1_SDO_Node := 0;
        
            (* Dato il numero dell'asse si ricava rete e nodo *)
        ipar := ((C1_SetParamAxNum*100)+3);    
        vret := ExecPlcFun( PLC_ECAT_INFO, ipar, C1_SDO_RW_PAR_IDX ); 
        
        C1_SDO_ObjIndex := C1_SetParamIdx + ( C1_SetParamCat * 256 ) + 8192;
        C1_SDO_SubIndex := 0;
        C1_SDO_Size     := C1_SetParamSize; 
        C1_SDO_VqDataIdx:= C1_SDO_VQ_DATA_IDX; 
    
        if ( C1_SetParamCmd = 1 ) then
            vret := ExecPlcFun( PLC_ECAT_SDO_RD, C1_SDO_ERRCODE_IDX, C1_SDO_RW_PAR_IDX ); 
        end_if;

        if ( C1_SetParamCmd = 2 ) then
            vret := ExecPlcFun( PLC_ECAT_SDO_WR, C1_SDO_ERRCODE_IDX, C1_SDO_RW_PAR_IDX ); 
        end_if;

    end_if;
    
    C1_SetParamCmd := 0;
end_if;

]]>
					</sourceCode>
				</program>
				<program name="OutAnalogicheT1" version="1.0.0" creationDate="0" lastModifiedDate="1715668991" excludeFromBuild="FALSE">
					<vars>
						<localVars>
							<var name="RiseVb4061_AppTensAumentaTesta1" type="RiseEdge"/>
							<var name="RiseVb4062_AppTensDiminuisceTesta1" type="RiseEdge"/>
							<var name="AppON_TensioneTesta1" type="BOOL"/>
							<var name="TimIniTensioneTesta1" type="Ton"/>
							<var name="TimeOutTensioneTesta1" type="Ton"/>
							<var name="RiseVb4065_AppTensAumentaSotto" type="RiseEdge"/>
							<var name="RiseVb4066_AppTensDiminuisceSotto" type="RiseEdge"/>
							<var name="TimeOutElettrocSopra" type="Ton"/>
							<var name="RiseVb4067_AppTensAumentaSopra" type="RiseEdge"/>
							<var name="RiseVb4068_AppTensDiminuisceSopra" type="RiseEdge"/>
							<var name="TimeOutElettrocSotto" type="Ton"/>
							<var name="FallVbChn1AutoRun" type="FallEdge"/>
							<var name="RiseC1_CmdReleaseHMI" type="RiseEdge"/>
							<var name="TimTesta1Release" type="Ton"/>
							<var name="AppON_TensioneTesta2Release" type="BOOL"/>
							<var name="VcdIdxT1" type="INT"/>
							<var name="RitOffTensSimT1" type="Ton"/>
							<var name="RiseC1_VbRunCuci" type="RiseEdge"/>
							<var name="FallC1_VbRunCuci" type="FallEdge"/>
							<var name="TensioneT1Fix3" type="DINT"/>
							<var name="RiseBloccaFilo_C1" type="RiseEdge"/>
							<var name="FallBloccaFilo_C1" type="FallEdge"/>
							<var name="TimTestTensioneTesta1" type="Ton"/>
							<var name="TimTestTensioneBloccaFilo1" type="Ton"/>
							<var name="TimTestMagneteSottoPiegatore" type="Ton"/>
							<var name="TimTestMagneteSopraPiegatore" type="Ton"/>
							<var name="Fall_Vb4208_AppMagneteTensione" type="FallEdge"/>
							<var name="Fall_Vb4210_AppMagneteSopraPiegatore" type="FallEdge"/>
							<var name="Fall_Vb4209_AppMagneteBloccaFilo" type="FallEdge"/>
							<var name="Fall_Vb4211_AppMagneteSottoPiegatore" type="FallEdge"/>
							<var name="RitOffTensContaSpola" type="Ton"/>
							<var name="Inizio_cucitura" type="BOOL"/>
							<var name="Rise_Inizio_Cucitura" type="RiseEdge"/>
							<var name="Tim_Inizio_Cucitura" type="Ton"/>
							<var name="Fall_Camma_Apritensione" type="FallEdge"/>
							<var name="Tim_Fall_Camma_Apritensione" type="Ton"/>
							<var name="Rise_Camma_Apritensione" type="RiseEdge"/>
							<var name="Chiudi_tensione_dopo_rasafilo" type="BOOL"/>
							<var name="StatusAout98BloccaFilo" type="BOOL"/>
							<var name="TimRiduzioneMagneteSopraPiegatore" type="Ton"/>
							<var name="TimeRiduzioneOutElettrocSotto" type="Ton"/>
							<var name="TonSalvaUdf" type="Ton"/>
							<var name="Rise_FineCodiceTensione" type="RiseEdge"/>
							<var name="ColpoForteTensione" type="BOOL"/>
							<var name="RiseBloccaFilo_C2" type="RiseEdge"/>
							<var name="FallBloccaFilo_C2" type="FallEdge"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[(* ========================================================================== 
(* SIPRO - Siax M															  	
(*                                                                            
(* COMPANY:     JAM INTERNATIONAL                                             
(*                                                                            
(* NAME: OutAnalogicheT1                                                          
(*
(* TASK MAIN	 
(*
(* DESCRIPTION: Gestione tensione elettronica testa 1
(*
(*                                                                             
(* NOTE:                                NAME:           VER:    DATE:         
(* -------------------------------------------------------------------------  
(* Prima stesura                        Jam             1.0     29/04/2021    
(* Ultima modifica                                                            
(* ========================================================================== *)

(* hmi impostazione manuale *)

	RiseVb4061_AppTensAumentaTesta1(  in :=  Vb4061_AppTensAumentaTesta1 );
	RiseVb4062_AppTensDiminuisceTesta1(  in :=  Vb4062_AppTensDiminuisceTesta1 );
	
(* hmi attivo magnete dopo impostazione impostazione manuale *)

if ( RiseVb4061_AppTensAumentaTesta1.q or RiseVb4062_AppTensDiminuisceTesta1.q or (C1_CmdPiedinoGiu and not Vb30_C1_InCucitura))then

	Vb4061_AppTensAumentaTesta1:= FALSE;
	Vb4062_AppTensDiminuisceTesta1 := FALSE;
	if(mc_stati_PiuMenoTensione = 0)then
		mc_stati_PiuMenoTensione :=1;
	end_if;
	
	

end_if;



(* timer colpo tensione a 5V *)
TimIniTensioneTesta1( in := AppON_TensioneTesta1 , pt := TO_UDINT(Vq3094_TimeColpoTensione ) );
(* timeout tensione manuale dopo colpo a 5 V*)
TimeOutTensioneTesta1( in := ( AppON_TensioneTesta1 and not Vb4061_AppTensAumentaTesta1 and not Vb4062_AppTensDiminuisceTesta1 and not Vb30_C1_InCucitura), pt := TO_UDINT(Vq3095_TimeChiusTensTasti ) );
	
	
	(* macchina stati ulsanti tensione + e - *)
	if(not Vb30_C1_InCucitura)then
	
		case ( mc_stati_PiuMenoTensione ) of
		
			1:
		
				vret := ExecPlcFun( PLC_AN_OUT_NUM , AO97_ValoreTensioneTesta1 , TO_INT ( 2500 ) );  //5V con alimentatore a 48V
				ColpoForteTensione :=FALSE;
				AppON_TensioneTesta1 := TRUE ;
				mc_stati_PiuMenoTensione :=5;
			5:
		 		if ( TimIniTensioneTesta1.q and not Vb30_C1_InCucitura )then
		 		
		 			vret := ExecPlcFun( PLC_AN_OUT_NUM , AO97_ValoreTensioneTesta1 , TO_INT( C1_Udf_ValTensione /20  ) );	//con alimentatore 48V
		 			mc_stati_PiuMenoTensione :=10;
				end_if;
			10:
				if ( TimeOutTensioneTesta1.q or not i21_Emg )then
				
		    		vret := ExecPlcFun( PLC_AN_OUT_NUM , AO97_ValoreTensioneTesta1 , 0 );
					AppON_TensioneTesta1 := FALSE ;
					mc_stati_PiuMenoTensione := 0; 	
				else
				
					vret := ExecPlcFun( PLC_AN_OUT_NUM , AO97_ValoreTensioneTesta1 , TO_INT( C1_Udf_ValTensione /20  ) );
				end_if;
				
			else
				mc_stati_PiuMenoTensione := 0; 
				
			end_case;
	else
		mc_stati_PiuMenoTensione :=0;
	end_if;
	
	if (TimeOutTensioneTesta1.q or not i21_Emg )then
	
	    vret := ExecPlcFun( PLC_AN_OUT_NUM , AO97_ValoreTensioneTesta1 , 0 );
	end_if;
	
	
	(****** tensione testa 1 in automatico ******)
	
	VbTest := ColpoForteTensione;
	
	if ( VbChn1AutoRun and C1_AssiAzzerati and not Vb4080_TestFcZeroC1 )then
		(* con il piedino alto blocco la tensione *)
			if ( o17_C1_Piedino and not C1_CmdHoldRelease )then
			
	    		vret := ExecPlcFun( PLC_AN_OUT_NUM , AO97_ValoreTensioneTesta1 , 2500 );  //5V  con alimentatore 48V
	    	
			end_if;
		(* colpo forte per chiusura, avviene all'inizio di una cucitura oppure se chiamato da "ColpoForteTensione"  *)	
			Rise_Inizio_Cucitura ( in:= not o17_C1_Piedino and not C1_AsseAgoFermo and not Vb2_C1_Apritensione );
			if(Rise_Inizio_Cucitura.q or ColpoForteTensione ) then
			
			 	vret := ExecPlcFun( PLC_AN_OUT_NUM , AO97_ValoreTensioneTesta1 , TO_INT ( 2500 ) );  //5V   con alimentatore 48V 
			  	ColpoForteTensione:= TRUE;
			end_if;
		(* finito colpo forte vado a valore impostato su udf salvo che ci sia un codice *)	
			Tim_Inizio_Cucitura( in := ColpoForteTensione , pt := 200 );
			if(Tim_Inizio_Cucitura.q) then
				TensioneT1Fix3 := C1_Udf_ValTensione*100;
				
				vret := ExecPlcFun( PLC_AN_OUT_NUM , AO97_ValoreTensioneTesta1 , TO_INT( TensioneT1Fix3 / 2000 ) ); //con alimentatore 48V			
				ColpoForteTensione := FALSE;
			end_if;
			
		(* apro tensione durante rasafilo sull'angolo di inizio apertura *)
	
			Rise_Camma_Apritensione ( in:= not o17_C1_Piedino and not C1_AsseAgoFermo and Vb2_C1_Apritensione );
			if(Rise_Camma_Apritensione.q) then
				
	    		vret := ExecPlcFun( PLC_AN_OUT_NUM , AO97_ValoreTensioneTesta1 , 0 );
	    	
			end_if;
		(* chiudo tensione durante rasafilo sull'angolo di fine apertura *)
			Fall_Camma_Apritensione ( in:=Vb2_C1_Apritensione );
			if(Fall_Camma_Apritensione.q) then
				Chiudi_tensione_dopo_rasafilo := TRUE;
			
				vret := ExecPlcFun( PLC_AN_OUT_NUM , AO97_ValoreTensioneTesta1 , TO_INT ( 2500 ) );  //5V  con alimentatore 48V
			
			end_if;
		(* alla fine della camma, sopra l'ho chiusa, qui la riapro definitivamente *)	
			Tim_Fall_Camma_Apritensione ( in := Chiudi_tensione_dopo_rasafilo , pt := 400 );
			if(Tim_Fall_Camma_Apritensione.q) then
			
				vret := ExecPlcFun( PLC_AN_OUT_NUM , AO97_ValoreTensioneTesta1 , 0 );
			
					Chiudi_tensione_dopo_rasafilo := FALSE;
			end_if;
			
		(* stop cucitura  la tensione è aperta *)
			if ( not o17_C1_Piedino and C1_AsseAgoFermo and not Vb2_C1_Apritensione and not  ColpoForteTensione  and not Chiudi_tensione_dopo_rasafilo)then
	    		vret := ExecPlcFun( PLC_AN_OUT_NUM , AO97_ValoreTensioneTesta1 , 0 );
	    	
	    	end_if;
	
		(* ripresa cucitura dopo stop cucitura*)
		RiseC1_CmdReleaseHMI ( in:=C1_CmdReleaseHMI );
		if ( RiseC1_CmdReleaseHMI.q )then
			ColpoForteTensione := TRUE;	//lancio colpo forte e poi vado a valore impostato
		end_if;
	
	end_if;
	
	(* esco dall'automatico testa 1  la tensione è aperta *)
	
	FallVbChn1AutoRun(  in :=  VbChn1AutoRun );
	RitOffTensSimT1( in := ( o17_C1_Piedino and C1_CmdHoldRelease ) , pt := 1000 );
	RitOffTensContaSpola( in := ( Vn2CodiceAllarmeXHmi = 1 and not Vb4_C1_InCucitura ) , pt := 1000 );
	if ( FallVbChn1AutoRun.q or RitOffTensSimT1.q or RitOffTensContaSpola.q )then
		vret := ExecPlcFun( PLC_AN_OUT_NUM , AO97_ValoreTensioneTesta1 , 0 );
	
	
	end_if;


	(***** cambio tensione in base hai valori nel programma cucitura *****)

(* Calcolo tensione testa 1 *)
(* La tensione impostata con la VDC2 a 0 è quella del' HMI	           *)
(* Nell'header del profilo si imposta il valore di default             *)
(* Durante la cucitura si puo' cambiare la tensione scrivendo la VCD2  *)

 (* verifico se sono in cucitura *)
	if ( C1_VbRunCuci and not Vb4047_C1_AxAgoFermo )then
		Vb4_C1_InCucitura := TRUE ;
	else;
		Vb4_C1_InCucitura := FALSE ;
	end_if;

		RiseC1_VbRunCuci(  in :=  C1_VbRunCuci );
		FallC1_VbRunCuci(  in :=  C1_VbRunCuci );

	(* se sto cucendo controllo se c'è un codice tesione nel programma*)
	if ( Vb4_C1_InCucitura )then

		VcdIdxT1 := (C1_CHN*1000)+VCD_TENSIONE_IDX;
		vret := ExecPlcFun( PLC_VCD_TO_VD, VD_TMP_CALC_T1_IDX, VcdIdxT1 );
		VdTmpCalcT1 := VdTmpCalcT1 * 1000.0 ;
		C1_TensioneInProfilo := TO_DINT( VdTmpCalcT1 );
	end_if;
	(* se c'è un codice tesione nel programma imposto uscita analogia*)
	if ( C1_TensioneInProfilo > 0 and not C1_VbEnableCamme) then		(*DA 09082023*)
		TensioneT1Fix3 := C1_TensioneInProfilo *100;
	
		vret := ExecPlcFun( PLC_AN_OUT_NUM , AO97_ValoreTensioneTesta1 , TO_INT( TensioneT1Fix3 / 2000 ) ); //con alimentatore 48V
	end_if;
	(* se c'è un codice tesione = 0 riporto la tensione al valore di udf *)
	Rise_FineCodiceTensione (in := 	C1_TensioneInProfilo =0);
	if(	Rise_FineCodiceTensione.q and not Vb2_C1_Apritensione) then		(*DA 09082023*)
		ColpoForteTensione := TRUE;
	end_if;
		
		
		
		
		
		
		
	(* azzero tutto quando ho finito la cucitura *)

	if ( FallC1_VbRunCuci.q )then
		C1_TensioneInProfilo := 0 ;
		VdTmpCalcT1 := 0.0 ;
		vret := ExecPlcFun( PLC_VD_TO_VCD, VcdIdxT1, VD_TMP_CALC_T1_IDX );	(*Vcd2_Tensione := 0,0 ;*)
		VcdIdxT1 := 0 ;
	end_if;






	(* Pulsante Test uscita magnete tensione *)
		if ( Vb4208_AppMagneteTensione )then
		
        	vret := ExecPlcFun( PLC_AN_OUT_NUM , AO97_ValoreTensioneTesta1 , TO_INT ( 2500 ) );   //5V con alimentatore 48V
    	
		end_if;
	(* timeout test uscita magnete tensione  *)
	TimTestTensioneTesta1( in := ( Vb4208_AppMagneteTensione ), pt := 2000 );

	if ( TimTestTensioneTesta1.q or  (not i21_Emg and not EnbManuale) or Fall_Vb4208_AppMagneteTensione.q)then
	
        vret := ExecPlcFun( PLC_AN_OUT_NUM , AO97_ValoreTensioneTesta1 , 0 );
		Vb4208_AppMagneteTensione := FALSE ;	
	end_if;
	(**)
	Fall_Vb4208_AppMagneteTensione (in:= Vb4208_AppMagneteTensione and Vn3804_PageID = 1005);

(************************************************************************)
(**************************   magnete sopra  ****************************)
(************************************************************************)

(* Pulsante Test uscita magnete sopra piegatore *)
if ( Vb4210_AppMagneteSopraPiegatore )then
     vret := ExecPlcFun( PLC_AN_OUT_NUM , AO100_ValoreElettrocSopra , TO_INT ( 5000 ) );	//24V con alimentatore 48V
end_if;
(* timeout uscita magnete sopra piegatore  *)
(*dopo 1 sec se ho uscita sopra a 24V la porto a 24V, dopo 5 sec porto sempre uscita a 0V,*)

vret := ExecPlcFun( PLC_AN_OUT_READ , AO100_ValoreElettrocSopra , 163); 	//leggo la tensione di uscita
TimTestMagneteSopraPiegatore( in := ( Vb4210_AppMagneteSopraPiegatore ) or Vn163_Read_anaout100 > 1000, pt := 5000 );	//time out che porta uscita a 0V
TimRiduzioneMagneteSopraPiegatore( in := Vn163_Read_anaout100 > 5000, pt := 1000 );	//timeout che abbassa l'uscita a 24V

if ( TimTestMagneteSopraPiegatore.q or (not i21_Emg and not EnbManuale) or Fall_Vb4210_AppMagneteSopraPiegatore.q)then
	vret := ExecPlcFun( PLC_AN_OUT_NUM , AO100_ValoreElettrocSopra , 0 );
	Vb4210_AppMagneteSopraPiegatore := FALSE ;	
end_if;


if(TimRiduzioneMagneteSopraPiegatore.q) then
	vret := ExecPlcFun( PLC_AN_OUT_NUM , AO100_ValoreElettrocSopra , 5000 );	//set 24V
end_if;
(**)
Fall_Vb4210_AppMagneteSopraPiegatore (in:= Vb4210_AppMagneteSopraPiegatore and Vn3804_PageID = 1005);


(************************************************************************)
(**************************   magnete sotto  ****************************)
(************************************************************************)
if ( Vb4070_AppTensOnSotto )then
    vret := ExecPlcFun( PLC_AN_OUT_NUM , AO99_ValoreElettrocSotto , TO_INT( C1_Udf_ValEletSotto / 1000 )  );
end_if;

(* timeout magnete sotto  *)
(*dopo 3 sec se ho uscita maggiore di 24V la porto a 24V, dopo 60 sec porto sempre uscita a 0V,*)

vret := ExecPlcFun( PLC_AN_OUT_READ , AO99_ValoreElettrocSotto , 162); 	//leggo la tensione di uscita	

TimeOutElettrocSotto( in := ( Vb4070_AppTensOnSotto or Vn162_Read_anaout99 >1000 ), pt := 60000 ); //time out che porta uscita a 0V
TimeRiduzioneOutElettrocSotto( in := Vn162_Read_anaout99 > 5000, pt := 3000 );	//timeout che abbassa l'uscita a 24V

if ( TimeOutElettrocSotto.q or (not i21_Emg and not EnbManuale) )then
    vret := ExecPlcFun( PLC_AN_OUT_NUM , AO99_ValoreElettrocSotto , 0 );
	Vb4070_AppTensOnSotto := FALSE ;	
end_if;
if(TimeRiduzioneOutElettrocSotto.q) then
	vret := ExecPlcFun( PLC_AN_OUT_NUM , AO99_ValoreElettrocSotto , 5000 );	//set 24V
end_if;


(* Pulsante Test uscita magnete sotto piegatore *)
if ( Vb4211_AppMagneteSottoPiegatore )then
     vret := ExecPlcFun( PLC_AN_OUT_NUM , AO99_ValoreElettrocSotto , TO_INT ( 5000 ) );  //con alimentatore 48V
   
end_if;
(* timeout test uscita magnete sotto piegatore  *)
TimTestMagneteSottoPiegatore( in := ( Vb4211_AppMagneteSottoPiegatore ), pt := 2000 );

if ( TimTestMagneteSottoPiegatore.q or (not i21_Emg and not EnbManuale) or Fall_Vb4211_AppMagneteSottoPiegatore.q )then
	vret := ExecPlcFun( PLC_AN_OUT_NUM , AO99_ValoreElettrocSotto , 0 );
	Vb4211_AppMagneteSottoPiegatore := FALSE ;	
	
end_if;
Fall_Vb4211_AppMagneteSottoPiegatore (in:= Vb4211_AppMagneteSottoPiegatore and Vn3804_PageID = 1005); 




(************************************************************************)
(**************************   magnete blocca filo ***********************)
(************************************************************************)

(* cucitrice 1 *)
RiseBloccaFilo_C1 (in:= Vb13_C1_BloccoFiloINI or Vb14_C1_BloccoFiloEND );
FallBloccaFilo_C1 (in:= Vb13_C1_BloccoFiloINI or Vb14_C1_BloccoFiloEND );
if ( RiseBloccaFilo_C1.q )then
	o31_C1_bloccaFiloMagente := TRUE;
end_if;
if ( FallBloccaFilo_C1.q )then
	o31_C1_bloccaFiloMagente := FALSE;
		
end_if;
	
	
	
	

(* cucitrice 2 *)

RiseBloccaFilo_C2 (in:= Vb15_C2_BloccoFiloINI or Vb16_C2_BloccoFiloEND );
FallBloccaFilo_C2 (in:= Vb15_C2_BloccoFiloINI or Vb16_C2_BloccoFiloEND );

if ( RiseBloccaFilo_C2.q )then
		o63_C2_bloccaFiloMagente := TRUE ;
end_if;	
if ( FallBloccaFilo_C2.q )then	
		o63_C2_bloccaFiloMagente := FALSE ;
end_if;
]]>
					</sourceCode>
				</program>
				<program name="OutAnalogicheT2" version="1.0.0" creationDate="0" lastModifiedDate="1715671535" excludeFromBuild="FALSE">
					<vars>
						<localVars>
							<var name="AppON_TensioneTesta2" type="BOOL"/>
							<var name="TimIniTensioneTesta2" type="Ton"/>
							<var name="TimeOutTensioneTesta2" type="Ton"/>
							<var name="RiseVb4063_AppTensAumentaTesta2" type="RiseEdge"/>
							<var name="RiseVb4064_AppTensDiminuisceTesta2" type="RiseEdge"/>
							<var name="TimeOutElettrocSotto" type="Ton"/>
							<var name="FallVbChn2AutoRun" type="FallEdge"/>
							<var name="RiseC2_CmdReleaseHMI" type="RiseEdge"/>
							<var name="TimTesta2Release" type="Ton"/>
							<var name="AppON_TensioneTesta2Release" type="BOOL"/>
							<var name="VcdIdxT2" type="INT"/>
							<var name="RitOffTensSimT2" type="Ton"/>
							<var name="RiseC2_VbRunCuci" type="RiseEdge"/>
							<var name="FallC2_VbRunCuci" type="FallEdge"/>
							<var name="TensioneT2Fix3" type="DINT"/>
							<var name="ColpoForteTensione" type="BOOL"/>
							<var name="Rise_Inizio_Cucitura" type="RiseEdge"/>
							<var name="Tim_Inizio_Cucitura" type="Ton"/>
							<var name="Rise_Camma_Apritensione" type="RiseEdge"/>
							<var name="Tim_Fall_Camma_Apritensione" type="Ton"/>
							<var name="RitOffTensContaSpolaT2" type="Ton"/>
							<var name="Fall_Camma_Apritensione" type="FallEdge"/>
							<var name="Rise_FineCodiceTensione" type="RiseEdge"/>
							<var name="TimTestTensioneTesta2" type="Ton"/>
							<var name="Fall_Vb4209_AppMagneteTensioneT2" type="FallEdge"/>
							<var name="Chiudi_tensione_dopo_rasafilo" type="BOOL"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[(* ========================================================================== 
(* SIPRO - Siax M															  	
(*                                                                            
(* COMPANY:     JAM INTERNATIONAL                                             
(*                                                                            
(* NAME: OutAnalogicheT2                                                          
(*
(* TASK MAIN	 
(*
(* DESCRIPTION: Gestione tensione elettronica testa 2
(*
(*                                                                             
(* NOTE:                                NAME:           VER:    DATE:         
(* -------------------------------------------------------------------------  
(* Prima stesura                        Jam             1.0     29/04/2021    
(* Ultima modifica                                                            
(* ========================================================================== *)

(* hmi impostazione manuale *)

	RiseVb4063_AppTensAumentaTesta2(  in :=  Vb4063_AppTensAumentaTesta2 );
	RiseVb4064_AppTensDiminuisceTesta2(  in :=  Vb4064_AppTensDiminuisceTesta2 );
	
(* hmi attivo magnete dopo impostazione impostazione manuale *)

if ( RiseVb4063_AppTensAumentaTesta2.q or RiseVb4064_AppTensDiminuisceTesta2.q or (C2_CmdPiedinoGiu and not Vb31_C2_InCucitura and not i2_C1_Pedana))then

	Vb4063_AppTensAumentaTesta2:= FALSE;
	Vb4064_AppTensDiminuisceTesta2 := FALSE;
	if(mc_stati_PiuMenoTensioneT2 = 0)then
		mc_stati_PiuMenoTensioneT2 :=1;
	end_if;
	
	

end_if;



(* timer colpo tensione a 5V *)
TimIniTensioneTesta2( in := AppON_TensioneTesta2 , pt :=  TO_UDINT(Vq3094_TimeColpoTensione ) );
(* timeout tensione manuale dopo colpo a 5 V*)
TimeOutTensioneTesta2( in := ( AppON_TensioneTesta2 and not Vb4063_AppTensAumentaTesta2 and not Vb4064_AppTensDiminuisceTesta2 and not Vb31_C2_InCucitura), pt := TO_UDINT(Vq3095_TimeChiusTensTasti ) );
	
	
	(* macchina stati ulsanti tensione + e - *)
	if(not Vb31_C2_InCucitura)then
	
		case ( mc_stati_PiuMenoTensioneT2 ) of
		
			1:
			
				vret := ExecPlcFun( PLC_AN_OUT_NUM , AO98_ValoreTensioneTesta2 , TO_INT ( 2500 ) );  //5V con alimentatore a 48V
				ColpoForteTensione :=FALSE;
				AppON_TensioneTesta2 := TRUE ;
				mc_stati_PiuMenoTensioneT2 :=5;
			5:
		 		if ( TimIniTensioneTesta2.q and not Vb31_C2_InCucitura )then
		 	
		 			vret := ExecPlcFun( PLC_AN_OUT_NUM , AO98_ValoreTensioneTesta2 , TO_INT( C2_Udf_ValTensione /20  ) );	//con alimentatore 48V
		 			mc_stati_PiuMenoTensioneT2 :=10;
				end_if;
			10:
				if ( TimeOutTensioneTesta2.q or not i21_Emg )then
				
		    		vret := ExecPlcFun( PLC_AN_OUT_NUM , AO98_ValoreTensioneTesta2 , 0 );
					AppON_TensioneTesta2 := FALSE ;
					mc_stati_PiuMenoTensioneT2 := 0; 	
				else
			
					vret := ExecPlcFun( PLC_AN_OUT_NUM , AO98_ValoreTensioneTesta2 , TO_INT( C2_Udf_ValTensione /20  ) );
				end_if;
				
			else
				mc_stati_PiuMenoTensioneT2 := 0; 
				
			end_case;
	else
		mc_stati_PiuMenoTensioneT2 :=0;
	end_if;
	
	if (TimeOutTensioneTesta2.q or not i21_Emg )then

	    vret := ExecPlcFun( PLC_AN_OUT_NUM , AO98_ValoreTensioneTesta2 , 0 );
	end_if;
	
	
	(****** tensione testa 2 in automatico ******)
	
	VbTest := ColpoForteTensione;
	
	if ( VbChn2AutoRun and C2_AssiAzzerati and not Vb4085_TestFcZeroC2 )then
		(* con il piedino alto blocco la tensione *)
			if ( o49_C2_Piedino and not C2_CmdHoldRelease )then

	    		vret := ExecPlcFun( PLC_AN_OUT_NUM , AO98_ValoreTensioneTesta2 , 2500 );  //5V  con alimentatore 48V
	    	
			end_if;
		(* colpo forte per chiusura, avviene all'inizio di una cucitura oppure se chiamato da "ColpoForteTensione"  *)	
			Rise_Inizio_Cucitura ( in:= not o49_C2_Piedino and not C2_AsseAgoFermo and not Vb3_C2_Apritensione );
			if(Rise_Inizio_Cucitura.q or ColpoForteTensione ) then

			 	vret := ExecPlcFun( PLC_AN_OUT_NUM , AO98_ValoreTensioneTesta2 , TO_INT ( 2500 ) );  //5V   con alimentatore 48V 
			  	ColpoForteTensione:= TRUE;
			end_if;
		(* finito colpo forte vado a valore impostato su udf salvo che ci sia un codice *)	
			Tim_Inizio_Cucitura( in := ColpoForteTensione , pt := 200 );
			if(Tim_Inizio_Cucitura.q) then
				TensioneT2Fix3 := C2_Udf_ValTensione*100;

				vret := ExecPlcFun( PLC_AN_OUT_NUM , AO98_ValoreTensioneTesta2 , TO_INT( TensioneT2Fix3 / 2000 ) ); //con alimentatore 48V			
				ColpoForteTensione := FALSE;
			end_if;
			
		(* apro tensione durante rasafilo sull'angolo di inizio apertura *)
	
			Rise_Camma_Apritensione ( in:= not o49_C2_Piedino and not C2_AsseAgoFermo and Vb3_C2_Apritensione );
			if(Rise_Camma_Apritensione.q) then

	    		vret := ExecPlcFun( PLC_AN_OUT_NUM , AO98_ValoreTensioneTesta2 , 0 );
	    	
			end_if;
		(* chiudo tensione durante rasafilo sull'angolo di fine apertura *)
			Fall_Camma_Apritensione ( in:=Vb3_C2_Apritensione );
			if(Fall_Camma_Apritensione.q) then
				Chiudi_tensione_dopo_rasafilo := TRUE;
			
				vret := ExecPlcFun( PLC_AN_OUT_NUM , AO98_ValoreTensioneTesta2 , TO_INT ( 2500 ) );  //5V  con alimentatore 48V
			
			end_if;
		(* alla fine della camma, sopra l'ho chiusa, qui la riapro definitivamente *)	
			Tim_Fall_Camma_Apritensione ( in := Chiudi_tensione_dopo_rasafilo , pt := 400 );
			if(Tim_Fall_Camma_Apritensione.q) then
		
				vret := ExecPlcFun( PLC_AN_OUT_NUM , AO98_ValoreTensioneTesta2 , 0 );
			
					Chiudi_tensione_dopo_rasafilo := FALSE;
			end_if;
			
		(* stop cucitura  la tensione è aperta *)
			if ( not o49_C2_Piedino and C2_AsseAgoFermo and not Vb3_C2_Apritensione and not  ColpoForteTensione  and not Chiudi_tensione_dopo_rasafilo)then
	    		vret := ExecPlcFun( PLC_AN_OUT_NUM , AO98_ValoreTensioneTesta2 , 0 );

	    	end_if;
	
		(* ripresa cucitura dopo stop cucitura*)
		RiseC2_CmdReleaseHMI ( in:=C2_CmdReleaseHMI );
		if ( RiseC2_CmdReleaseHMI.q )then
			ColpoForteTensione := TRUE;	//lancio colpo forte e poi vado a valore impostato
		end_if;
	
	end_if;
	
	(* esco dall'automatico testa 2  la tensione è aperta *)
	
	FallVbChn2AutoRun(  in :=  VbChn2AutoRun );
	RitOffTensSimT2( in := ( o49_C2_Piedino and C2_CmdHoldRelease ) , pt := 1000 );
	RitOffTensContaSpolaT2( in := ( Vn2CodiceAllarmeXHmi = 1 and not Vb5_C2_InCucitura ) , pt := 1000 );
	if ( FallVbChn2AutoRun.q or RitOffTensSimT2.q or RitOffTensContaSpolaT2.q )then
		vret := ExecPlcFun( PLC_AN_OUT_NUM , AO98_ValoreTensioneTesta2 , 0 );
		

	end_if;


	(***** cambio tensione in base hai valori nel programma cucitura *****)

(* Calcolo tensione testa 2 *)
(* La tensione impostata con la VDC2 a 0 è quella del' HMI	           *)
(* Nell'header del profilo si imposta il valore di default             *)
(* Durante la cucitura si puo' cambiare la tensione scrivendo la VCD2  *)

 (* verifico se sono in cucitura *)
	if ( C2_VbRunCuci and not Vb4052_C2_AxAgoFermo )then
		Vb5_C2_InCucitura := TRUE ;
	else;
		Vb5_C2_InCucitura := FALSE ;
	end_if;

		RiseC2_VbRunCuci(  in :=  C2_VbRunCuci );
		FallC2_VbRunCuci(  in :=  C2_VbRunCuci );

	(* se sto cucendo controllo se c'è un codice tesione nel programma*)
	if ( Vb5_C2_InCucitura )then

		VcdIdxT2 := (C2_CHN*1000)+VCD_TENSIONE_IDX;
		vret := ExecPlcFun( PLC_VCD_TO_VD, VD_TMP_CALC_T2_IDX, VcdIdxT2 );
		VdTmpCalcT2 := VdTmpCalcT2 * 1000.0 ;
		C2_TensioneInProfilo := TO_DINT( VdTmpCalcT2 );
	end_if;
	(* se c'è un codice tesione nel programma imposto uscita analogia*)
	if ( C2_TensioneInProfilo > 0 and not C2_VbEnableCamme) then		(*DA 09082023*)
		TensioneT2Fix3 := C2_TensioneInProfilo *100;
	
		vret := ExecPlcFun( PLC_AN_OUT_NUM , AO98_ValoreTensioneTesta2 , TO_INT( TensioneT2Fix3 / 2000 ) ); //con alimentatore 48V
	end_if;
	(* se c'è un codice tesione = 0 riporto la tensione al valore di udf *)
	Rise_FineCodiceTensione (in := 	C2_TensioneInProfilo =0);
	if(	Rise_FineCodiceTensione.q and not Vb3_C2_Apritensione) then		(*DA 09082023*)
		ColpoForteTensione := TRUE;
	end_if;
		
		
		
		
		
		
		
	(* azzero tutto quando ho finito la cucitura *)

	if ( FallC2_VbRunCuci.q )then
		C2_TensioneInProfilo := 0 ;
		VdTmpCalcT2 := 0.0 ;
		vret := ExecPlcFun( PLC_VD_TO_VCD, VcdIdxT2, VD_TMP_CALC_T2_IDX );	(*Vcd2_Tensione := 0,0 ;*)
		VcdIdxT2 := 0 ;
	end_if;






	(* Pulsante Test uscita magnete tensione *)
		if ( Vb4209_AppMagneteTensioneT2 )then

        	vret := ExecPlcFun( PLC_AN_OUT_NUM , AO98_ValoreTensioneTesta2 , TO_INT ( 2500 ) );   //5V con alimentatore 48V
    	
		end_if;
	(* timeout test uscita magnete tensione  *)
	TimTestTensioneTesta2( in := ( Vb4209_AppMagneteTensioneT2 ), pt := 2000 );

	if ( TimTestTensioneTesta2.q or  (not i21_Emg and not EnbManuale )or Fall_Vb4209_AppMagneteTensioneT2.q)then
        vret := ExecPlcFun( PLC_AN_OUT_NUM , AO98_ValoreTensioneTesta2 , 0 );
       
		Vb4209_AppMagneteTensioneT2 := FALSE ;	
	end_if;
	(**)
	Fall_Vb4209_AppMagneteTensioneT2 (in:= Vb4209_AppMagneteTensioneT2 and Vn3804_PageID = 1005);

]]>
					</sourceCode>
				</program>
				<program name="OpCodeT1" version="1.0.0" creationDate="0" lastModifiedDate="1702996654" excludeFromBuild="FALSE">
					<vars>
						<localVars>
							<var name="RiseC1_VbRunCuci" type="RiseEdge"/>
							<var name="FallC1_VbRunCuci" type="FallEdge"/>
							<var name="VcdIdxOP" type="INT"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[(* ========================================================================== 
(* SIPRO - Siax M															  	
(*                                                                            
(* COMPANY:     JAM INTERNATIONAL                                             
(*                                                                            
(* NAME: OpCodeT1                                                          
(*
(* TASK MAIN	 
(*
(* DESCRIPTION: codici OP1-10 testa 1
(*
(*                                                                             
(* NOTE:                                NAME:           VER:    DATE:         
(* -------------------------------------------------------------------------  
(* Prima stesura                        Jam             1.0     29/04/2021    
(* Ultima modifica                                                            
(* ========================================================================== *)

	(***** Impostazioni valide per tutti gli OP *****)

 (* verifico se sono in cucitura *)
		RiseC1_VbRunCuci(  in :=  C1_VbRunCuci );
		FallC1_VbRunCuci(  in :=  C1_VbRunCuci );



 (* a inizio e fine cucitura azzero tutte le VCD 11-20 *)

	if ( RiseC1_VbRunCuci.q or FallC1_VbRunCuci.q )then
		(* azzero OP1*)
//		VcdIdxOP := (C1_CHN*1000)+VCD11_OP1_IDX;
//		VdTmpOP_T1 := 0.0 ;
//		vret := ExecPlcFun( PLC_VD_TO_VCD, VcdIdxOP, VD_TMP_OP_T1_IDX );
		(* azzero OP2*)
		VcdIdxOP := (C1_CHN*1000)+VCD12_OP2_IDX;
		VdTmpOP_T1 := 0.0 ;
		vret := ExecPlcFun( PLC_VD_TO_VCD, VcdIdxOP, VD_TMP_OP_T1_IDX );
		(* azzero OP3*)
		VcdIdxOP := (C1_CHN*1000)+VCD13_OP3_IDX;
		VdTmpOP_T1 := 0.0 ;
		vret := ExecPlcFun( PLC_VD_TO_VCD, VcdIdxOP, VD_TMP_OP_T1_IDX );
		(* azzero OP4*)
	//	VcdIdxOP := (C1_CHN*1000)+VCD14_OP4_IDX;
	//	VdTmpOP_T1 := 0.0 ;
	//	vret := ExecPlcFun( PLC_VD_TO_VCD, VcdIdxOP, VD_TMP_OP_T1_IDX );
		(* azzero OP5*)
	//	VcdIdxOP := (C1_CHN*1000)+VCD15_OP5_IDX;
	//	VdTmpOP_T1 := 0.0 ;
	//	vret := ExecPlcFun( PLC_VD_TO_VCD, VcdIdxOP, VD_TMP_OP_T1_IDX );
		(* azzero OP6*)
	//	VcdIdxOP := (C1_CHN*1000)+VCD16_OP6_IDX;
	//	VdTmpOP_T1 := 0.0 ;
	//	vret := ExecPlcFun( PLC_VD_TO_VCD, VcdIdxOP, VD_TMP_OP_T1_IDX );
		(* azzero OP7*)
	//	VcdIdxOP := (C1_CHN*1000)+VCD17_OP7_IDX;
	//	VdTmpOP_T1 := 0.0 ;
	//	vret := ExecPlcFun( PLC_VD_TO_VCD, VcdIdxOP, VD_TMP_OP_T1_IDX );
		(* azzero OP8*)
	//	VcdIdxOP := (C1_CHN*1000)+VCD18_OP8_IDX;
	//	VdTmpOP_T1 := 0.0 ;
	//	vret := ExecPlcFun( PLC_VD_TO_VCD, VcdIdxOP, VD_TMP_OP_T1_IDX );
		(* azzero OP9*)
	//	VcdIdxOP := (C1_CHN*1000)+VCD19_OP9_IDX;
	//	VdTmpOP_T1 := 0.0 ;
	//	vret := ExecPlcFun( PLC_VD_TO_VCD, VcdIdxOP, VD_TMP_OP_T1_IDX );
		(* azzero OP10*)
	//	VcdIdxOP := (C1_CHN*1000)+VCD20_OP10_IDX;
	//	VdTmpOP_T1 := 0.0 ;
	//	vret := ExecPlcFun( PLC_VD_TO_VCD, VcdIdxOP, VD_TMP_OP_T1_IDX );
	end_if;


(* OPT1 --> OFF *)

	if ( Vb36_Clear_OPT1 )then
		(* azzero OP1*)
		VdTmpOP_T1 :=0.0;
		VcdIdxOP := (C1_CHN*1000)+VCD11_OP1_IDX;
	
		vret := ExecPlcFun( PLC_VD_TO_VCD, VcdIdxOP, VD_TMP_OP_T1_IDX );
		Vb36_Clear_OPT1:= FALSE;
		Vb4352_AppAut_o20_C1_Retrattile_AC := FALSE;	
		
	end_if;
	
	
(* OPT2 --> OFF *)		
	if ( Vb37_Clear_OPT2 )then
		(* azzero OP2*)
		VdTmpOP_T1 :=0.0;
		VcdIdxOP := (C1_CHN*1000)+VCD12_OP2_IDX;
	
		vret := ExecPlcFun( PLC_VD_TO_VCD, VcdIdxOP, VD_TMP_OP_T1_IDX );
		Vb37_Clear_OPT2 :=FALSE;
		Vb4359_AppAut_o27_C1_Ranocchia_retrat := FALSE;
	end_if;
	
(* OPT3 --> OFF *)		
	if ( Vb38_Clear_OPT3 )then
		(* azzero OP3*)
		VdTmpOP_T1 :=0.0;
		VcdIdxOP := (C1_CHN*1000)+VCD13_OP3_IDX;
	
		vret := ExecPlcFun( PLC_VD_TO_VCD, VcdIdxOP, VD_TMP_OP_T1_IDX );
		Vb38_Clear_OPT3 :=FALSE;
		Vb4358_AppAut_o26_C1_Scalino_Piedino := FALSE;
	end_if;	









	(***** codice OP1  *****)
	if (  C1_VbRunCuci or C1_CmdHoldRelease)then
		VcdIdxOP := (C1_CHN*1000)+VCD11_OP1_IDX;
		vret := ExecPlcFun( PLC_VCD_TO_VD, VD_TMP_OP_T1_IDX, VcdIdxOP );
	
		
		if ( VdTmpOP_T1 = 1.0 )then
			Vb4352_AppAut_o20_C1_Retrattile_AC := TRUE;
		else
				
			Vb4352_AppAut_o20_C1_Retrattile_AC := FALSE;		
		
		end_if;
		
	end_if;

	(***** codice OP2  *****)
	if ( ( C1_VbRunCuci or C1_CmdHoldRelease ) or Vb37_Clear_OPT2)then
		VcdIdxOP := (C1_CHN*1000)+VCD12_OP2_IDX;
		vret := ExecPlcFun( PLC_VCD_TO_VD, VD_TMP_OP_T1_IDX, VcdIdxOP );

		if ( VdTmpOP_T1 = 1.0 and not Vb37_Clear_OPT2)then
			Vb4359_AppAut_o27_C1_Ranocchia_retrat := TRUE;
 
		else;	
			Vb4359_AppAut_o27_C1_Ranocchia_retrat := FALSE;
		end_if;
	end_if;
	(***** codice OP3  *****)
	if (  C1_VbRunCuci or C1_CmdHoldRelease )then
		VcdIdxOP := (C1_CHN*1000)+VCD13_OP3_IDX;
		vret := ExecPlcFun( PLC_VCD_TO_VD, VD_TMP_OP_T1_IDX, VcdIdxOP );

		if ( VdTmpOP_T1 = 1.0 )then
			Vb4358_AppAut_o26_C1_Scalino_Piedino := TRUE;
		else;	
			Vb4358_AppAut_o26_C1_Scalino_Piedino := FALSE;
		end_if;
		
	end_if;
]]>
					</sourceCode>
				</program>
				<program name="OpCodeT2" version="1.0.0" creationDate="0" lastModifiedDate="1702997408" excludeFromBuild="FALSE">
					<vars>
						<localVars>
							<var name="RiseC2_VbRunCuci" type="RiseEdge"/>
							<var name="FallC2_VbRunCuci" type="FallEdge"/>
							<var name="VcdIdxOP" type="INT"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[(* ========================================================================== 
(* SIPRO - Siax M															  	
(*                                                                            
(* COMPANY:     JAM INTERNATIONAL                                             
(*                                                                            
(* NAME: OpCodeT2                                                          
(*
(* TASK MAIN	 
(*
(* DESCRIPTION: codici OP1-10 testa 2
(*
(*                                                                             
(* NOTE:                                NAME:           VER:    DATE:         
(* -------------------------------------------------------------------------  
(* Prima stesura                        Jam             1.0     29/04/2021    
(* Ultima modifica                                                            
(* ========================================================================== *)

	(***** Impostazioni valide per tutti gli OP *****)

 (* verifico se sono in cucitura *)
  		RiseC2_VbRunCuci(  in :=  C2_VbRunCuci );
		FallC2_VbRunCuci(  in :=  C2_VbRunCuci );



 (* a inizio e fine cucitura azzero tutte le VCD 11-20 *)

	if ( RiseC2_VbRunCuci.q or FallC2_VbRunCuci.q )then
		(* azzero OP1*)
		VcdIdxOP := (C2_CHN*1000)+VCD11_OP1_IDX;
		VdTmpOP_T2 := 0.0 ;
		vret := ExecPlcFun( PLC_VD_TO_VCD, VcdIdxOP, VD_TMP_OP_T2_IDX );
		(* azzero OP2*)
		VcdIdxOP := (C2_CHN*1000)+VCD12_OP2_IDX;
		VdTmpOP_T2 := 0.0 ;
		vret := ExecPlcFun( PLC_VD_TO_VCD, VcdIdxOP, VD_TMP_OP_T2_IDX );
		(* azzero OP3*)
		VcdIdxOP := (C2_CHN*1000)+VCD13_OP3_IDX;
		VdTmpOP_T2 := 0.0 ;
		vret := ExecPlcFun( PLC_VD_TO_VCD, VcdIdxOP, VD_TMP_OP_T2_IDX );
		(* azzero OP4*)
		VcdIdxOP := (C2_CHN*1000)+VCD14_OP4_IDX;
		VdTmpOP_T2 := 0.0 ;
		vret := ExecPlcFun( PLC_VD_TO_VCD, VcdIdxOP, VD_TMP_OP_T2_IDX );
		(* azzero OP5*)
		VcdIdxOP := (C2_CHN*1000)+VCD15_OP5_IDX;
		VdTmpOP_T2 := 0.0 ;
		vret := ExecPlcFun( PLC_VD_TO_VCD, VcdIdxOP, VD_TMP_OP_T2_IDX );
		(* azzero OP6*)
		VcdIdxOP := (C2_CHN*1000)+VCD16_OP6_IDX;
		VdTmpOP_T2 := 0.0 ;
		vret := ExecPlcFun( PLC_VD_TO_VCD, VcdIdxOP, VD_TMP_OP_T2_IDX );
		(* azzero OP7*)
		VcdIdxOP := (C2_CHN*1000)+VCD17_OP7_IDX;
		VdTmpOP_T2 := 0.0 ;
		vret := ExecPlcFun( PLC_VD_TO_VCD, VcdIdxOP, VD_TMP_OP_T2_IDX );
		(* azzero OP8*)
		VcdIdxOP := (C2_CHN*1000)+VCD18_OP8_IDX;
		VdTmpOP_T2 := 0.0 ;
		vret := ExecPlcFun( PLC_VD_TO_VCD, VcdIdxOP, VD_TMP_OP_T2_IDX );
		(* azzero OP9*)
		VcdIdxOP := (C2_CHN*1000)+VCD19_OP9_IDX;
		VdTmpOP_T2 := 0.0 ;
		vret := ExecPlcFun( PLC_VD_TO_VCD, VcdIdxOP, VD_TMP_OP_T2_IDX );
		(* azzero OP10*)
		VcdIdxOP := (C2_CHN*1000)+VCD20_OP10_IDX;
		VdTmpOP_T2 := 0.0 ;
		vret := ExecPlcFun( PLC_VD_TO_VCD, VcdIdxOP, VD_TMP_OP_T2_IDX );
	end_if;




(* OPT3 --> OFF *)		
	if ( Vb41_Clear_OPT3_C2 )then
		(* azzero OP3*)
		VcdIdxOP := (C2_CHN*1000)+VCD13_OP3_IDX;
		VdTmpOP_T2 := 0.0 ;
		vret := ExecPlcFun( PLC_VD_TO_VCD, VcdIdxOP, VD_TMP_OP_T2_IDX );		
		Vb41_Clear_OPT3_C2 :=FALSE;
		Vb4390_AppAut_o58_C2_Scalino_Piedino := FALSE;
	end_if;	



	(***** codice OP1  ****
	if ( C1_VbRunCuci or C2_CmdHoldRelease )then
		VcdIdxOP := (C2_CHN*1000)+VCD11_OP1_IDX;
		vret := ExecPlcFun( PLC_VCD_TO_VD, VD_TMP_OP_IDX, VcdIdxOP );

		if ( VdTmpOP = 1.0 )then
			 := TRUE;
		else;	
			 := FALSE;
		end_if;
	end_if;*)
	
	(***** codice OP2  ****
	if ( C1_VbRunCuci or C2_CmdHoldRelease )then
		VcdIdxOP := (C2_CHN*1000)+VCD12_OP2_IDX;
		vret := ExecPlcFun( PLC_VCD_TO_VD, VD_TMP_OP_IDX, VcdIdxOP );

		if ( VdTmpOP = 1.0 )then
			 := TRUE;
		else;	
			 := FALSE;
		end_if;
	end_if;*)

	(***** codice OP3  *****)
	if ( C2_VbRunCuci or C2_CmdHoldRelease )then
		VcdIdxOP := (C2_CHN*1000)+VCD13_OP3_IDX;
		vret := ExecPlcFun( PLC_VCD_TO_VD, VD_TMP_OP_T2_IDX, VcdIdxOP );
	end_if;

		if ( VdTmpOP_T2 = 1.0 )then
			Vb4390_AppAut_o58_C2_Scalino_Piedino := TRUE;
		else;	
			Vb4390_AppAut_o58_C2_Scalino_Piedino := FALSE;
		end_if;
		

]]>
					</sourceCode>
				</program>
				<program name="TestManutenzione" version="1.0.0" creationDate="0" lastModifiedDate="1703088245" excludeFromBuild="FALSE">
					<vars>
						<localVars>
							<var name="RiseVb4080_TestFcZeroC1" type="RiseEdge"/>
							<var name="RiseVb4081_TestCaricatorePinzaC1" type="RiseEdge"/>
							<var name="RiseVb4082_TestCaricatoreLanciaC1" type="RiseEdge"/>
							<var name="RiseVb4083_TestCaricatoreC2CaricoC1" type="RiseEdge"/>
							<var name="RiseVb4084_TestCaricatoreC2ScaricoC2" type="RiseEdge"/>
							<var name="RiseVb4085_TestFcZeroC2" type="RiseEdge"/>
							<var name="RiseVb4086_SavePosizioni" type="RiseEdge"/>
							<var name="RiseVb4087_TestLiberaPinzaCaricatore" type="RiseEdge"/>
							<var name="RiseVb4078_TestHomeC1" type="RiseEdge"/>
							<var name="RiseVb4079_TestHomeC2" type="RiseEdge"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[(* ========================================================================== 
(* SIPRO - Siax M															  	
(*                                                                            
(* COMPANY:     JAM INTERNATIONAL                                             
(*                                                                            
(* NAME: TestManutenzione                                                          
(*
(* TASK MAIN	 
(*
(* DESCRIPTION: Test / Manutenzione
(*
(*                                                                             
(* NOTE:                                NAME:           VER:    DATE:         
(* -------------------------------------------------------------------------  
(* Prima stesura                        Jam             1.0     29/04/2021    
(* Ultima modifica                                                            
(* ========================================================================== *)
(* vb blocco manutenzione se le pinze non sono apposto *)
case ( Vn_ID_macchina) of
	
	882:

		if ( i5_FcPinzaCaricoAlta and i38_FcPinzaTraslAlta )then	
			Vb6_PinzeOkTestManut := TRUE ;
		else;
			Vb6_PinzeOkTestManut := FALSE ;
		end_if;
	862: (*862M*)
		if ( i5_FcPinzaCaricoAlta )then	
			Vb6_PinzeOkTestManut := TRUE ;
		else;
			Vb6_PinzeOkTestManut := FALSE ;
		end_if;
	860: (*862HM*)
		if ( i5_FcPinzaCaricoAlta )then	
			Vb6_PinzeOkTestManut := TRUE ;
		else;
			Vb6_PinzeOkTestManut := FALSE ;
		end_if;
end_case;	




(* ritorno punto di carico  cucitrice 1 *)
RiseVb4078_TestHomeC1( in := Vb4078_TestHomeC1 and not Vb4507_AppManAuto and Vb6_PinzeOkTestManut and MacchinaAzzerata );

		if ( RiseVb4078_TestHomeC1.q )then
			Vb4080_TestFcZeroC1 := TRUE ;
		end_if;



(* centraggio pinza ago cucitrice 1 *)
RiseVb4080_TestFcZeroC1( in := Vb4080_TestFcZeroC1 and not Vb4507_AppManAuto and Vb6_PinzeOkTestManut and MacchinaAzzerata );

		if ( RiseVb4080_TestFcZeroC1.q )then
			VbChn3Start := TRUE ;
		end_if;
(* centraggio pinza caricatore pinza cucitrice *)
RiseVb4081_TestCaricatorePinzaC1( in := Vb4081_TestCaricatorePinzaC1 and not Vb4507_AppManAuto  and Vb6_PinzeOkTestManut and MacchinaAzzerata );

		if ( RiseVb4081_TestCaricatorePinzaC1.q )then
			VbChn3Start := TRUE ;
		end_if;
		
(* centraggio pinza caricatore lancia  *)
RiseVb4082_TestCaricatoreLanciaC1( in := Vb4082_TestCaricatoreLanciaC1 and not Vb4507_AppManAuto  and Vb6_PinzeOkTestManut and MacchinaAzzerata );

		if ( RiseVb4082_TestCaricatoreLanciaC1.q )then
			VbChn3Start := TRUE ;
		end_if;

(* centraggio pinza caricatore 2  pinza Cucitrice 1 *)
RiseVb4083_TestCaricatoreC2CaricoC1( in := Vb4083_TestCaricatoreC2CaricoC1 and not Vb4507_AppManAuto  and Vb6_PinzeOkTestManut and MacchinaAzzerata );

		if ( RiseVb4083_TestCaricatoreC2CaricoC1.q )then
			VbChn3Start := TRUE ;
		end_if;



(* centraggio pinza caricatore 2  pinza Cucitrice 2 *)
RiseVb4084_TestCaricatoreC2ScaricoC2( in := Vb4084_TestCaricatoreC2ScaricoC2 and not Vb4507_AppManAuto  and Vb6_PinzeOkTestManut and MacchinaAzzerata );

		if ( RiseVb4084_TestCaricatoreC2ScaricoC2.q )then
			VbChn3Start := TRUE ;
		end_if;

(* centraggio pinza ago cucitrice 2 *)
RiseVb4079_TestHomeC2( in := Vb4079_TestHomeC2 and not Vb4507_AppManAuto  and Vb6_PinzeOkTestManut and MacchinaAzzerata );

		if ( RiseVb4079_TestHomeC2.q )then
			Vb4085_TestFcZeroC2 := TRUE ;
		end_if;

(* centraggio pinza ago cucitrice 2 *)
RiseVb4085_TestFcZeroC2( in := Vb4085_TestFcZeroC2 and not Vb4507_AppManAuto  and Vb6_PinzeOkTestManut and MacchinaAzzerata );

		if ( RiseVb4085_TestFcZeroC2.q )then
			VbChn3Start := TRUE ;
		end_if;

(* utilizzato per gestire l'anticipo tra pinza caricatore e C1 *)
RiseVb4087_TestLiberaPinzaCaricatore( in := Vb4087_TestLiberaPinzaCaricatore and not Vb4507_AppManAuto  and Vb6_PinzeOkTestManut and MacchinaAzzerata );

		if ( RiseVb4087_TestLiberaPinzaCaricatore.q )then
			VbChn3Start := TRUE ;
		end_if;


(* salvataggio quote *)

RiseVb4086_SavePosizioni( in := Vb4086_SavePosizioni and not Vb4507_AppManAuto );

(* centraggio pinza caricatore pinza cucitrice *)
	if ( Vb4081_TestCaricatorePinzaC1 and RiseVb4086_SavePosizioni.q )then
		Vq3502_PosizioneCaricScaricoTasca := PosAx_C1_AsseCAR ;
	end_if;
(* centraggio pinza caricatore lancia  *)
	if ( Vb4082_TestCaricatoreLanciaC1 and RiseVb4086_SavePosizioni.q )then
		Vq3501_PosizioneCaricCaricoTasca := PosAx_C1_AsseCAR ;
	end_if;
(* centraggio pinza caricatore 2  pinza Cucitrice 1 *)
	if ( Vb4083_TestCaricatoreC2CaricoC1 and RiseVb4086_SavePosizioni.q )then
		Vq3522_PosizioneTraslCaricoTascaC1 := PosAx_C2_AsseCAR ;
	end_if;
(* centraggio pinza caricatore 2  pinza Cucitrice 2 *)
	if ( Vb4084_TestCaricatoreC2ScaricoC2 and RiseVb4086_SavePosizioni.q )then
		Vq3520_PosizioneTraslScaricaC2 := PosAx_C2_AsseCAR ;
	end_if;
	
	
(* corsa massima caricatore su lancia  *)	
if(Vq3501_PosizioneCaricCaricoTasca > 450000)then
	Vq3501_PosizioneCaricCaricoTasca := 450000;
end_if;  	 			

]]>
					</sourceCode>
				</program>
				<program name="ComandiHMI" version="1.0.0" creationDate="0" lastModifiedDate="1710437706" excludeFromBuild="FALSE">
					<vars>
						<localVars>
							<var name="RiseVb52RichiestaZeroAxDaHmiC1" type="RiseEdge"/>
							<var name="RiseVb53RichiestaZeroAxDaHmiC2" type="RiseEdge"/>
							<var name="RitC1AsseXStep2" type="Ton"/>
							<var name="RitC1AsseXStep3" type="Ton"/>
							<var name="RitC1AsseYStep2" type="Ton"/>
							<var name="RitC1AsseYStep3" type="Ton"/>
							<var name="RitC2AsseXStep2" type="Ton"/>
							<var name="RitC2AsseXStep3" type="Ton"/>
							<var name="RitC2AsseYStep2" type="Ton"/>
							<var name="RitC2AsseYStep3" type="Ton"/>
							<var name="FallVb54HmiDiag_XP_YP_C1" type="FallEdge"/>
							<var name="FallVb55HmiDiag_XP_YM_C1" type="FallEdge"/>
							<var name="FallVb56HmiDiag_XM_YP_C1" type="FallEdge"/>
							<var name="FallVb57HmiDiag_XM_YM_C1" type="FallEdge"/>
							<var name="FallVb58HmiDiag_XP_YP_C2" type="FallEdge"/>
							<var name="FallVb59HmiDiag_XP_YM_C2" type="FallEdge"/>
							<var name="FallVb60HmiDiag_XM_YP_C2" type="FallEdge"/>
							<var name="FallVb61HmiDiag_XM_YM_C2" type="FallEdge"/>
							<var name="RiseJogAxX_C1" type="RiseEdge"/>
							<var name="RiseJogAxY_C1" type="RiseEdge"/>
							<var name="RiseJogAxX_C2" type="RiseEdge"/>
							<var name="RiseJogAxY_C2" type="RiseEdge"/>
							<var name="RiseVB_AX1_JOG_PIU" type="RiseEdge"/>
							<var name="RiseVB_AX1_JOG_MENO" type="RiseEdge"/>
							<var name="RitC1AsseXStep1" type="Ton"/>
							<var name="RitC1AsseYStep1" type="Ton"/>
							<var name="RiseVB_AX2_JOG_PIU" type="RiseEdge"/>
							<var name="RiseVB_AX2_JOG_MENO" type="RiseEdge"/>
							<var name="RitC2AsseXStep1" type="Ton"/>
							<var name="RiseVB_AX6_JOG_PIU" type="RiseEdge"/>
							<var name="RiseVB_AX6_JOG_MENO" type="RiseEdge"/>
							<var name="RitC2AsseYStep1" type="Ton"/>
							<var name="RiseVB_AX7_JOG_PIU" type="RiseEdge"/>
							<var name="RiseVB_AX7_JOG_MENO" type="RiseEdge"/>
							<var name="Rise_Vb34_FinitoCucitura_C1" type="RiseEdge"/>
							<var name="RiseMoveXY" type="RiseEdge"/>
							<var name="Rise_C1_VbRunCuci" type="RiseEdge"/>
							<var name="mc_stati_move_XY" type="INT"/>
							<var name="Rise_tascaDxSX" type="RiseEdge"/>
							<var name="Fall_tascaDxSX" type="FallEdge"/>
							<var name="Rise_Vb78SetVelManualeAsseAgo_C1" type="RiseEdge"/>
							<var name="Rit_IconaTools" type="Ton"/>
							<var name="RiseMoveXY_C2" type="RiseEdge"/>
							<var name="mc_stati_move_XY_C2" type="INT"/>
							<var name="Rise_Pagina_Jog" type="RiseEdge"/>
							<var name="Fall_Pagina_Jog" type="FallEdge"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[(* ========================================================================== 
(* SIPRO - Siax M															  	
(*                                                                            
(* COMPANY:     JAM INTERNATIONAL                                             
(*                                                                            
(* NAME: ComandiHMI                                                          
(*
(* TASK MAIN	 
(*
(* DESCRIPTION:  comandi HMI 
(*
(* NOTE:                                NAME:           VER:    DATE:         
(* -------------------------------------------------------------------------  
(* Prima stesura                        Jam             1.0     29/04/2021    
(* Ultima modifica                                                            
(* ========================================================================== *)

(**** comandi da hmi ****)
(* richiesta azzeramento pinza cucitrice 1*)

RiseVb52RichiestaZeroAxDaHmiC1( in := Vb52RichiestaZeroAxDaHmiC1 );
	
	if ( RiseVb52RichiestaZeroAxDaHmiC1.q )then
		VbFlgAzzAx1	:= FALSE ;
		VbFlgAzzAx2	:= FALSE ;
		VbChn1Start	:= TRUE ;
	end_if; 
	(* richiesta azzeramento pinza cucitrice 2*)

RiseVb53RichiestaZeroAxDaHmiC2( in := Vb53RichiestaZeroAxDaHmiC2 );
	
	if ( RiseVb53RichiestaZeroAxDaHmiC2.q )then
		VbFlgAzzAx6	:= FALSE ;
		VbFlgAzzAx7	:= FALSE ;
		VbChn2Start	:= TRUE ;
	end_if; 
	
(**** cambio velocità assi pinza tramite tasti su HMI ****)	
(* asse X cucitrice 1 *)

	if (VN_SYS_PAGE_ID = 1003 or VN_SYS_PAGE_ID = 1004 or VN_SYS_PAGE_ID = 1007)then
		RitC1AsseXStep1( in := Vb62HmiJogXP_C1 or Vb63HmiJogXM_C1, pt := 500 );
		RitC1AsseXStep2( in := Vb62HmiJogXP_C1 or Vb63HmiJogXM_C1, pt := 1500 );
		RitC1AsseXStep3( in := Vb62HmiJogXP_C1 or Vb63HmiJogXM_C1, pt := 2500 );
		RiseVB_AX1_JOG_PIU( in := Vb62HmiJogXP_C1 );
		RiseVB_AX1_JOG_MENO( in := Vb63HmiJogXM_C1 );
		RiseJogAxX_C1( in := not Vb62HmiJogXP_C1 and not Vb63HmiJogXM_C1 );
		
		(* attivo i jog PIU *)
		if ( ( RitC1AsseXStep1.q or RitC1AsseXStep2.q or RitC1AsseXStep3.q ) and Vb62HmiJogXP_C1 )then
			VB_AX1_JOG_PIU := TRUE ;
		end_if;
		
		(* attivo i jog MENO *)
		if ( ( RitC1AsseXStep1.q or RitC1AsseXStep2.q or RitC1AsseXStep3.q ) and Vb63HmiJogXM_C1 )then
			VB_AX1_JOG_MENO := TRUE ;
		end_if;

		(* velocità step 1 asse X C1 PIU *)
			if ( RiseVB_AX1_JOG_PIU.q and not RitC1AsseXStep1.q and not RitC1AsseXStep2.q and not RitC1AsseXStep3.q )then
				VQ_AX1_INCR_JOG := 50 ;	
				VB_AX1_JOG_INCR_PIU := TRUE ;
			end_if;	
				
		(* velocità step 1 asse X C1 PIU *)
			if ( RiseVB_AX1_JOG_MENO.q and not RitC1AsseXStep1.q and not RitC1AsseXStep2.q and not RitC1AsseXStep3.q )then
				VQ_AX1_INCR_JOG := 50 ;	
				VB_AX1_JOG_INCR_MENO := TRUE ;
			end_if;		

		(* velocità step 1 asse X C1 *)
			if (( VB_AX1_JOG_PIU or VB_AX1_JOG_MENO ) and RitC1AsseXStep1.q and not RitC1AsseXStep2.q and not RitC1AsseXStep3.q )then		
				if (VN_SYS_PAGE_ID = 1003 or VN_SYS_PAGE_ID = 1007)then
					if(not Vb4014JogFastSlow) then
						VN_AX1_OVERRIDE := Vn151_SpeedStep1 * 10;
					else
						VN_AX1_OVERRIDE := Vn151_SpeedStep1;
					end_if;	
				end_if;	
				if (VN_SYS_PAGE_ID = 1004 )then
					VN_AX1_OVERRIDE := Vn151_SpeedStep1;
				end_if;	
			end_if;		

		(* velocità step 2 asse X C1 *)
			if (( VB_AX1_JOG_PIU or VB_AX1_JOG_MENO ) and RitC1AsseXStep1.q and RitC1AsseXStep2.q and not RitC1AsseXStep3.q )then
				if (VN_SYS_PAGE_ID = 1003 or VN_SYS_PAGE_ID = 1007)then
					if(not Vb4014JogFastSlow) then
						VN_AX1_OVERRIDE := Vn152_SpeedStep2 * 10;
					else
						VN_AX1_OVERRIDE := Vn152_SpeedStep2;
					end_if;	
				end_if;	
				if (VN_SYS_PAGE_ID = 1004 )then
					VN_AX1_OVERRIDE := Vn152_SpeedStep2;
				end_if;	
			end_if;		

		(* velocità step 3 asse X C1 *)
			if (( VB_AX1_JOG_PIU or VB_AX1_JOG_MENO ) and RitC1AsseXStep1.q and RitC1AsseXStep2.q and RitC1AsseXStep3.q )then
				if (VN_SYS_PAGE_ID = 1003 or VN_SYS_PAGE_ID = 1007)then
					if(not Vb4014JogFastSlow) then
						VN_AX1_OVERRIDE := Vn153_SpeedStep3 * 10;
					else
						VN_AX1_OVERRIDE := Vn153_SpeedStep3;
					end_if;	
				end_if;	
				if (VN_SYS_PAGE_ID = 1004 )then
					VN_AX1_OVERRIDE := Vn153_SpeedStep3;
				end_if;	
			end_if;	
		(* velocità 100% *)	
			if ( RiseJogAxX_C1.q )then
				VB_AX1_JOG_PIU  := FALSE ;
				VB_AX1_JOG_MENO := FALSE ;
				VN_AX1_OVERRIDE := 1000  ;
			end_if;		
	else;
		VN_AX1_OVERRIDE := 1000 ;
	end_if;

(* asse Y cucitrice 1 *)

	if (VN_SYS_PAGE_ID = 1003  or VN_SYS_PAGE_ID = 1004  or VN_SYS_PAGE_ID = 1007)then
		RitC1AsseYStep1( in := Vb64HmiJogYP_C1 or Vb65HmiJogYM_C1, pt := 500 );
		RitC1AsseYStep2( in := Vb64HmiJogYP_C1 or Vb65HmiJogYM_C1, pt := 1500 );
		RitC1AsseYStep3( in := Vb64HmiJogYP_C1 or Vb65HmiJogYM_C1, pt := 2500 );
		RiseVB_AX2_JOG_PIU( in := Vb64HmiJogYP_C1 );
		RiseVB_AX2_JOG_MENO( in := Vb65HmiJogYM_C1 );
		RiseJogAxY_C1( in := not Vb64HmiJogYP_C1 and not Vb65HmiJogYM_C1 );
		
		(* attivo i jog PIU *)
		if ( ( RitC1AsseYStep1.q or RitC1AsseYStep2.q or RitC1AsseYStep3.q ) and Vb64HmiJogYP_C1 )then
			VB_AX2_JOG_PIU := TRUE ;
		end_if;
		
		(* attivo i jog MENO *)
		if ( ( RitC1AsseYStep1.q or RitC1AsseYStep2.q or RitC1AsseYStep3.q ) and Vb65HmiJogYM_C1 )then
			VB_AX2_JOG_MENO := TRUE ;
		end_if;

		(* velocità step 1 asse X C1 PIU *)
			if ( RiseVB_AX2_JOG_PIU.q and not RitC1AsseYStep1.q and not RitC1AsseYStep2.q and not RitC1AsseYStep3.q )then
				VQ_AX2_INCR_JOG := 50 ;	
				VB_AX2_JOG_INCR_PIU := TRUE ;
			end_if;	
				
		(* velocità step 1 asse X C1 PIU *)
			if ( RiseVB_AX2_JOG_MENO.q and not RitC1AsseYStep1.q and not RitC1AsseYStep2.q and not RitC1AsseYStep3.q )then
				VQ_AX2_INCR_JOG := 50 ;	
				VB_AX2_JOG_INCR_MENO := TRUE ;
			end_if;		

		(* velocità step 1 asse X C1 *)
			if (( VB_AX2_JOG_PIU or VB_AX2_JOG_MENO ) and RitC1AsseYStep1.q and not RitC1AsseYStep2.q and not RitC1AsseYStep3.q )then				
				if (VN_SYS_PAGE_ID = 1003 or VN_SYS_PAGE_ID = 1007)then
					if(not Vb4014JogFastSlow) then
						VN_AX2_OVERRIDE := Vn151_SpeedStep1 * 10;
					else
						VN_AX2_OVERRIDE := Vn151_SpeedStep1;
					end_if;	
				end_if;	
				if (VN_SYS_PAGE_ID = 1004 )then
					VN_AX2_OVERRIDE := Vn151_SpeedStep1;
				end_if;									
			end_if;		

		(* velocità step 2 asse X C1 *)
			if (( VB_AX2_JOG_PIU or VB_AX2_JOG_MENO ) and RitC1AsseYStep1.q and RitC1AsseYStep2.q and not RitC1AsseYStep3.q )then			
				if (VN_SYS_PAGE_ID = 1003 or VN_SYS_PAGE_ID = 1007)then
					if(not Vb4014JogFastSlow) then
						VN_AX2_OVERRIDE := Vn152_SpeedStep2 * 10;
					else
						VN_AX2_OVERRIDE := Vn152_SpeedStep2;
					end_if;	
				end_if;	
				if (VN_SYS_PAGE_ID = 1004 )then
					VN_AX2_OVERRIDE := Vn152_SpeedStep2;
				end_if;									
			end_if;		

		(* velocità step 3 asse X C1 *)
			if (( VB_AX2_JOG_PIU or VB_AX2_JOG_MENO ) and RitC1AsseYStep1.q and RitC1AsseYStep2.q and RitC1AsseYStep3.q )then
				if (VN_SYS_PAGE_ID = 1003 or VN_SYS_PAGE_ID = 1007)then
					if(not Vb4014JogFastSlow) then
						VN_AX2_OVERRIDE := Vn153_SpeedStep3 * 10;
					else
						VN_AX2_OVERRIDE := Vn153_SpeedStep3;
					end_if;	
				end_if;	
				if (VN_SYS_PAGE_ID = 1004 )then
					VN_AX2_OVERRIDE := Vn153_SpeedStep3;
				end_if;		
				
			end_if;	
		(* velocità 100% *)	
			if ( RiseJogAxY_C1.q )then
				VB_AX2_JOG_PIU  := FALSE ;
				VB_AX2_JOG_MENO := FALSE ;
				VN_AX2_OVERRIDE := 1000  ;
			end_if;		
	else;
		VN_AX2_OVERRIDE := 1000 ;
	end_if;

	
(**** cambio velocità assi pinza tramite tasti su HMI ****)	
(* asse X cucitrice 2 *)

	if (VN_SYS_PAGE_ID = 1003  or VN_SYS_PAGE_ID = 1004 or VN_SYS_PAGE_ID = 1007)then
		RitC2AsseXStep1( in := Vb66HmiJogXP_C2 or Vb67HmiJogXM_C2, pt := 500 );
		RitC2AsseXStep2( in := Vb66HmiJogXP_C2 or Vb67HmiJogXM_C2, pt := 1500 );
		RitC2AsseXStep3( in := Vb66HmiJogXP_C2 or Vb67HmiJogXM_C2, pt := 2500 );
		RiseVB_AX6_JOG_PIU( in := Vb66HmiJogXP_C2 );
		RiseVB_AX6_JOG_MENO( in := Vb67HmiJogXM_C2 );
		RiseJogAxX_C2( in := not Vb66HmiJogXP_C2 and not Vb67HmiJogXM_C2 );
		
		(* attivo i jog PIU *)
		if ( ( RitC2AsseXStep1.q or RitC2AsseXStep2.q or RitC2AsseXStep3.q ) and Vb66HmiJogXP_C2 )then
			VB_AX6_JOG_PIU := TRUE ;
		end_if;
		
		(* attivo i jog MENO *)
		if ( ( RitC2AsseXStep1.q or RitC2AsseXStep2.q or RitC2AsseXStep3.q ) and Vb67HmiJogXM_C2 )then
			VB_AX6_JOG_MENO := TRUE ;
		end_if;

		(* velocità step 1 asse X C2 PIU *)
			if ( RiseVB_AX6_JOG_PIU.q and not RitC2AsseXStep1.q and not RitC2AsseXStep2.q and not RitC2AsseXStep3.q )then
				VQ_AX6_INCR_JOG := 50 ;	
				VB_AX6_JOG_INCR_PIU := TRUE ;
			end_if;	
				
		(* velocità step 1 asse X C2 PIU *)
			if ( RiseVB_AX6_JOG_MENO.q and not RitC2AsseXStep1.q and not RitC2AsseXStep2.q and not RitC2AsseXStep3.q )then
				VQ_AX6_INCR_JOG := 50 ;	
				VB_AX6_JOG_INCR_MENO := TRUE ;
			end_if;		

		(* velocità step 1 asse X C2 *)
			if (( VB_AX6_JOG_PIU or VB_AX6_JOG_MENO ) and RitC2AsseXStep1.q and not RitC2AsseXStep2.q and not RitC2AsseXStep3.q )then
				if (VN_SYS_PAGE_ID = 1003 or VN_SYS_PAGE_ID = 1007)then
					if(not Vb4014JogFastSlow) then
						VN_AX6_OVERRIDE := Vn151_SpeedStep1 * 10;
					else
						VN_AX6_OVERRIDE := Vn151_SpeedStep1;
					end_if;	
				end_if;	
				if (VN_SYS_PAGE_ID = 1004 )then
					VN_AX6_OVERRIDE := Vn151_SpeedStep1;
				end_if;	
			end_if;		

		(* velocità step 2 asse X C2 *)
			if (( VB_AX6_JOG_PIU or VB_AX6_JOG_MENO ) and RitC2AsseXStep1.q and RitC2AsseXStep2.q and not RitC2AsseXStep3.q )then
				if (VN_SYS_PAGE_ID = 1003 or VN_SYS_PAGE_ID = 1007)then
					if(not Vb4014JogFastSlow) then
						VN_AX6_OVERRIDE := Vn152_SpeedStep2 * 10;
					else
						VN_AX6_OVERRIDE := Vn152_SpeedStep2;
					end_if;	
				end_if;	
				if (VN_SYS_PAGE_ID = 1004 )then
					VN_AX6_OVERRIDE := Vn152_SpeedStep2;
				end_if;	
			end_if;		

		(* velocità step 3 asse X C2 *)
			if (( VB_AX6_JOG_PIU or VB_AX6_JOG_MENO ) and RitC2AsseXStep1.q and RitC2AsseXStep2.q and RitC2AsseXStep3.q )then
				if (VN_SYS_PAGE_ID = 1003 or VN_SYS_PAGE_ID = 1007)then
				if(not Vb4014JogFastSlow) then
						VN_AX6_OVERRIDE := Vn153_SpeedStep3 * 10;
					else
						VN_AX6_OVERRIDE := Vn153_SpeedStep3;
					end_if;	
				end_if;	
				if (VN_SYS_PAGE_ID = 1004 )then
					VN_AX6_OVERRIDE := Vn153_SpeedStep3;
				end_if;	
			end_if;	
		(* velocità 100% *)	
			if ( RiseJogAxX_C2.q )then
				VB_AX6_JOG_PIU  := FALSE ;
				VB_AX6_JOG_MENO := FALSE ;
				VN_AX6_OVERRIDE := 1000  ;
			end_if;		
	else;
		VN_AX6_OVERRIDE := 1000 ;
	end_if;

(* asse Y cucitrice 2 *)

	if (VN_SYS_PAGE_ID = 1003  or VN_SYS_PAGE_ID = 1004 or VN_SYS_PAGE_ID = 1007)then
		RitC2AsseYStep1( in := Vb68HmiJogYP_C2 or Vb69HmiJogYM_C2, pt := 500 );
		RitC2AsseYStep2( in := Vb68HmiJogYP_C2 or Vb69HmiJogYM_C2, pt := 1500 );
		RitC2AsseYStep3( in := Vb68HmiJogYP_C2 or Vb69HmiJogYM_C2, pt := 2500 );
		RiseVB_AX7_JOG_PIU( in := Vb68HmiJogYP_C2 );
		RiseVB_AX7_JOG_MENO( in := Vb69HmiJogYM_C2 );
		RiseJogAxY_C2( in := not Vb68HmiJogYP_C2 and not Vb69HmiJogYM_C2 );
		
		(* attivo i jog PIU *)
		if ( ( RitC2AsseYStep1.q or RitC2AsseYStep2.q or RitC2AsseYStep3.q ) and Vb68HmiJogYP_C2 )then
			VB_AX7_JOG_PIU := TRUE ;
		end_if;
		
		(* attivo i jog MENO *)
		if ( ( RitC2AsseYStep1.q or RitC2AsseYStep2.q or RitC2AsseYStep3.q ) and Vb69HmiJogYM_C2 )then
			VB_AX7_JOG_MENO := TRUE ;
		end_if;

		(* velocità step 1 asse X C2 PIU *)
			if ( RiseVB_AX7_JOG_PIU.q and not RitC2AsseYStep1.q and not RitC2AsseYStep2.q and not RitC2AsseYStep3.q )then
				VQ_AX7_INCR_JOG := 50 ;	
				VB_AX7_JOG_INCR_PIU := TRUE ;
			end_if;	
				
		(* velocità step 1 asse X C2 PIU *)
			if ( RiseVB_AX7_JOG_MENO.q and not RitC2AsseYStep1.q and not RitC2AsseYStep2.q and not RitC2AsseYStep3.q )then
				VQ_AX7_INCR_JOG := 50 ;	
				VB_AX7_JOG_INCR_MENO := TRUE ;
			end_if;		

		(* velocità step 1 asse X C2 *)
			if (( VB_AX7_JOG_PIU or VB_AX7_JOG_MENO ) and RitC2AsseYStep1.q and not RitC2AsseYStep2.q and not RitC2AsseYStep3.q )then
				if (VN_SYS_PAGE_ID = 1003 or VN_SYS_PAGE_ID = 1007)then
					if(not Vb4014JogFastSlow) then
						VN_AX7_OVERRIDE := Vn151_SpeedStep1 * 10;
					else
						VN_AX7_OVERRIDE := Vn151_SpeedStep1;
					end_if;	
				end_if;	
				if (VN_SYS_PAGE_ID = 1004 )then
					VN_AX7_OVERRIDE := Vn151_SpeedStep1;
				end_if;	
			end_if;		

		(* velocità step 2 asse X C2 *)
			if (( VB_AX7_JOG_PIU or VB_AX7_JOG_MENO ) and RitC2AsseYStep1.q and RitC2AsseYStep2.q and not RitC2AsseYStep3.q )then
				if (VN_SYS_PAGE_ID = 1003 or VN_SYS_PAGE_ID = 1007)then
					if(not Vb4014JogFastSlow) then
						VN_AX7_OVERRIDE := Vn152_SpeedStep2 * 10;
					else
						VN_AX7_OVERRIDE := Vn152_SpeedStep2;
					end_if;	
				end_if;	
				if (VN_SYS_PAGE_ID = 1004 )then
					VN_AX7_OVERRIDE := Vn152_SpeedStep2;
				end_if;	
			end_if;		

		(* velocità step 3 asse X C2 *)
			if (( VB_AX7_JOG_PIU or VB_AX7_JOG_MENO ) and RitC2AsseYStep1.q and RitC2AsseYStep2.q and RitC2AsseYStep3.q )then
				if (VN_SYS_PAGE_ID = 1003 or VN_SYS_PAGE_ID = 1007)then
					if(not Vb4014JogFastSlow) then
						VN_AX7_OVERRIDE := Vn153_SpeedStep3 * 10;
					else
						VN_AX7_OVERRIDE := Vn153_SpeedStep3;
					end_if;	
				end_if;	
				if (VN_SYS_PAGE_ID = 1004 )then
					VN_AX7_OVERRIDE := Vn153_SpeedStep3;
				end_if;	
			end_if;	
		(* velocità 100% *)	
			if ( RiseJogAxY_C2.q )then
				VB_AX7_JOG_PIU  := FALSE ;
				VB_AX7_JOG_MENO := FALSE ;
				VN_AX7_OVERRIDE := 1000  ;
			end_if;		
	else;
		VN_AX7_OVERRIDE := 1000 ;
	end_if;	


(**** gestione diagonali tramite tasti su HMI ****)	

(*** cucitrice 1 ***)
(* X POSITIVO Y POSITIVO *) 
	if (VN_SYS_PAGE_ID = 1003  or VN_SYS_PAGE_ID = 1004 or VN_SYS_PAGE_ID = 1007)then
		if ( Vb54HmiDiag_XP_YP_C1 )then
			Vb62HmiJogXP_C1 := TRUE ;
			Vb64HmiJogYP_C1 := TRUE ;
		end_if;
	else;
		Vb54HmiDiag_XP_YP_C1 := FALSE ;
	end_if;
	(* azzero tutto allo spegnimento vb *)	
	FallVb54HmiDiag_XP_YP_C1( in := Vb54HmiDiag_XP_YP_C1 );
		if ( FallVb54HmiDiag_XP_YP_C1.q )then
			Vb62HmiJogXP_C1 := FALSE ;
			Vb64HmiJogYP_C1 := FALSE ;
		end_if;
	
(* X POSITIVO Y NEGATIVO *)
	if (VN_SYS_PAGE_ID = 1003  or VN_SYS_PAGE_ID = 1004 or VN_SYS_PAGE_ID = 1007)then
		if ( Vb55HmiDiag_XP_YM_C1 )then
			Vb62HmiJogXP_C1 := TRUE ;
			Vb65HmiJogYM_C1 := TRUE ;
		end_if;
	else;
		Vb55HmiDiag_XP_YM_C1 := FALSE ;
	end_if;
	(* azzero tutto allo spegnimento vb *)	
	FallVb55HmiDiag_XP_YM_C1( in := Vb55HmiDiag_XP_YM_C1 );
		if ( FallVb55HmiDiag_XP_YM_C1.q )then
			Vb62HmiJogXP_C1 := FALSE ;
			Vb65HmiJogYM_C1 := FALSE ;
		end_if;	

(* X NEGATIVO Y POSITIVO *)
	if (VN_SYS_PAGE_ID = 1003  or VN_SYS_PAGE_ID = 1004 or VN_SYS_PAGE_ID = 1007)then
		if ( Vb56HmiDiag_XM_YP_C1 )then
			Vb63HmiJogXM_C1 := TRUE ;
			Vb64HmiJogYP_C1 := TRUE ;
		end_if;
	else;
		Vb56HmiDiag_XM_YP_C1 := FALSE ;
	end_if;
	(* azzero tutto allo spegnimento vb *)	
	FallVb56HmiDiag_XM_YP_C1( in := Vb56HmiDiag_XM_YP_C1 );
		if ( FallVb56HmiDiag_XM_YP_C1.q )then
			Vb63HmiJogXM_C1 := FALSE ;
			Vb64HmiJogYP_C1 := FALSE ;
		end_if;
	
(* X NEGATIVO Y NEGATIVO *)
	if (VN_SYS_PAGE_ID = 1003  or VN_SYS_PAGE_ID = 1004 or VN_SYS_PAGE_ID = 1007)then
		if ( Vb57HmiDiag_XM_YM_C1 )then
			Vb63HmiJogXM_C1 := TRUE ;
			Vb65HmiJogYM_C1 := TRUE ;
		end_if;
	else;
		Vb57HmiDiag_XM_YM_C1 := FALSE ;
	end_if;
	(* azzero tutto allo spegnimento vb *)	
	FallVb57HmiDiag_XM_YM_C1( in := Vb57HmiDiag_XM_YM_C1 );
		if ( FallVb57HmiDiag_XM_YM_C1.q )then
			Vb63HmiJogXM_C1 := FALSE ;
			Vb65HmiJogYM_C1 := FALSE ;
		end_if;	


(*** cucitrice 2 ***)
(* X POSITIVO Y POSITIVO *)
	if (VN_SYS_PAGE_ID = 1003  or VN_SYS_PAGE_ID = 1004 or VN_SYS_PAGE_ID = 1007)then
		if ( Vb58HmiDiag_XP_YP_C2 )then
			Vb66HmiJogXP_C2 := TRUE ;
			Vb68HmiJogYP_C2 := TRUE ;
		end_if;
	else;
		Vb58HmiDiag_XP_YP_C2 := FALSE ;
	end_if;
	(* azzero tutto allo spegnimento vb *)	
	FallVb58HmiDiag_XP_YP_C2( in := Vb58HmiDiag_XP_YP_C2 );
		if ( FallVb58HmiDiag_XP_YP_C2.q )then
			Vb66HmiJogXP_C2 := FALSE ;
			Vb68HmiJogYP_C2 := FALSE ;
		end_if;
	
(* X POSITIVO Y NEGATIVO *)
	if (VN_SYS_PAGE_ID = 1003  or VN_SYS_PAGE_ID = 1004 or VN_SYS_PAGE_ID = 1007)then
		if ( Vb59HmiDiag_XP_YM_C2 )then
			Vb66HmiJogXP_C2 := TRUE ;
			Vb69HmiJogYM_C2 := TRUE ;
		end_if;
	else;
		Vb59HmiDiag_XP_YM_C2 := FALSE ;
	end_if;
	(* azzero tutto allo spegnimento vb *)	
	FallVb59HmiDiag_XP_YM_C2( in := Vb59HmiDiag_XP_YM_C2 );
		if ( FallVb59HmiDiag_XP_YM_C2.q )then
			Vb66HmiJogXP_C2 := FALSE ;
			Vb69HmiJogYM_C2 := FALSE ;
		end_if;	

(* X NEGATIVO Y POSITIVO *)
	if (VN_SYS_PAGE_ID = 1003  or VN_SYS_PAGE_ID = 1004 or VN_SYS_PAGE_ID = 1007)then
		if ( Vb60HmiDiag_XM_YP_C2 )then
			Vb67HmiJogXM_C2 := TRUE ;
			Vb68HmiJogYP_C2 := TRUE ;
		end_if;
	else;
		Vb60HmiDiag_XM_YP_C2 := FALSE ;
	end_if;
	(* azzero tutto allo spegnimento vb *)	
	FallVb60HmiDiag_XM_YP_C2( in := Vb60HmiDiag_XM_YP_C2 );
		if ( FallVb60HmiDiag_XM_YP_C2.q )then
			Vb67HmiJogXM_C2 := FALSE ;
			Vb68HmiJogYP_C2 := FALSE ;
		end_if;
	
(* X NEGATIVO Y NEGATIVO *)
	if (VN_SYS_PAGE_ID = 1003  or VN_SYS_PAGE_ID = 1004 or VN_SYS_PAGE_ID = 1007)then
		if ( Vb61HmiDiag_XM_YM_C2 )then
			Vb67HmiJogXM_C2 := TRUE ;
			Vb69HmiJogYM_C2 := TRUE ;
		end_if;
	else;
		Vb61HmiDiag_XM_YM_C2 := FALSE ;
	end_if;
	(* azzero tutto allo spegnimento vb *)	
	FallVb61HmiDiag_XM_YM_C2( in := Vb61HmiDiag_XM_YM_C2 );
		if ( FallVb61HmiDiag_XM_YM_C2.q )then
			Vb67HmiJogXM_C2 := FALSE ;
			Vb69HmiJogYM_C2 := FALSE ;
		end_if;	

(* Modifica_programmi del HMI chiede di spostare XY a quota *)
RiseMoveXY ( in:= Vb72HmiMoveXY_C1);
if(RiseMoveXY.q) then

	mc_stati_move_XY := 5;

end_if;

case ( mc_stati_move_XY ) of

	5:
		Vb72HmiMoveXY_C1 := FALSE;
		if(	Vb74HmiMoveXY_PieAlto_C1 ) then
		
			C1_CmdPiedinoSu := TRUE;
			C1_CmdPiedinoGiu := FALSE;
			mc_stati_move_XY :=7;	
		else
			mc_stati_move_XY :=10;	
		end_if;
	

	7:
		if ( not C1_CmdPiedinoSu ) then	(* Entro quando il piedino è alto *)
			mc_stati_move_XY :=10;	
		end_if;
	
	10:
		VB_AX1_START_SEMI := TRUE;
		VB_AX2_START_SEMI := TRUE;
		mc_stati_move_XY := 20;
		Vb74HmiMoveXY_PieAlto_C1 :=FALSE;
		
		(* Default switch case *)
	else
    	
    	mc_stati_move_XY := 0;  	
		
end_case;


(* Modifica_programmi del HMI chiede di spostare XY a quota *)
RiseMoveXY_C2 ( in:= Vb73HmiMoveXY_C2);
if(RiseMoveXY_C2.q) then

	mc_stati_move_XY_C2 := 5;

end_if;

case ( mc_stati_move_XY_C2 ) of

	5:
		Vb73HmiMoveXY_C2 := FALSE;
		if(	Vb75HmiMoveXY_PieAlto_C2 ) then
		
			C2_CmdPiedinoSu := TRUE;
			C2_CmdPiedinoGiu := FALSE;
			mc_stati_move_XY_C2 :=7;	
		else
			mc_stati_move_XY_C2 :=10;	
		end_if;
	

	7:
		if ( not C2_CmdPiedinoSu ) then	(* Entro quando il piedino è alto *)
			mc_stati_move_XY_C2 :=10;	
		end_if;
	
	10:
		VB_AX6_START_SEMI := TRUE;
		VB_AX7_START_SEMI := TRUE;
		mc_stati_move_XY_C2 := 20;
		Vb75HmiMoveXY_PieAlto_C2 :=FALSE;
		
		(* Default switch case *)
	else
    	
    	mc_stati_move_XY_C2 := 0;  	
		
end_case;



(* spengo tasto Test se parto a cucire *)
Rise_C1_VbRunCuci (in:= C1_VbRunCuci);
if(Rise_C1_VbRunCuci.q) then
	C1_CuciSimulaAuto := FALSE;
end_if;




(* finito una cucitura *)
Rise_Vb34_FinitoCucitura_C1 (in:= Vb34_FinitoCucitura_C1);
if(Rise_Vb34_FinitoCucitura_C1.q) then
	Vb34_FinitoCucitura_C1 := FALSE;
	if(Vb76EnableCucitureInfinite_C1) then

		Vb4350_AppAut_o18_C1_Pinza_int := FALSE;
		Vb4351_AppAut_o19_C1_Pinza_est := FALSE;
		Vb4801_PulsStartHmiC1 := TRUE;
	end_if;
end_if;


(*tasca dx e sx*)
Rise_tascaDxSX (in:=Vb21_Tasca_dx_sx);
Fall_tascaDxSX (in:=Vb21_Tasca_dx_sx);
if(Rise_tascaDxSX.q or Fall_tascaDxSX.q) then 
	Vn196_Tasca_DX_C1 :=1;
	Vn197_Tasca_SX_C1 :=0;
	Vn198_Tasca_DX_C2 :=1;
	Vn199_Tasca_SX_C2 :=0;
end_if;
(* velocità manuale del jog ago *)
Rise_Vb78SetVelManualeAsseAgo_C1 (in:= Vb78SetVelManualeAsseAgo_C1);
if(Rise_Vb78SetVelManualeAsseAgo_C1.q) then
	Vb78SetVelManualeAsseAgo_C1 := FALSE;
	ipar := ( (C1_AsseAGO * 100) + 2 ); 
	vret := ExecPlcFun( PLC_WRITE_AX_PARAM, ipar, 108 );	//Vq108_WRITE_Vel_manualeAgo_C1 contiene valore da scrivere.
end_if;
(* se asse X o Y sono in allarme avviso HMI *)	
if(not i32_C1_ReadyAsseY) then
	Vn2CodiceAllarmeXHmi := 15;
end_if;
if(not i31_C1_ReadyAsseX) then
	Vn2CodiceAllarmeXHmi := 14;
end_if;

(* decido se HMI può mostrare il tasto tools nella pagina main *)

case ( Vn_ID_macchina ) of

	882:
		Rit_IconaTools ( in := (not Vb4806_AppPinzaAltaC1 and Vb4058_C1_AsseX_YFermo and not Vb30_C1_InCucitura and not Vb52RichiestaZeroAxDaHmiC1 
 		and not C1_CmdHoldRelease and Vb4059_C2_AsseX_YFermo and not Vb31_C2_InCucitura and not Vb4906_AppPinzaIntAltaC2 and not Vb53RichiestaZeroAxDaHmiC2), pt := 300 );
		(*spengo?*)
		if(Vb4806_AppPinzaAltaC1 or not Vb4058_C1_AsseX_YFermo or Vb30_C1_InCucitura or Vb52RichiestaZeroAxDaHmiC1 or C1_CmdHoldRelease or Vb4906_AppPinzaIntAltaC2 or Vb31_C2_InCucitura or Vb53RichiestaZeroAxDaHmiC2 ) then
			Vb80ShowIconaTools := FALSE;
		end_if;


	862: (*862M*)
		Rit_IconaTools ( in := (not Vb4806_AppPinzaAltaC1 and Vb4058_C1_AsseX_YFermo and not Vb30_C1_InCucitura and not Vb52RichiestaZeroAxDaHmiC1 and not C1_CmdHoldRelease), pt := 300 );
  
  		(*spengo?*)
		if(Vb4806_AppPinzaAltaC1 or not Vb4058_C1_AsseX_YFermo or Vb30_C1_InCucitura or Vb52RichiestaZeroAxDaHmiC1 or C1_CmdHoldRelease) then
			Vb80ShowIconaTools := FALSE;
		end_if;
	860: (*862HM*)
		Rit_IconaTools ( in := (not Vb4806_AppPinzaAltaC1 and Vb4058_C1_AsseX_YFermo and not Vb30_C1_InCucitura and not Vb52RichiestaZeroAxDaHmiC1 and not C1_CmdHoldRelease), pt := 300 );
 	
 		(*spengo?*)
		if(Vb4806_AppPinzaAltaC1 or not Vb4058_C1_AsseX_YFermo or Vb30_C1_InCucitura or Vb52RichiestaZeroAxDaHmiC1 or C1_CmdHoldRelease) then
			Vb80ShowIconaTools := FALSE;
		end_if;
end_case;

	
if(Rit_IconaTools.q and not Vb4523_C2_PinzaDietroUnaTesta) then
	Vb80ShowIconaTools := TRUE;
	
end_if;






(*-----------  limite jog ----------------*)
(*limite jog X+*)
if(VB_AX1_JOG_PIU and PosAx_C1_AsseX >Vq_105_READ_FC_ava_X) then
	VB_AX1_JOG_PIU := FALSE;
end_if;

(*limite jog X-*)
if(VB_AX1_JOG_MENO and PosAx_C1_AsseX < Vq_104_READ_FC_ind_X) then
	VB_AX1_JOG_MENO := FALSE;
end_if;

(*limite jog Y+*)
if(VB_AX2_JOG_PIU and PosAx_C1_AsseY > Vq_107_READ_FC_ava_Y) then
	VB_AX2_JOG_PIU := FALSE;
end_if;

(*limite jog Y-*)
if(VB_AX2_JOG_MENO and PosAx_C1_AsseY < Vq_106_READ_FC_ind_Y) then
	VB_AX2_JOG_MENO := FALSE;
end_if;

(*limite jog CARIC DX*)
if(VB_AX5_JOG_PIU and PosAx_C1_AsseCAR > Vq_111_READ_FC_ava_CARIC) then
	VB_AX5_JOG_PIU := FALSE;
end_if;

(*limite jog CARIC sX*)
if(VB_AX5_JOG_MENO and PosAx_C1_AsseCAR < Vq_110_READ_FC_ind_CARIC) then
	VB_AX5_JOG_MENO := FALSE;
end_if;

(*limite jog CARIC SX*)
(*-----------  limite jog C2 ----------------*)
(*limite jog X+  C2   *)
if(VB_AX6_JOG_PIU and PosAx_C2_AsseX >Vq_115_READ_FC_ava_X_C2) then
	VB_AX6_JOG_PIU := FALSE;
end_if;

(*limite jog X-  C2  *)
if(VB_AX6_JOG_MENO and PosAx_C2_AsseX < Vq_114_READ_FC_ind_X_C2) then
	VB_AX6_JOG_MENO := FALSE;
end_if;

(*limite jog Y+  C2 *)
if(VB_AX7_JOG_PIU and PosAx_C2_AsseY > Vq_117_READ_FC_ava_Y_C2) then
	VB_AX7_JOG_PIU := FALSE;
end_if;

(*limite jog Y-  C2 *)
if(VB_AX7_JOG_MENO and PosAx_C2_AsseY < Vq_116_READ_FC_ind_Y_C2) then
	VB_AX7_JOG_MENO := FALSE;
end_if;

(*limite jog CARIC DX *)
if(VB_AX10_JOG_PIU and PosAx_C2_AsseCAR > Vq_119_READ_FC_ava_CARIC_C2) then
	VB_AX10_JOG_PIU := FALSE;
end_if;

(*limite jog CARIC DX *)
if(VB_AX10_JOG_MENO and PosAx_C2_AsseCAR  < Vq_118_READ_FC_ind_CARIC_C2 ) then
	VB_AX10_JOG_MENO := FALSE;
end_if;

(*limite jog CARIC SX*)


(*pagina JOG*)
Rise_Pagina_Jog (in:= Vn3804_PageID = 1008);
Fall_Pagina_Jog (in:= Vn3804_PageID = 1008);
if(Rise_Pagina_Jog.q) then
	VnVelJogAx3 :=10;
end_if;

if(Fall_Pagina_Jog.q) then
	VnVelJogAx3 :=0;
end_if;
]]>
					</sourceCode>
				</program>
				<program name="RotturaFilo_Spola_C1" version="1.0.0" creationDate="0" lastModifiedDate="1711621497" excludeFromBuild="FALSE">
					<vars>
						<localVars>
							<var name="CNT_N_PuntiRottFiloC1" type="DINT"/>
							<var name="FallVb4_C1_InCucitura" type="FallEdge"/>
							<var name="OLD_ContPuntiRottFiloC1" type="DINT"/>
							<var name="Rise_cnt_giro" type="RiseEdge"/>
							<var name="RiseStopC1" type="RiseEdge"/>
							<var name="RiseVb4_C1_InCucitura" type="RiseEdge"/>
							<var name="RiseAllSpolaC1" type="RiseEdge"/>
							<var name="FallAllSpolaC1" type="FallEdge"/>
							<var name="Rise_Vb4075_GiraAgoFaiSpolaC1" type="RiseEdge"/>
							<var name="Fall_Vb4075_GiraAgoFaiSpolaC1" type="FallEdge"/>
							<var name="Ton_Vb4075_GiraAgoFaiSpolaC1" type="Ton"/>
							<var name="Rise_paginaTest_IO" type="RiseEdge"/>
							<var name="Fall_paginaTest_IO" type="FallEdge"/>
							<var name="Rise_i18_C1_RotturaFilo" type="RiseEdge"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[(* ========================================================================== 
(* SIPRO - Siax M															  	
(*                                                                            
(* COMPANY:     JAM INTERNATIONAL                                             
(*                                                                            
(* NAME: RotturaFile_Spola_C1                                                          
(*
(* TASK MAIN	 
(*
(* DESCRIPTION:  Rottura filo cucitrice 1 
(*
(* NOTE:                                NAME:           VER:    DATE:         
(* -------------------------------------------------------------------------  
(* Prima stesura                        Jam             1.0     29/04/2021    
(* Ultima modifica                                                            
(* ========================================================================== *)
RiseVb4_C1_InCucitura ( in:= Vb4_C1_InCucitura );
FallVb4_C1_InCucitura ( in:= Vb4_C1_InCucitura );

	(* se parto a cucire*)
	if ( RiseVb4_C1_InCucitura.q )then 	 
		 CNT_N_PuntiRottFiloC1 :=0;
	end_if;
	
	(* se mi fermo a cucire*)
	
	if ( FallVb4_C1_InCucitura.q )then 
	
		CNT_N_PuntiRottFiloC1 := 0 ;
		
	end_if;

	(*ad ogni segnale di ago algo incremento il contatore*)


	if ( Rise_cnt_giro.q and VN_SYS_PAGE_ID = 1001 )then 
	
	
		CNT_N_PuntiRottFiloC1 := CNT_N_PuntiRottFiloC1+1000;
	
	end_if;
	
	(* se la molla tocca azzero il contatore, se tocca sempre il contatore continuerà a incrementarsi fino a scatenare l'errore*)
	Rise_i18_C1_RotturaFilo ( in:= i18_C1_RotturaFilo );

	if ( Rise_i18_C1_RotturaFilo.q )then 
	
	
		CNT_N_PuntiRottFiloC1 := 0;
	
	end_if;


(* comando stop/hold C1 *)
RiseStopC1(  in := ( VB_CHN_AUTO_RUNNING and not C1_CmdHoldRelease and Vb4090_EnableRotturaFiloC1 and ( CNT_N_PuntiRottFiloC1 >= Vq3560_N_PuntiRottFiloC1 )));
	if ( RiseStopC1.q )then
		C1_CmdHoldHMI := TRUE ;
		//if(CNT_N_PuntiRottFiloC1 >= C1_NumPuntiRottFilo) then
		if(CNT_N_PuntiRottFiloC1 >= Vq3560_N_PuntiRottFiloC1) then
		

			Vn2CodiceAllarmeXHmi := 2;  (*Daniele HMI*)
		end_if;
	end_if;


(* conteggio punti spola *)
	VnDeltaCntGiri_C1 := C1_VnZeroCuci - VnMemCntGiri_C1;
    Rise_cnt_giro (in:= VnDeltaCntGiri_C1 >0);	//serve per rottura filo, non spostarlo da qui

    VnMemCntGiri_C1   := C1_VnZeroCuci;

    Vq3596_ContPuntiSpolaC1 := Vq3596_ContPuntiSpolaC1 + To_Dint( To_Udint( VnDeltaCntGiri_C1 ) );

(* allarme raggiunto numero punti spola *)
RiseAllSpolaC1 ( in:= Vq3596_ContPuntiSpolaC1 >= Vq3597_ImpPuntiSpolaC1 );

	if ( RiseAllSpolaC1.q and Vb4071_AbilitaContSpolaC1 )then
		Vb4072_AllarmeContSpolaC1 := TRUE ; 
		Vn2CodiceAllarmeXHmi := 1;  (*Daniele HMI*)
	end_if;
	
	
(* reset numero punti spola *)
FallAllSpolaC1 ( in:= Vb4072_AllarmeContSpolaC1 );
	if ( FallAllSpolaC1.q and Vb4071_AbilitaContSpolaC1 )then
		Vn2CodiceAllarmeXHmi := 0;  (*Daniele HMI*); 
	end_if;

	if ( FallAllSpolaC1.q or not Vb4071_AbilitaContSpolaC1 )then
		Vq3596_ContPuntiSpolaC1 := 0 ; 
	end_if;
(* blocco allarme se sono disattivato *)
	if (not Vb4071_AbilitaContSpolaC1 )then
		Vb4072_AllarmeContSpolaC1 := FALSE ; 
	end_if;

(* gira ago per spola *)
Rise_Vb4075_GiraAgoFaiSpolaC1 ( in:= Vb4075_GiraAgoFaiSpolaC1 and  Vn3804_PageID = 1002);
Fall_Vb4075_GiraAgoFaiSpolaC1 ( in:= Vb4075_GiraAgoFaiSpolaC1 and  Vn3804_PageID = 1002);

if(Rise_Vb4075_GiraAgoFaiSpolaC1.q) then
	VnVelJogAx3			:=0;
	C1_CmdPiedinoGiu := TRUE;
	Vq108_WRITE_Vel_manualeAgo_C1 := 45000; (*vel spola 55000 = 2500rpm*)
	Vb78SetVelManualeAsseAgo_C1 := TRUE;
	VB_AX3_JOG_PIU := TRUE;
	

end_if;

if(Fall_Vb4075_GiraAgoFaiSpolaC1.q) then
	
	VB_AX3_JOG_PIU := FALSE;
	Vb4088_TestDisableRiposizionaAgo := FALSE;
	Vb4008_AgoSu_C1 := TRUE;  (*lancio comando per far ritornare l'ago in posizione alta*)

end_if;


]]>
					</sourceCode>
				</program>
				<program name="RotturaFilo_Spola_C2" version="1.0.0" creationDate="0" lastModifiedDate="1711621632" excludeFromBuild="FALSE">
					<vars>
						<localVars>
							<var name="FallVb5_C2_InCucitura" type="FallEdge"/>
							<var name="RiseVb5_C2_InCucitura" type="RiseEdge"/>
							<var name="Rise_cnt_giro_C2" type="RiseEdge"/>
							<var name="OLD_ContPuntiRottFiloC2" type="DINT"/>
							<var name="CNT_N_PuntiRottFiloC2" type="DINT"/>
							<var name="RiseStopC2" type="RiseEdge"/>
							<var name="RiseAllSpolaC2" type="RiseEdge"/>
							<var name="FallAllSpolaC2" type="FallEdge"/>
							<var name="NONAME" type="BOOL"/>
							<var name="Rise_Vb4076_GiraAgoFaiSpolaC2" type="RiseEdge"/>
							<var name="Fall_Vb4076_GiraAgoFaiSpolaC2" type="FallEdge"/>
							<var name="Rise_i50_C2_RotturaFilo" type="RiseEdge"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[(* ========================================================================== 
(* SIPRO - Siax M															  	
(*                                                                            
(* COMPANY:     JAM INTERNATIONAL                                             
(*                                                                            
(* NAME: RotturaFile_Spola_C2                                                          
(*
(* TASK MAIN	 
(*
(* DESCRIPTION:  Rottura filo cucitrice 2 
(*
(* NOTE:                                NAME:           VER:    DATE:         
(* -------------------------------------------------------------------------  
(* Prima stesura                        Jam             1.0     29/04/2021    
(* Ultima modifica                                                            
(* ========================================================================== *)
RiseVb5_C2_InCucitura ( in:= Vb5_C2_InCucitura );
FallVb5_C2_InCucitura ( in:= Vb5_C2_InCucitura );

	(* se parto a cucire*)
	if ( RiseVb5_C2_InCucitura.q )then 	 
		 CNT_N_PuntiRottFiloC2 :=0;
	end_if;
	
	(* se mi fermo a cucire*)
	
	if ( FallVb5_C2_InCucitura.q )then 
	
		CNT_N_PuntiRottFiloC2 := 0 ;
		
	end_if;

	(*ad ogni segnale di ago algo incremento il contatore*)


	if ( Rise_cnt_giro_C2.q and VN_SYS_PAGE_ID = 1001 )then 
	
	
		CNT_N_PuntiRottFiloC2 := CNT_N_PuntiRottFiloC2+1000;
	
	end_if;
	
	(* se la molla tocca azzero il contatore, se tocca sempre il contatore continuerà a incrementarsi fino a scatenare l'errore*)
Rise_i50_C2_RotturaFilo ( in:= i50_C2_RotturaFilo );

	if ( Rise_i50_C2_RotturaFilo.q )then 
	
	
		CNT_N_PuntiRottFiloC2 := 0;
	
	end_if;


(* comando stop/hold C1 *)
RiseStopC2(  in := ( VB_CHN2_AUTO_RUNNING and not C2_CmdHoldRelease and Vb4091_EnableRotturaFiloC2 and ( CNT_N_PuntiRottFiloC2 >= Vq3562_N_PuntiRottFiloC2 )));
	if ( RiseStopC2.q )then
		C2_CmdHoldHMI := TRUE ;
		//if(CNT_N_PuntiRottFiloC1 >= C1_NumPuntiRottFilo) then
		if(CNT_N_PuntiRottFiloC2 >= Vq3562_N_PuntiRottFiloC2) then
		

			Vn2CodiceAllarmeXHmi := 38;  (*Daniele HMI*)
		end_if;
	end_if;



(* conteggio punti spola C2*)
	VnDeltaCntGiri_C2 := C2_VnZeroCuci - VnMemCntGiri_C2;
    Rise_cnt_giro_C2 (in:= VnDeltaCntGiri_C2 >0);	//serve per rottura filo, non spostarlo da qui

    VnMemCntGiri_C2   := C2_VnZeroCuci;

    Vq3598_ContPuntiSpolaC2 := Vq3598_ContPuntiSpolaC2 + To_Dint( To_Udint( VnDeltaCntGiri_C2 ) );

(* allarme raggiunto numero punti spola C2 *)
RiseAllSpolaC2 ( in:= Vq3598_ContPuntiSpolaC2 >= Vq3599_ImpPuntiSpolaC2 );

	if ( RiseAllSpolaC2.q and Vb4073_AbilitaContSpolaC2 )then
		Vb4074_AllarmeContSpolaC2 := TRUE ; 

		Vn2CodiceAllarmeXHmi := 37;  (*Daniele HMI*)
	end_if;
	
	
(* reset numero punti spola *)
FallAllSpolaC2 ( in:= Vb4074_AllarmeContSpolaC2 );
	if ( FallAllSpolaC2.q and Vb4073_AbilitaContSpolaC2 )then
		
		Vn2CodiceAllarmeXHmi := 0;  (*Daniele HMI*); 
	end_if;

	if ( FallAllSpolaC2.q or not Vb4073_AbilitaContSpolaC2 )then
		Vq3598_ContPuntiSpolaC2 := 0 ; 
	end_if;
(* blocco allarme se sono disattivato *)
	if (not Vb4073_AbilitaContSpolaC2 )then
		Vb4074_AllarmeContSpolaC2 := FALSE ; 
	end_if;

(* gira ago per spola *)
Rise_Vb4076_GiraAgoFaiSpolaC2 ( in:= Vb4076_GiraAgoFaiSpolaC2 and  Vn3804_PageID = 1002);
Fall_Vb4076_GiraAgoFaiSpolaC2 ( in:= Vb4076_GiraAgoFaiSpolaC2 and  Vn3804_PageID = 1002);

if(Rise_Vb4076_GiraAgoFaiSpolaC2.q) then

	C2_CmdPiedinoGiu := TRUE;
	Vq109_WRITE_Vel_manualeAgo_C2  := 55000; (*vel spola 55000 = 2500rpm*)
	Vb79SetVelManualeAsseAgo_C2 := TRUE;
	VB_AX8_JOG_PIU := TRUE;
	

end_if;

if(Fall_Vb4076_GiraAgoFaiSpolaC2.q) then
	
	VB_AX8_JOG_PIU := FALSE;
	Vb4089_TestDisableRiposizionaAgoC2 := FALSE;
	Vb4009_AgoSu_C2 := TRUE;  (*lancio comando per far ritornare l'ago in posizione alta*)

end_if;











]]>
					</sourceCode>
				</program>
				<program name="Contatori" version="1.0.0" creationDate="0" lastModifiedDate="1701250456" excludeFromBuild="FALSE">
					<vars>
						<localVars>
							<var name="RiseCntCuci1" type="RiseEdge"/>
							<var name="RiseCntCuci2" type="RiseEdge"/>
							<var name="TonTrigTascaCucita" type="Ton"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[(* ========================================================================== 
(* SIPRO - Siax M															  	
(*                                                                            
(* COMPANY:     JAM INTERNATIONAL                                             
(*                                                                            
(* NAME: Contatori                                                          
(*
(* TASK MAIN	 
(*
(* DESCRIPTION:  Contatori produzione
(*
(* NOTE:                                NAME:           VER:    DATE:         
(* -------------------------------------------------------------------------  
(* Prima stesura                        Jam             1.0     29/04/2021    
(* Ultima modifica                                                            
(* ========================================================================== *)

(* in automatico solo cucitrice 1  *)
RiseCntCuci1(  in := Vb88_TascaC1Completata);

(* in automatico solo cucitrice 2  *)
RiseCntCuci2(  in := Vb89_TascaC2Completata);

(* incremento conteggio se ho solo 1 Testa *)
if(RiseCntCuci1.q) then
	Vb88_TascaC1Completata := FALSE;	
	if ( Vb4507_AppManAuto and not Vb4513_AppEnbCucitrice2)then 
		Vb4018_TrigrHMITascaCucita := TRUE;	// x HMI TCP 4.0
		Vq3591_CNT_CicliAutomaticoUser := Vq3591_CNT_CicliAutomaticoUser + 1 ;
		Vq3592_CNT_CicliAutomaticoVita := Vq3592_CNT_CicliAutomaticoVita + 1 ;
		if (Vq3592_CNT_CicliAutomaticoVita >= 100000)then
			Vq3593_CNT_CicliAutomaticoVitaX100K := Vq3593_CNT_CicliAutomaticoVitaX100K + 1 ;
			Vq3592_CNT_CicliAutomaticoVita := 0 ;
		end_if;
	end_if;
end_if;	


(* incremento conteggio se ho 2 teste *)
if(RiseCntCuci2.q) then
	Vb89_TascaC2Completata := FALSE;	
	if ( Vb4507_AppManAuto and Vb4513_AppEnbCucitrice2)then 
		Vb4018_TrigrHMITascaCucita := TRUE;	// x HMI TCP 4.0
		Vq3591_CNT_CicliAutomaticoUser := Vq3591_CNT_CicliAutomaticoUser + 1 ;
		Vq3592_CNT_CicliAutomaticoVita := Vq3592_CNT_CicliAutomaticoVita + 1 ;
		if (Vq3592_CNT_CicliAutomaticoVita >= 100000)then
			Vq3593_CNT_CicliAutomaticoVitaX100K := Vq3593_CNT_CicliAutomaticoVitaX100K + 1 ;
			Vq3592_CNT_CicliAutomaticoVita := 0 ;
		end_if;
	end_if;
end_if;	

(* reset contatore USER *)

	if ( Vb20_ResetContapezziUser )then
		Vq3591_CNT_CicliAutomaticoUser := 0 ;
		Vb20_ResetContapezziUser := FALSE ;
	end_if;

(* spengo la variabile che ha indicato al HMI che la tasca è finita*)
TonTrigTascaCucita (in:= Vb4018_TrigrHMITascaCucita,pt:=1000);
if(TonTrigTascaCucita.q) then
	Vb4018_TrigrHMITascaCucita := FALSE;	
end_if;
]]>
					</sourceCode>
				</program>
				<program name="Timeout_Sensori" version="1.0.0" creationDate="1627283434" lastModifiedDate="1703066814" excludeFromBuild="FALSE">
					<vars>
						<localVars>
							<var name="TonSensPinzaEstOff" type="Ton"/>
							<var name="Rise_Vb4802_PulsResetHmiC1" type="RiseEdge"/>
							<var name="TonSensPinzaIntOn" type="Ton"/>
							<var name="TonSensPinzaEstOn" type="Ton"/>
							<var name="TonSensPinzaIntOff" type="Ton"/>
							<var name="TonSensPinzaCaricoOn" type="Ton"/>
							<var name="TonSensPinzaCaricoOff" type="Ton"/>
							<var name="TonSensPiegAvantiOn" type="Ton"/>
							<var name="TonSensPiegAvantiOff" type="Ton"/>
							<var name="TonSensPiegDietroOn" type="Ton"/>
							<var name="TonSensPiegDietroOff" type="Ton"/>
							<var name="TonSensLanciaDietroOn" type="Ton"/>
							<var name="TonSensLanciaDietroOff" type="Ton"/>
							<var name="TonSensPiegatoreGiu" type="Ton"/>
							<var name="TonSensPiegatoreSu" type="Ton"/>
							<var name="TonSensPinzaIntOn_C2" type="Ton"/>
							<var name="TonSensPinzaIntOff_C2" type="Ton"/>
							<var name="TonSensPinzaTraslOff" type="Ton"/>
							<var name="TonSensPinzaTraslOn" type="Ton"/>
							<var name="FallPiegatoreBasso" type="FallEdge"/>
							<var name="RisePiegatoreGiu" type="RiseEdge"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[(* ========================================================================== 
(* SIPRO - Siax M															  	
(*                                                                            
(* COMPANY:     JAM INTERNATIONAL                                             
(*                                                                            
(* NAME: Contatori                                                          
(*
(* TASK MAIN	 
(*
(* DESCRIPTION:  Timeout sensori
(*
(* NOTE:                                NAME:           VER:    DATE:         
(* -------------------------------------------------------------------------  
(* Prima stesura                        D.A             15.2     26/07/2021    
(* Ultima modifica                                                            
(* ========================================================================== *)
//reset allarme

Rise_Vb4802_PulsResetHmiC1 (in:= Vb4802_PulsResetHmiC1);
if(Rise_Vb4802_PulsResetHmiC1.q and (Vn2CodiceAllarmeXHmi =23 or Vn2CodiceAllarmeXHmi =24)) then
	Vn2CodiceAllarmeXHmi:= 0;
end_if;

//sensore pinza esterna alta non si accende
TonSensPinzaEstOff ( in:=  Vb4351_AppAut_o19_C1_Pinza_est and not i24_C1_PinzaEstAlta , pt := TO_UDINT(Vq3090_TimeoutSensori) ); 
if(TonSensPinzaEstOff.q) then
	Vn2CodiceAllarmeXHmi :=23;
	Vn16GoCuci := 2; //annullo esecuzione cucitura
end_if;


//sensore pinza esterna alta non si spegne
TonSensPinzaEstOn ( in:=  not Vb4351_AppAut_o19_C1_Pinza_est and i24_C1_PinzaEstAlta , pt := TO_UDINT(Vq3090_TimeoutSensori) ); 
if(TonSensPinzaEstOn.q and ( Vb4509_AppEnbPiegatore or Vb4511_AppEnbCaricatore)) then
	Vn2CodiceAllarmeXHmi :=24;
	Vn16GoCuci := 2; //annullo esecuzione cucitura
end_if;

//sensore pinza interna bassa non si accende
TonSensPinzaIntOn ( in:= not Vb4350_AppAut_o18_C1_Pinza_int and not i23_C1_PinzaIntBassa , pt := TO_UDINT(Vq3090_TimeoutSensori) ); 
if(TonSensPinzaIntOn.q and ( Vb4509_AppEnbPiegatore or Vb4511_AppEnbCaricatore)) then
	Vn2CodiceAllarmeXHmi :=25;
	Vn16GoCuci := 2; //annullo esecuzione cucitura
end_if;

//sensore pinza interna bassa non si spegne
TonSensPinzaIntOff ( in:=  Vb4350_AppAut_o18_C1_Pinza_int and  i23_C1_PinzaIntBassa , pt := TO_UDINT(Vq3090_TimeoutSensori) ); 
if(TonSensPinzaIntOff.q and not Vb4507_AppManAuto) then
	Vn2CodiceAllarmeXHmi :=26;
	Vn16GoCuci := 2; //annullo esecuzione cucitura
end_if;

// timeout sensore pinza carico
TonSensPinzaCaricoOn (in:= not Vb4356_AppAut_o24_Pinza_carico_Su_Giu and not i5_FcPinzaCaricoAlta, pt := TO_UDINT(Vq3090_TimeoutSensori) ); 
TonSensPinzaCaricoOff (in:=  Vb4356_AppAut_o24_Pinza_carico_Su_Giu and i5_FcPinzaCaricoAlta, pt := TO_UDINT(Vq3090_TimeoutSensori) ); 
if(TonSensPinzaCaricoOn.q or TonSensPinzaCaricoOff.q) then
	Vn2CodiceAllarmeXHmi :=27;
	Vn16GoCuci := 2; //annullo esecuzione cucitura
end_if;

// timeout sensore piegatore avanti
TonSensPiegAvantiOn (in:= Vb4342_AppAut_o10_Piegatore_AD and not i7_FcPiegatore_AV, pt := TO_UDINT(Vq3090_TimeoutSensori) ); 
TonSensPiegAvantiOff (in:=  not Vb4342_AppAut_o10_Piegatore_AD and  i7_FcPiegatore_AV, pt := TO_UDINT(Vq3090_TimeoutSensori) ); 
if(TonSensPiegAvantiOn.q or TonSensPiegAvantiOff.q) then
	Vn2CodiceAllarmeXHmi :=28;
	Vn16GoCuci := 2; //annullo esecuzione cucitura
end_if;

// timeout sensore piegatore dietro
TonSensPiegDietroOn (in:= not Vb4342_AppAut_o10_Piegatore_AD and not i8_FcPiegatore_DI, pt := TO_UDINT(Vq3090_TimeoutSensori) ); 
TonSensPiegDietroOff (in:=   Vb4342_AppAut_o10_Piegatore_AD and  i8_FcPiegatore_DI, pt := TO_UDINT(Vq3090_TimeoutSensori) ); 
if(TonSensPiegDietroOn.q or TonSensPiegDietroOff.q) then
	Vn2CodiceAllarmeXHmi :=29;
	Vn16GoCuci := 2; //annullo esecuzione cucitura
end_if;

// timeout sensore lancia dietro
TonSensLanciaDietroOn (in:=  not Vb4341_AppAut_o9_Lancia_AD and not i11_FcLancia_DI, pt := TO_UDINT(Vq3090_TimeoutSensori) ); 
TonSensLanciaDietroOff (in:=   Vb4341_AppAut_o9_Lancia_AD and  i11_FcLancia_DI, pt := TO_UDINT(Vq3090_TimeoutSensori) ); 
if(TonSensLanciaDietroOn.q or TonSensLanciaDietroOff.q) then
	Vn2CodiceAllarmeXHmi :=30;
	Vn16GoCuci := 2; //annullo esecuzione cucitura
end_if;



// timeout sensore piegatore basso e piegatore alto (se attivo) 
FallPiegatoreBasso (in:= Vb4343_AppAut_o11_Piegatore_Su_Giu and  VbChn3AutoRun);
RisePiegatoreGiu  (in:= Vb4343_AppAut_o11_Piegatore_Su_Giu and  VbChn3AutoRun);
if(FallPiegatoreBasso.q) then
	PiegatoreStaSalendo := TRUE;
end_if;	

if(RisePiegatoreGiu.q or Vb84PiegatoreRisalito or not i21_Emg) then
	PiegatoreStaSalendo := FALSE;
end_if;


TonSensPiegatoreGiu (in:=  Vb4343_AppAut_o11_Piegatore_Su_Giu and not i9_FcPiegatoreBasso, pt := TO_UDINT(Vq3090_TimeoutSensori) ); 
TonSensPiegatoreSu (in:=   PiegatoreStaSalendo and not Vb84PiegatoreRisalito and Vb85AbilitaSensAltoPieg, pt := TO_UDINT(Vq3090_TimeoutSensori) ); 
if(TonSensPiegatoreGiu.q ) then
	Vn2CodiceAllarmeXHmi :=31;
	Vn16GoCuci := 2; //annullo esecuzione cucitura
end_if;
if(TonSensPiegatoreSu.q ) then
	Vn2CodiceAllarmeXHmi :=32;
	Vn16GoCuci := 2; //annullo esecuzione cucitura
end_if;














//sensore pinza interna bassa non si accende T2
TonSensPinzaIntOn_C2 ( in:= not Vb4382_AppAut_o50_C2_Pinza_int and not i55_C2_FcPinzaIntBassa , pt := TO_UDINT(Vq3090_TimeoutSensori) ); 
if(TonSensPinzaIntOn_C2.q and ( Vb4509_AppEnbPiegatore or Vb4511_AppEnbCaricatore)) then
	Vn2CodiceAllarmeXHmi :=33;
	Vn17GoCuci_C2 := 2; //annullo esecuzione cucitura
end_if;

//sensore pinza interna bassa non si spegne T2
TonSensPinzaIntOff_C2 ( in:=  Vb4382_AppAut_o50_C2_Pinza_int and  i55_C2_FcPinzaIntBassa , pt := TO_UDINT(Vq3090_TimeoutSensori) ); 
if(TonSensPinzaIntOff_C2.q and not Vb4507_AppManAuto) then
	Vn2CodiceAllarmeXHmi :=34;
	Vn17GoCuci_C2 := 2; //annullo esecuzione cucitura
end_if;
//sensore traslatore alto non si accende

TonSensPinzaTraslOff (in:=not Vb4388_AppAut_o56_Pinza_tras_su_giu and not i38_FcPinzaTraslAlta , pt := TO_UDINT(Vq3090_TimeoutSensori) ); 
if(TonSensPinzaTraslOff.q) then
	Vn2CodiceAllarmeXHmi :=35;
	Vn17GoCuci_C2 := 2; //annullo esecuzione cucitura
end_if;


//sensore traslatore alto non si spegne
TonSensPinzaTraslOn ( in:=  Vb4388_AppAut_o56_Pinza_tras_su_giu and i38_FcPinzaTraslAlta , pt := TO_UDINT(Vq3090_TimeoutSensori) ); 
if(TonSensPinzaTraslOn.q and ( Vb4509_AppEnbPiegatore or Vb4511_AppEnbCaricatore)) then
	Vn2CodiceAllarmeXHmi :=36;
	Vn17GoCuci_C2 := 2; //annullo esecuzione cucitura
end_if;
]]>
					</sourceCode>
				</program>
				<program name="CariactorePattine" version="1.0.0" creationDate="1715259170" lastModifiedDate="1715361377" excludeFromBuild="FALSE">
					<vars>
						<localVars>
							<var name="Fall_Vb152KitCarPAttine" type="FallEdge"/>
							<var name="Rise_Vb152KitCarPAttine" type="RiseEdge"/>
							<var name="Fall_Vb157PattinaPassoPasso" type="FallEdge"/>
							<var name="Rise_Vb157PattinaPassoPasso" type="RiseEdge"/>
							<var name="Fall_i21_Emg" type="FallEdge"/>
							<var name="Rise_i21_Emg" type="RiseEdge"/>
							<var name="DelayTimer_50" type="Ton"/>
							<var name="DelayTimer_90" type="Ton"/>
							<var name="Rise_i42_CarPat_Middle_SUGIu" type="RiseEdge"/>
							<var name="Rise_i33_C2_Pedana" type="RiseEdge"/>
							<var name="Rise_i44_CarPat_Tastatore" type="RiseEdge"/>
							<var name="Rise_Vb155LasciaPattina" type="RiseEdge"/>
							<var name="DelayTimer_20" type="Ton"/>
							<var name="Ton_CadutaPattina" type="Ton"/>
							<var name="TON_BLOCCAPATTINA" type="Ton"/>
							<var name="Ton_PartenzaCucitura" type="Ton"/>
							<var name="Rise_Vb4043_SyncSplit" type="RiseEdge"/>
							<var name="Ton_RibaltaPattina" type="Ton"/>
							<var name="Ton_Vb4043_SyncSplit" type="Ton"/>
							<var name="Fall_Vb31_C2_InCucitura" type="FallEdge"/>
							<var name="Ton_timeour_zero" type="Ton"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[(* ========================================================================== 
(* SIPRO - Siax M															  	
(*                                                                            
(* COMPANY:     JAM INTERNATIONAL                                             
(*                                                                            
(* NAME: CaricatorePattine                                                          
(*
(* TASK MAIN	 
(*
(* DESCRIPTION:  CaricatorePattine 
(*
(* NOTE:                                NAME:           VER:    DATE:         
(* -------------------------------------------------------------------------  
(* Prima stesura                        Danielke         1.0     13/04/2024    
(* Ultima modifica                                                            
(* ========================================================================== *)
if(not Vb151EnableCarPattine) then
	Vb152KitCarPAttine := FALSE;
	Vb157PattinaPassoPasso := FALSE;
end_if;

Fall_Vb152KitCarPAttine (in:= Vb152KitCarPAttine);
Rise_Vb152KitCarPAttine (in:= Vb152KitCarPAttine and MacchinaAzzerata);
Fall_Vb157PattinaPassoPasso (in:= Vb157PattinaPassoPasso);
Rise_Vb157PattinaPassoPasso  (in:= Vb157PattinaPassoPasso);
Rise_i42_CarPat_Middle_SUGIu (in:= i42_CarPat_Middle_SUGIu);
Fall_i21_Emg (in:= i21_Emg);
Rise_i21_Emg (in:= i21_Emg);
if(Fall_i21_Emg.q or Rise_i21_Emg.q) then
	Vb157PattinaPassoPasso := FALSE;
	Vb4371_AppAut_o39_CarPat_DCSu := FALSE;
	Vb4370_AppAut_o38_CarPat_DCGiu := FALSE;
	mc_stati_Carica_Pattina :=0;
	
end_if;
if(Rise_Vb157PattinaPassoPasso.q and not Vb152KitCarPAttine) then
	Vb157PattinaPassoPasso := FALSE;
end_if;
DelayTimer_50( in := mc_stati_Carica_Pattina =50, pt := TO_UDINT(Vq3200_Time_Pattina_avanti) );
DelayTimer_90( in := mc_stati_Carica_Pattina =90, pt := TO_UDINT(Vq3202_Time_pinza_blocca_pattin) );
Ton_PartenzaCucitura (in:=	mc_stati_Carica_Pattina =95,pt := TO_UDINT( Vq3203_Ritardo_PartenzaCuciPat));
Ton_BloccaPattina(in:=	Vb4369_AppAut_o37_CarPat_SoffiPattina, pt := TO_UDINT(Vq3201_Time_SoffioPattina));


Rise_i33_C2_Pedana (in:= i33_C2_Pedana);
Rise_i44_CarPat_Tastatore (in:= i44_CarPat_Tastatore);
if(Vb157PattinaPassoPasso and mc_stati_Carica_Pattina>0) then
	Vb158PattinaTestRunning := TRUE;
else
	Vb158PattinaTestRunning := FALSE;	
end_if;	

// se la macchina è azzerata e accendo il tasto pattina ne preparo una
if(Rise_Vb152KitCarPAttine.q and i41_CarPat_Top_SUGIu) then
	Vb153GoCicloCarPAttina:=TRUE;
	Vb154CarInPosAltaOK :=TRUE;
	Vb4366_AppAut_o34_CarPat_FrontBack :=TRUE;
end_if;


// controlli per far partire la macchina a stati
if(Vb152KitCarPAttine)then
	//automatico
	if(not Vb157PattinaPassoPasso) then
		if(Vb153GoCicloCarPAttina  and Vb154CarInPosAltaOK ) then
			Vb153GoCicloCarPAttina := FALSE;
			mc_stati_Carica_Pattina :=1;
		end_if;
	else
	//passo passo
		if(Rise_i33_C2_Pedana.q and mc_stati_Carica_Pattina =0) then
			mc_stati_Carica_Pattina :=1;
		end_if;
	end_if;

end_if;

		

case ( mc_stati_Carica_Pattina) of
	1:	//mando giu le pinze
		if(i45_CarPat_Empty) then
			Vn2CodiceAllarmeXHmi := 40;
			Vb153GoCicloCarPAttina := FALSE;
			mc_stati_Carica_Pattina := 0;
						
		else
		
			Vb4371_AppAut_o39_CarPat_DCSu := FALSE;
			Vb4370_AppAut_o38_CarPat_DCGiu := TRUE;
			mc_stati_Carica_Pattina:=10;
	
		end_if;			
	10:  //aspetto il tastatore e fermo la discesa
		if(Rise_i44_CarPat_Tastatore.q) then
			Vb4370_AppAut_o38_CarPat_DCGiu := FALSE;
			mc_stati_Carica_Pattina := 20;
		end_if;	;
		
		//se spengo automatico pattina
		if(not Vb152KitCarPAttine) then
			mc_stati_Carica_Pattina := 200;
		end_if;		
					
			
	20:	//attivo aghi
			
		Vb4367_AppAut_o35_CarPat_Aghi:= TRUE;
		DelayTimer_20( in := mc_stati_Carica_Pattina =20, pt := 200 );
		if ( DelayTimer_20.q ) then
			mc_stati_Carica_Pattina := 30;
		end_if; 

	
	30: // salgo
		Vb4370_AppAut_o38_CarPat_DCGiu := FALSE;	
		Vb4371_AppAut_o39_CarPat_DCSu := TRUE;
		mc_stati_Carica_Pattina := 40;
		

		
	40: //aspetto tutto alto e fermo il motore
		if(i41_CarPat_Top_SUGIu) then
			Vb4371_AppAut_o39_CarPat_DCSu := FALSE;
			mc_stati_Carica_Pattina := 50;
		end_if;
		
		//se spengo automatico pattina
		if(not Vb152KitCarPAttine) then
			mc_stati_Carica_Pattina := 200;
		end_if;
		
								
	50: //pinze avanti poi aspetto Vq3200_Time_Pattina_avanti
		Vb4366_AppAut_o34_CarPat_FrontBack :=FALSE;
		if ( DelayTimer_50.q ) then
			mc_stati_Carica_Pattina := 52;
		end_if;
		//se spengo automatico pattina
		if(not Vb152KitCarPAttine) then
			mc_stati_Carica_Pattina := 200;
		end_if;
		
	52://scendo fino al sensore medio
		Vb4371_AppAut_o39_CarPat_DCSu := FALSE;
		Vb4370_AppAut_o38_CarPat_DCGiu :=TRUE;
		mc_stati_Carica_Pattina := 55;
		
	55:	
		if(Rise_i42_CarPat_Middle_SUGIu.q or i43_CarPat_Bottom_SUGIu) then
			Vb4370_AppAut_o38_CarPat_DCGiu := FALSE;
			mc_stati_Carica_Pattina := 60;
		end_if;
		//se spengo automatico pattina
		if(not Vb152KitCarPAttine) then
			mc_stati_Carica_Pattina := 200;
		end_if;		
		
		
	60:	//aspetto che il programma udf è arrivato sul primo punto (sarebbe il punto dove devo lasciare la pattina)	
		if( i55_C2_FcPinzaIntBassa and Vb155LasciaPattina) then
			
				Vb155LasciaPattina := FALSE;
				mc_stati_Carica_Pattina := 70;
		end_if;
			
		//se spengo automatico pattina
		if(not Vb152KitCarPAttine) then
			mc_stati_Carica_Pattina := 200;
		end_if;		
		
	70: // scendo fino al sensore basso
		Vb4371_AppAut_o39_CarPat_DCSu := FALSE;
		Vb4370_AppAut_o38_CarPat_DCGiu :=TRUE;
		if(i43_CarPat_Bottom_SUGIu) then
			Vb4370_AppAut_o38_CarPat_DCGiu := FALSE;
			mc_stati_Carica_Pattina := 80;
		end_if;
		//se spengo automatico pattina
		if(not Vb152KitCarPAttine) then
			mc_stati_Carica_Pattina := 200;
		end_if;		
				
		
	80:	//lascio la pattina e soffio
		Vb4367_AppAut_o35_CarPat_Aghi := FALSE;			//lascio aghi
		Vb4368_AppAut_o36_CarPat_SoffioAghi := TRUE;		//attivo soffio pinze aghi
		Vb4369_AppAut_o37_CarPat_SoffiPattina := TRUE;		//attivo tubi soffi
			
		mc_stati_Carica_Pattina := 85;
		
	85: //aspetto che i soffi tengono la pattina bassa e poi faccio avanzare la pinza blocca pattina
	
		if(Ton_BloccaPattina.q) then  //Vq3201_Time_SoffioPattina
			Vb4383_AppAut_o51_PinzaPattina_1 := TRUE;
			mc_stati_Carica_Pattina := 90;
		end_if;
		
				
	
	90: //tempo per far avanzare la pinza blocca pattina della dima
			if ( DelayTimer_90.q ) then	//Vq3202_Time_pinza_blocca_pattin
			Vb4368_AppAut_o36_CarPat_SoffioAghi := FALSE;    //spengo soffi pinza aghi
			Vb4369_AppAut_o37_CarPat_SoffiPattina := FALSE;		//spengo tubisoffi
			
			Vb4370_AppAut_o38_CarPat_DCGiu := FALSE;	//pulisco
			Vb4371_AppAut_o39_CarPat_DCSu := TRUE;		//faccio salire il caricatore
			
			mc_stati_Carica_Pattina := 95;
		end_if; 
		//se spengo automatico pattina
		if(not Vb152KitCarPAttine) then
			mc_stati_Carica_Pattina := 200;
		end_if;		
		
 	95:// dopo che la prima pinza ha bloccato la pattina, parto a cucire per la prima cucitura
		if(Ton_PartenzaCucitura.q) then   //Vq3203_Ritardo_PartenzaCuciPat
			Vb160PartiACucire := TRUE;
			mc_stati_Carica_Pattina := 110;
		end_if;
		
		// il caricatore sta salendo, se arriva in alto lo fermo
		if(i41_CarPat_Top_SUGIu) then
			Vb4371_AppAut_o39_CarPat_DCSu := FALSE;		
		end_if;	
				
		
	110: //aspetto che arriva in alto
		if(i41_CarPat_Top_SUGIu) then
			Vb4371_AppAut_o39_CarPat_DCSu := FALSE;		
			mc_stati_Carica_Pattina := 120;			
		end_if;			
		
	120:// pinze in dietro
		Vb4366_AppAut_o34_CarPat_FrontBack := TRUE;
		mc_stati_Carica_Pattina := 130;			
	
	130: //aspetto sensore pinze in dietro
		if(i46_CarPat_BackPos) then
		
			if(Vb152KitCarPAttine and not Vb157PattinaPassoPasso) then
				Vb154CarInPosAltaOK := TRUE;
				mc_stati_Carica_Pattina := 1;	//torno in cima e carico un'altra pattina
			else
			
				Vb154CarInPosAltaOK := TRUE;	//se ero in test mi fermo
				Vb157PattinaPassoPasso := FALSE;
				mc_stati_Carica_Pattina := 0;
			end_if;		
		end_if;	
		
	//*** Reset Piattina
	200:
		Vb4367_AppAut_o35_CarPat_Aghi := FALSE;
		Vb4368_AppAut_o36_CarPat_SoffioAghi := FALSE;
		Vb4369_AppAut_o37_CarPat_SoffiPattina := FALSE;	
		Vb4371_AppAut_o39_CarPat_DCSu := TRUE;
		Vb4370_AppAut_o38_CarPat_DCGiu := FALSE;
		Vb157PattinaPassoPasso := FALSE;
		mc_stati_Carica_Pattina := 100;

								
									
else
	mc_stati_Carica_Pattina := 0; 
	
end_case;
		


// 4 sono fermo al secondo split, riapro la pinza 1
Rise_Vb4043_SyncSplit (in:= Vb4043_SyncSplit2);
if(Rise_Vb4043_SyncSplit.q) then
	Vb4383_AppAut_o51_PinzaPattina_1 := FALSE;
end_if;

// 5 chiudo la pinza 2 
Ton_RibaltaPattina (in:= (Vb4043_SyncSplit2 and not Vb4383_AppAut_o51_PinzaPattina_1),pt := TO_UDINT( Vq3204_Ritardo_PiegaturaPat));
if(Ton_RibaltaPattina.q) then
	Vb4384_AppAut_o52_PinzaPattina_2:=TRUE;
end_if;

// 6 riparto per la seconda cucitura
Ton_Vb4043_SyncSplit 	(in:=	(Vb4384_AppAut_o52_PinzaPattina_2 and not Vb4383_AppAut_o51_PinzaPattina_1) ,pt := TO_UDINT(Vq3205_Ritardo_SecondaCuciPat));
if(Ton_Vb4043_SyncSplit.q) then
	Vb4043_SyncSplit2 := FALSE;		//riparte seconda cucitura
end_if;

// 7 alla fine della cucitura pulisco
Fall_Vb31_C2_InCucitura (in:= Vb31_C2_InCucitura);
if(Fall_Vb31_C2_InCucitura.q) then
	Vb4384_AppAut_o52_PinzaPattina_2:=FALSE;
	Vb155LasciaPattina:=FALSE;
end_if;


/* timeout */


//caricatore suposizione iniziale
Ton_timeour_zero ( in:= Vb151EnableCarPattine and  Vb4371_AppAut_o39_CarPat_DCSu and not Vb154CarInPosAltaOK , pt := 5000 ); 
if(Ton_timeour_zero.q) then
		if(Vn3804_PageID = 0) then		//pagina emergenza
		Vn4CodiceWarning := 4;
	end_if;
	
end_if;
]]>
					</sourceCode>
				</program>
			</programs>
			<macros/>
			<structs/>
			<typedefs/>
			<enums/>
			<subranges/>
			<interfaces/>
		</main>
		<target id="SiaxM32_1p0" name="Cuci.tgt" fullXml="false">
			<![CDATA[  (********************************)
  (*****  Variabili globali *****)
  (********************************)


RESOURCE SiaxM32 ON ColdFire

    TASK Main  ( INTERVAL := t#0ms, PRIORITY := 0 );
    TASK Boot  ( INTERVAL := t#0ms, PRIORITY := 1 );
    TASK RtcAx ( INTERVAL := t#0ms, PRIORITY := 2 );

END_RESOURCE

VAR_GLOBAL

    {G:"Cnc Shared Variables"}
    sysTimer        AT %MD0.0 : UDINT;      { DE:"System timer 1 KHz"}
    din             AT %IX100.0 : ARRAY[ 0..511 ] OF BOOL; {DE:"Digital Inputs"}
    dout            AT %QX200.0 : ARRAY[ 0..511 ] OF BOOL; {DE:"Digital Outputs"}
    vb              AT %MB300.0 : ARRAY[ 0..8191 ] OF BOOL; {DE:"VB[]"}
    vn              AT %MW400.0 : ARRAY[ 0..4095 ] OF INT;  {DE:"VN[]"}
    vq              AT %MD500.0 : ARRAY[ 0..8191 ] OF DINT; {DE:"VQ[]"}
    vd              AT %ML600.0 : ARRAY[ 0..255 ] OF LREAL; {DE:"VD[]"}
    va0             AT %MB700.0 : STRING[ 80 ]; {DE:"va0"}
    va1             AT %MB700.1 : STRING[ 80 ]; {DE:"va1"}
    va2             AT %MB700.2 : STRING[ 80 ]; {DE:"va2"}
    va3             AT %MB700.3 : STRING[ 80 ]; {DE:"va3"}
    va4             AT %MB700.4 : STRING[ 80 ]; {DE:"va4"}
    va5             AT %MB700.5 : STRING[ 80 ]; {DE:"va5"}
    va6             AT %MB700.6 : STRING[ 80 ]; {DE:"va6"}
    va7             AT %MB700.7 : STRING[ 80 ]; {DE:"va7"}
    va8             AT %MB700.8 : STRING[ 80 ]; {DE:"va8"}
    va9             AT %MB700.9 : STRING[ 80 ]; {DE:"va9"}
    va10            AT %MB700.10: STRING[ 80 ]; {DE:"va10"}
    va11            AT %MB700.11: STRING[ 80 ]; {DE:"va11"}
    va12            AT %MB700.12: STRING[ 80 ]; {DE:"va12"}
    va13            AT %MB700.13: STRING[ 80 ]; {DE:"va13"}
    va14            AT %MB700.14: STRING[ 80 ]; {DE:"va14"}
    va15            AT %MB700.15: STRING[ 80 ]; {DE:"va15"}
    va16            AT %MB700.16: STRING[ 80 ]; {DE:"va16"}
    va17            AT %MB700.17: STRING[ 80 ]; {DE:"va17"}
    va18            AT %MB700.18: STRING[ 80 ]; {DE:"va18"}
    va19            AT %MB700.19: STRING[ 80 ]; {DE:"va19"}
    va20            AT %MB700.20: STRING[ 80 ]; {DE:"va20"}
    va21            AT %MB700.21: STRING[ 80 ]; {DE:"va21"}
    va22            AT %MB700.22: STRING[ 80 ]; {DE:"va22"}
    va23            AT %MB700.23: STRING[ 80 ]; {DE:"va23"}
    va24            AT %MB700.24: STRING[ 80 ]; {DE:"va24"}
    va25            AT %MB700.25: STRING[ 80 ]; {DE:"va25"}
    va26            AT %MB700.26: STRING[ 80 ]; {DE:"va26"}
    va27            AT %MB700.27: STRING[ 80 ]; {DE:"va27"}
    va28            AT %MB700.28: STRING[ 80 ]; {DE:"va28"}
    va29            AT %MB700.29: STRING[ 80 ]; {DE:"va29"}
    va30            AT %MB700.30: STRING[ 80 ]; {DE:"va30"}
    va31            AT %MB700.31: STRING[ 80 ]; {DE:"va31"}
    va32            AT %MB700.32: STRING[ 80 ]; {DE:"va32"}
    va33            AT %MB700.33: STRING[ 80 ]; {DE:"va33"}
    va34            AT %MB700.34: STRING[ 80 ]; {DE:"va34"}
    va35            AT %MB700.35: STRING[ 80 ]; {DE:"va35"}
    va36            AT %MB700.36: STRING[ 80 ]; {DE:"va36"}
    va37            AT %MB700.37: STRING[ 80 ]; {DE:"va37"}
    va38            AT %MB700.38: STRING[ 80 ]; {DE:"va38"}
    va39            AT %MB700.39: STRING[ 80 ]; {DE:"va39"}
    va40            AT %MB700.40: STRING[ 80 ]; {DE:"va40"}
    va41            AT %MB700.41: STRING[ 80 ]; {DE:"va41"}
    va42            AT %MB700.42: STRING[ 80 ]; {DE:"va42"}
    va43            AT %MB700.43: STRING[ 80 ]; {DE:"va43"}
    va44            AT %MB700.44: STRING[ 80 ]; {DE:"va44"}
    va45            AT %MB700.45: STRING[ 80 ]; {DE:"va45"}
    va46            AT %MB700.46: STRING[ 80 ]; {DE:"va46"}
    va47            AT %MB700.47: STRING[ 80 ]; {DE:"va47"}
    va48            AT %MB700.48: STRING[ 80 ]; {DE:"va48"}
    va49            AT %MB700.49: STRING[ 80 ]; {DE:"va49"}
    va50            AT %MB700.50: STRING[ 80 ]; {DE:"va50"}
    va51            AT %MB700.51: STRING[ 80 ]; {DE:"va51"}
    va52            AT %MB700.52: STRING[ 80 ]; {DE:"va52"}
    va53            AT %MB700.53: STRING[ 80 ]; {DE:"va53"}
    va54            AT %MB700.54: STRING[ 80 ]; {DE:"va54"}
    va55            AT %MB700.55: STRING[ 80 ]; {DE:"va55"}
    va56            AT %MB700.56: STRING[ 80 ]; {DE:"va56"}
    va57            AT %MB700.57: STRING[ 80 ]; {DE:"va57"}
    va58            AT %MB700.58: STRING[ 80 ]; {DE:"va58"}
    va59            AT %MB700.59: STRING[ 80 ]; {DE:"va59"}
    va60            AT %MB700.60: STRING[ 80 ]; {DE:"va60"}
    va61            AT %MB700.61: STRING[ 80 ]; {DE:"va61"}
    va62            AT %MB700.62: STRING[ 80 ]; {DE:"va62"}
    va63            AT %MB700.63: STRING[ 80 ]; {DE:"va63"}

END_VAR

        (*********************)
        (*                   *)
        (*     FUNCTIONS     *)
        (* 23.09.2011        *)
        (*********************)

FUNCTION ExecPlcFun : DINT

{ DE:"Execute a PLC function" }

    VAR_INPUT
        FunCode : DINT; { DE:"Function Code" } 
        Par1    : INT; { DE:"Parameter 1" } 
        Par2    : INT; { DE:"Parameter 2" }
    END_VAR

    { CODE:EMBEDDED }
END_FUNCTION


FUNCTION DinToWord : INT

    VAR_INPUT
        DiNum : DINT;
    END_VAR

    { CODE:EMBEDDED }
END_FUNCTION


FUNCTION WordToDin : DINT

    VAR_INPUT
        DiNum : DINT;
        ShVal : INT;
    END_VAR

    { CODE:EMBEDDED }
END_FUNCTION


FUNCTION DinToLong : DINT

    VAR_INPUT
        DiNum : DINT;
    END_VAR

    { CODE:EMBEDDED }
END_FUNCTION


FUNCTION LongToDin : DINT

    VAR_INPUT
        DiNum : DINT;
        LgVal : UDINT;
    END_VAR

    { CODE:EMBEDDED }
END_FUNCTION


FUNCTION DoutToWord : INT

    VAR_INPUT
        DoNum : DINT;
    END_VAR

    { CODE:EMBEDDED }
END_FUNCTION


FUNCTION WordToDout : DINT

    VAR_INPUT
        DoNum : DINT;
        ShVal : INT;
    END_VAR

    { CODE:EMBEDDED }
END_FUNCTION


FUNCTION DoutToLong : DINT

    VAR_INPUT
        DoNum : DINT;
    END_VAR

    { CODE:EMBEDDED }
END_FUNCTION


FUNCTION LongToDout : DINT

    VAR_INPUT
        DoNum : DINT;
        LgVal : UDINT;
    END_VAR

    { CODE:EMBEDDED }
END_FUNCTION


FUNCTION VbToWord : INT

    VAR_INPUT
        VbIdx : DINT;
    END_VAR

    { CODE:EMBEDDED }
END_FUNCTION


FUNCTION WordToVb : DINT

    VAR_INPUT
        VbIdx : DINT;
        ShVal : INT;
    END_VAR

    { CODE:EMBEDDED }
END_FUNCTION


FUNCTION Strncpy : DINT

{ DE:"Copies the first NumChar characters of source to destination." }

    VAR_INPUT
        StrDst  : STRING; { DE:"Destination string" }	
        StrSrc  : STRING; { DE:"Source string" }
        NumChar : INT; { DE:"Number of characters" }
    END_VAR

    { CODE:EMBEDDED }
END_FUNCTION


FUNCTION Strncmp : DINT

{ DE:"Compares up to NumChar characters of the string StrSrc to those of the string StrDst. 
Returns an integral value indicating the relationship between the strings:
   < 0  the first character that does not match has a lower value in StrDst than in StrSrc 
   = 0  the contents of both strings are equal
   > 0  the first character that does not match has a greater value in StrDst than in StrSrc" }

    VAR_INPUT
        StrDst  : STRING; { DE:"Destination string" }
        StrSrc  : STRING; { DE:"Source string" }
        NumChar : INT; { DE:"Number of characters" }
    END_VAR

    { CODE:EMBEDDED }
END_FUNCTION


FUNCTION Strncat : DINT

{ DE:"Appends the first num characters of source to destination, plus a terminating null-character." }

    VAR_INPUT
        StrDst  : STRING; { DE:"Destination string" }
        StrSrc  : STRING; { DE:"Source string" }
        NumChar : INT; { DE:"Maximum number of characters to be appended" }
    END_VAR

    { CODE:EMBEDDED }
END_FUNCTION


FUNCTION Strcpy : DINT

{ DE:"Copies all characters of source to destination." }

    VAR_INPUT
        StrDst  : STRING; { DE:"Destination string" }
        StrSrc  : STRING; { DE:"Source string" }
    END_VAR

    { CODE:EMBEDDED }
END_FUNCTION


FUNCTION Stricmp : DINT

{ DE:"Compares the string StrSrc to the string StrDst.
Comparison is case insensitive" }

    VAR_INPUT
        StrDst  : STRING; { DE:"Destination string" }
        StrSrc  : STRING; { DE:"Source string" }
    END_VAR

    { CODE:EMBEDDED }
END_FUNCTION



        (***************************)
        (*                         *)
        (*     FUNCTION BLOCKS     *)
        (*                         *)
        (***************************)

(* #M121025_1LL# *)
(* Aggiunti i function blocks TonL, ToffL, TmonoL e TpulseL *)

FUNCTION_BLOCK TonL

{ DE:"ON delay timer Ld
      Suitable for ladder language" }

    VAR
        start  : UDINT;
        mem    : BOOL;
        dummy1 : BOOL;
    END_VAR

    VAR_INPUT
        in     : BOOL  := FALSE; { DE:"Condition" }
(*      dummy2 : BOOL;      *)
        pt     : UDINT := 0; { DE:"Time [ms]" }
    END_VAR

    VAR_OUTPUT
        q      : BOOL  := FALSE; { DE:"Output" } 
(*      dummy3 : BOOL;      *)
        et     : UDINT := 0; { DE:"Elapsed time [ms]" }
    END_VAR

    { CODE:EMBEDDED }
END_FUNCTION_BLOCK

FUNCTION_BLOCK ToffL

{ DE:"OFF delay timer Ld
      Suitable for ladder language" }


    VAR
        start  : UDINT;
        mem    : BOOL;
        dummy1 : BOOL;
    END_VAR

    VAR_INPUT
        in     : BOOL  := FALSE; { DE:"Condition" }
(*      dummy2 : BOOL;      *)
        pt     : UDINT := 0; { DE:"Time [ms]" }
    END_VAR

    VAR_OUTPUT
        q      : BOOL  := FALSE; { DE:"Output" }
(*      dummy3 : BOOL;      *)
        et     : UDINT := 0; { DE:"Elapsed time [ms]" }
    END_VAR

    { CODE:EMBEDDED }
END_FUNCTION_BLOCK


FUNCTION_BLOCK TmonoL

{ DE:"Monostable Ld
      Suitable for ladder language" }


    VAR
        start  : UDINT;
        mem    : BOOL;
        inprec : BOOL := FALSE;
    END_VAR

    VAR_INPUT
        in     : BOOL  := FALSE; { DE:"Condition" }
(*      dummy2 : BOOL;      *)
        pt     : UDINT := 0; { DE:"Time [ms]" }
    END_VAR

    VAR_OUTPUT
        q      : BOOL  := FALSE; { DE:"Output" }
(*      dummy3 : BOOL;      *)
        et     : UDINT := 0; { DE:"Elapsed time [ms]" }
    END_VAR

    { CODE:EMBEDDED }
END_FUNCTION_BLOCK


FUNCTION_BLOCK TpulseL

{ DE:"Pulse generator Ld
      Suitable for ladder language" }


    VAR
        start  : UDINT;
        mem    : BOOL;
        dummy1 : BOOL;
    END_VAR

    VAR_INPUT
        in     : BOOL  := FALSE; { DE:"Condition" }
(*      dummy2 : BOOL;      *)
        pt     : UDINT := 0; { DE:"Time [ms]" }
    END_VAR

    VAR_OUTPUT
        q      : BOOL  := FALSE; { DE:"Output" }
(*      dummy3 : BOOL;      *)
        et     : UDINT := 0; { DE:"Elapsed time [ms]" }
    END_VAR

    { CODE:EMBEDDED }
END_FUNCTION_BLOCK



FUNCTION_BLOCK Ton

{ DE:"ON delay timer
      
      Example:
      Timer( in := <condition>, pt := <ms> );" }

    VAR
        start  : UDINT;
        mem    : BOOL;
        dummy1 : BOOL;
    END_VAR

    VAR_INPUT
        in     : BOOL  := FALSE; { DE:"Condition" }
(*      dummy2 : BOOL;      *)
        pt     : UDINT := 0; { DE:"Time [ms]" }
    END_VAR

    VAR_OUTPUT
        et     : UDINT := 0; { DE:"Elapsed time [ms]" }
        q      : BOOL  := FALSE; { DE:"Output" }
(*      dummy3 : BOOL;      *)
    END_VAR

    { CODE:EMBEDDED }
END_FUNCTION_BLOCK


FUNCTION_BLOCK Toff

{ DE:"OFF delay timer
      
      Example:
      Timer( in := <condition>, pt := <ms> );" }


    VAR
        start  : UDINT;
        mem    : BOOL;
        dummy1 : BOOL;
    END_VAR

    VAR_INPUT
        in     : BOOL  := FALSE; { DE:"Condition" }
(*      dummy2 : BOOL;      *)
        pt     : UDINT := 0; { DE:"Time [ms]" }
    END_VAR

    VAR_OUTPUT
        et     : UDINT := 0; { DE:"Elapsed time [ms]" }
        q      : BOOL  := FALSE; { DE:"Output" }
(*      dummy3 : BOOL;      *)
    END_VAR

    { CODE:EMBEDDED }
END_FUNCTION_BLOCK


FUNCTION_BLOCK Tmono

{ DE:"Monostable
      
      Example:
      Timer( in := <condition>, pt := <ms> );" }


    VAR
        start  : UDINT;
        mem    : BOOL;
        inprec : BOOL := FALSE;
    END_VAR

    VAR_INPUT
        in     : BOOL  := FALSE; { DE:"Condition" }
(*      dummy2 : BOOL;      *)
        pt     : UDINT := 0; { DE:"Time [ms]" }
    END_VAR

    VAR_OUTPUT
        et     : UDINT := 0; { DE:"Elapsed time [ms]" }
        q      : BOOL  := FALSE; { DE:"Output" }
(*      dummy3 : BOOL;      *)
    END_VAR

    { CODE:EMBEDDED }
END_FUNCTION_BLOCK


FUNCTION_BLOCK Tpulse

{ DE:"Pulse generator
      
      Example:
      Timer( in := <condition>, pt := <ms> );" }


    VAR
        start  : UDINT;
        mem    : BOOL;
        dummy1 : BOOL;
    END_VAR

    VAR_INPUT
        in     : BOOL  := FALSE; { DE:"Condition" }
(*      dummy2 : BOOL;      *)
        pt     : UDINT := 0; { DE:"Time [ms]" }
    END_VAR

    VAR_OUTPUT
        et     : UDINT := 0; { DE:"Elapsed time [ms]" }
        q      : BOOL  := FALSE; { DE:"Output" }
(*      dummy3 : BOOL;      *)
    END_VAR

    { CODE:EMBEDDED }
END_FUNCTION_BLOCK


FUNCTION_BLOCK RiseEdge

{ DE:"Rise edge
      
      Example:
      Var( in := <condition> );" }


    VAR
        mem    : BOOL;
        inprec : BOOL;
    END_VAR

    VAR_INPUT
        in     : BOOL; { DE:"Condition" }
    END_VAR

    VAR_OUTPUT
        q      : BOOL; { DE:"Output" }
    END_VAR

    { CODE:EMBEDDED }
END_FUNCTION_BLOCK


FUNCTION_BLOCK FallEdge

{ DE:"Fall edge
      
      Example:
      Var( in := <condition> );" }


    VAR
        mem    : BOOL;
        inprec : BOOL;
    END_VAR

    VAR_INPUT
        in     : BOOL; { DE:"Condition" }
    END_VAR

    VAR_OUTPUT
        q      : BOOL; { DE:"Output" }
    END_VAR

    { CODE:EMBEDDED }
END_FUNCTION_BLOCK


]]>
		</target>
		<libraries>
			<lib name="c:\program files (x86)\sipro\siax pc tools\catalog\siaxm32\PLC\Ax1_4_v1.pll" fullXml="false" link="true">
				<![CDATA[(*
 *
 * MDPlc source file: Ax1_4_v1.pll
 * for project:
 * 20.04.2012 - s.v.
 *)


VAR_GLOBAL

    {G:"AXIS-1 Variables"}

    VB_AX1_JOG_PIU            AT %MB300.7001 : BOOL; {DE:"vb7001 Ax1 Jog+"}
    VB_AX1_JOG_MENO           AT %MB300.7002 : BOOL; {DE:"vb7002 Ax1 Jog-"}
    VB_AX1_JOG_INCR_PIU       AT %MB300.7003 : BOOL; {DE:"vb7003 Ax1 Incremental Jog+"}
    VB_AX1_JOG_INCR_MENO      AT %MB300.7004 : BOOL; {DE:"vb7004 Ax1 Incremental Jog-"}
    VB_AX1_START_SEMI         AT %MB300.7005 : BOOL; {DE:"vb7005 Ax1 Start Semi-automatic"}
    VB_AX1_START_ZERO         AT %MB300.7006 : BOOL; {DE:"vb7006 Ax1 Start Zero"}
    VB_AX1_PID_DISAB          AT %MB300.7007 : BOOL; {DE:"vb7007 Ax1 PID disable"}
    VB_AX1_START_DISAB        AT %MB300.7008 : BOOL; {DE:"vb7008 Ax1 Start disable"}
    VB_AX1_MOVE_DISAB         AT %MB300.7009 : BOOL; {DE:"vb7009 Ax1 Move disable"}
    VB_AX1_RAPIDO_FEED        AT %MB300.7010 : BOOL; {DE:"vb7010 Ax1 Use Fast Feed Vq"}
    VB_AX1_BOB_INV_DIR        AT %MB300.7011 : BOOL; {DE:"vb7011 Ax1 Reverse winder direction"}
    VB_AX1_GET_ORIG           AT %MB300.7012 : BOOL; {DE:"vb7012 Ax1 Enable origin acquisition"}
    VB_AX1_ZEROED             AT %MB300.7013 : BOOL; {DE:"vb7013 Ax1 Zeroed"}
    VB_AX1_IN_QUOTE           AT %MB300.7014 : BOOL; {DE:"vb7014 Ax1 In position"}
    VB_AX1_START_TST_VEL      AT %MB300.7015 : BOOL; {DE:"vb7015 Ax1 Start Speed Test"}
    VB_AX1_IN_TEST            AT %MB300.7016 : BOOL; {DE:"vb7016 Ax1 In Test Mode"}
    VB_AX1_USE_QUO_JOG        AT %MB300.7017 : BOOL; {DE:"vb7017 Ax1 Jog: use specific Vq"}

    VN_AX1_OVERRIDE           AT %MW400.3001 : INT;  {DE:"vn3001 Ax1 Indipendent Override"}
    VN_AX1_VEL_PERC_JOG       AT %MW400.3002 : INT;  {DE:"vn3002 Ax1 Jog Speed %"}
    VN_AX1_FOLL_MODE          AT %MW400.3003 : INT;  {DE:"vn3003 Ax1 Follow mode"}
    VN_AX1_FOLL_CONF          AT %MW400.3004 : INT;  {DE:"vn3004 Ax1 Follow configuration"}
    VN_AX1_FOLL_MASTER_NUM    AT %MW400.3005 : INT;  {DE:"vn3005 Ax1 N. of encoder to follow"}
    VN_AX1_FOLL_ERR           AT %MW400.3006 : INT;  {DE:"vn3006 Ax1 Follow functions error code"}
    VN_AX1_CMD_DRIVE          AT %MW400.3007 : INT;  {DE:"vn3007 Ax1 Control word to digital drive (bit)"}
    VN_AX1_VEL_PERC_SEMI      AT %MW400.3009 : INT;  {DE:"vn3009 Ax1 Semi-automatic Speed %"}
    VN_AX1_VEL_PERC_TST_VEL   AT %MW400.3010 : INT;  {DE:"vn3010 Ax1 Speed-Test speed %"}
    VN_AX1_FASE_ZERO          AT %MW400.3011 : INT;  {DE:"vn3011 Ax1 Reset phase"}
    VN_AX1_FASE               AT %MW400.3012 : INT;  {DE:"vn3012 Ax1 Phase"}
    VN_AX1_STATO              AT %MW400.3013 : INT;  {DE:"vn3013 Ax1 Status (bit)"}
    VN_AX1_STATO_ISO          AT %MW400.3014 : INT;  {DE:"vn3014 Ax1 ISO status (bit)"}
    VN_AX1_STATO_DRIVE        AT %MW400.3015 : INT;  {DE:"vn3015 Ax1 Status word from digital drive (bit)"}

    VQ_AX1_INCR_JOG           AT %MD500.7001 : DINT; {DE:"vq7001 Ax1 Jog increase"}
    VQ_AX1_QUO_SEMI           AT %MD500.7002 : DINT; {DE:"vq7002 Ax1 Semi-automatic position"}
    VQ_AX1_FEED_JOG           AT %MD500.7003 : DINT; {DE:"vq7003 Ax1 Jog Feed [mm/min]"}
    VQ_AX1_FOLL_NUM           AT %MD500.7004 : DINT; {DE:"vq7004 Ax1 Follow factor numerator"}
    VQ_AX1_FOLL_DEN           AT %MD500.7005 : DINT; {DE:"vq7005 Ax1 Follow factor denominator"}
    VQ_AX1_BOB_AVA            AT %MD500.7006 : DINT; {DE:"vq7006 Ax1 Reversing forward Threshold"}
    VQ_AX1_BOB_IND            AT %MD500.7007 : DINT; {DE:"vq7007 Ax1 Reversing backward Threshold"}
    VQ_AX1_FEED_SEMI          AT %MD500.7011 : DINT; {DE:"vq7011 Ax1 Jog and Semi-automatic Feed"}
    VQ_AX1_CUR_FEED           AT %MD500.7012 : DINT; {DE:"vq7012 Ax1 Instantaneous Speed Theoretical module"}
    VQ_AX1_VEL_RIF_IMP_S      AT %MD500.7013 : DINT; {DE:"vq7013 Ax1 Speed Test result"}
    VQ_AX1_MONITOR_1          AT %MD500.7014 : DINT; {DE:"vq7014 Ax1 Monitor 1        "}
    VQ_AX1_MONITOR_2          AT %MD500.7015 : DINT; {DE:"vq7015 Ax1 Monitor 2        "}
    
    {G:"AXIS-2 Variables"}

    VB_AX2_JOG_PIU            AT %MB300.7021 : BOOL; {DE:"vb7021 Ax2 Jog+"}
    VB_AX2_JOG_MENO           AT %MB300.7022 : BOOL; {DE:"vb7022 Ax2 Jog-"}
    VB_AX2_JOG_INCR_PIU       AT %MB300.7023 : BOOL; {DE:"vb7023 Ax2 Incremental Jog+"}
    VB_AX2_JOG_INCR_MENO      AT %MB300.7024 : BOOL; {DE:"vb7024 Ax2 Incremental Jog-"}
    VB_AX2_START_SEMI         AT %MB300.7025 : BOOL; {DE:"vb7025 Ax2 Start Semi-automatic"}
    VB_AX2_START_ZERO         AT %MB300.7026 : BOOL; {DE:"vb7026 Ax2 Start Zero"}
    VB_AX2_PID_DISAB          AT %MB300.7027 : BOOL; {DE:"vb7027 Ax2 PID disable"}
    VB_AX2_START_DISAB        AT %MB300.7028 : BOOL; {DE:"vb7028 Ax2 Start disable"}
    VB_AX2_MOVE_DISAB         AT %MB300.7029 : BOOL; {DE:"vb7029 Ax2 Move disable"}
    VB_AX2_RAPIDO_FEED        AT %MB300.7030 : BOOL; {DE:"vb7030 Ax2 Use Fast Feed Vq"}
    VB_AX2_BOB_INV_DIR        AT %MB300.7031 : BOOL; {DE:"vb7031 Ax2 Reverse winder direction"}
    VB_AX2_GET_ORIG           AT %MB300.7032 : BOOL; {DE:"vb7032 Ax2 Enable origin acquisition"}
    VB_AX2_ZEROED             AT %MB300.7033 : BOOL; {DE:"vb7033 Ax2 Zeroed"}
    VB_AX2_IN_QUOTE           AT %MB300.7034 : BOOL; {DE:"vb7034 Ax2 In position"}
    VB_AX2_START_TST_VEL      AT %MB300.7035 : BOOL; {DE:"vb7035 Ax2 Start Speed Test"}
    VB_AX2_IN_TEST            AT %MB300.7036 : BOOL; {DE:"vb7036 Ax2 In Test Mode"}
    VB_AX2_USE_QUO_JOG        AT %MB300.7037 : BOOL; {DE:"vb7037 Ax2 Jog: use specific Vq"}

    VN_AX2_OVERRIDE           AT %MW400.3021 : INT;  {DE:"vn3021 Ax2 Indipendent Override"}
    VN_AX2_VEL_PERC_JOG       AT %MW400.3022 : INT;  {DE:"vn3022 Ax2 Jog Speed %"}
    VN_AX2_FOLL_MODE          AT %MW400.3023 : INT;  {DE:"vn3023 Ax2 Follow mode"}
    VN_AX2_FOLL_CONF          AT %MW400.3024 : INT;  {DE:"vn3024 Ax2 Follow configuration"}
    VN_AX2_FOLL_MASTER_NUM    AT %MW400.3025 : INT;  {DE:"vn3025 Ax2 N. of encoder to follow"}
    VN_AX2_FOLL_ERR           AT %MW400.3026 : INT;  {DE:"vn3026 Ax2 Follow functions error code"}
    VN_AX2_CMD_DRIVE          AT %MW400.3027 : INT;  {DE:"vn3027 Ax2 Control word to digital drive (bit)"}
    VN_AX2_VEL_PERC_SEMI      AT %MW400.3029 : INT;  {DE:"vn3029 Ax2 Semi-automatic Speed %"}
    VN_AX2_VEL_PERC_TST_VEL   AT %MW400.3030 : INT;  {DE:"vn3030 Ax2 Speed-Test speed %"}
    VN_AX2_FASE_ZERO          AT %MW400.3031 : INT;  {DE:"vn3031 Ax2 Reset phase"}
    VN_AX2_FASE               AT %MW400.3032 : INT;  {DE:"vn3032 Ax2 Phase"}
    VN_AX2_STATO              AT %MW400.3033 : INT;  {DE:"vn3033 Ax2 Status (bit)"}
    VN_AX2_STATO_ISO          AT %MW400.3034 : INT;  {DE:"vn3034 Ax2 ISO status (bit)"}
    VN_AX2_STATO_DRIVE        AT %MW400.3035 : INT;  {DE:"vn3035 Ax2 Status word from digital drive (bit)"}

    VQ_AX2_INCR_JOG           AT %MD500.7021 : DINT; {DE:"vq7021 Ax2 Jog increase"}
    VQ_AX2_QUO_SEMI           AT %MD500.7022 : DINT; {DE:"vq7022 Ax2 Semi-automatic position"}
    VQ_AX2_FEED_JOG           AT %MD500.7023 : DINT; {DE:"vq7023 Ax2 Jog Feed [mm/min]"}
    VQ_AX2_FOLL_NUM           AT %MD500.7024 : DINT; {DE:"vq7024 Ax2 Follow factor numerator"}
    VQ_AX2_FOLL_DEN           AT %MD500.7025 : DINT; {DE:"vq7025 Ax2 Follow factor denominator"}
    VQ_AX2_BOB_AVA            AT %MD500.7026 : DINT; {DE:"vq7026 Ax2 Reversing forward Threshold"}
    VQ_AX2_BOB_IND            AT %MD500.7027 : DINT; {DE:"vq7027 Ax2 Reversing backward Threshold"}
    VQ_AX2_FEED_SEMI          AT %MD500.7031 : DINT; {DE:"vq7031 Ax2 Jog and Semi-automatic Feed"}
    VQ_AX2_CUR_FEED           AT %MD500.7032 : DINT; {DE:"vq7032 Ax2 Instantaneous Speed Theoretical module"}
    VQ_AX2_VEL_RIF_IMP_S      AT %MD500.7033 : DINT; {DE:"vq7033 Ax2 Speed Test result"}
    VQ_AX2_MONITOR_1          AT %MD500.7034 : DINT; {DE:"vq7034 Ax2 Monitor 1        "}
    VQ_AX2_MONITOR_2          AT %MD500.7035 : DINT; {DE:"vq7035 Ax2 Monitor 2        "}
    
    {G:"AXIS-3 Variables"}

    VB_AX3_JOG_PIU            AT %MB300.7041 : BOOL; {DE:"vb7041 Ax3 Jog+"}
    VB_AX3_JOG_MENO           AT %MB300.7042 : BOOL; {DE:"vb7042 Ax3 Jog-"}
    VB_AX3_JOG_INCR_PIU       AT %MB300.7043 : BOOL; {DE:"vb7043 Ax3 Incremental Jog+"}
    VB_AX3_JOG_INCR_MENO      AT %MB300.7044 : BOOL; {DE:"vb7044 Ax3 Incremental Jog-"}
    VB_AX3_START_SEMI         AT %MB300.7045 : BOOL; {DE:"vb7045 Ax3 Start Semi-automatic"}
    VB_AX3_START_ZERO         AT %MB300.7046 : BOOL; {DE:"vb7046 Ax3 Start Zero"}
    VB_AX3_PID_DISAB          AT %MB300.7047 : BOOL; {DE:"vb7047 Ax3 PID disable"}
    VB_AX3_START_DISAB        AT %MB300.7048 : BOOL; {DE:"vb7048 Ax3 Start disable"}
    VB_AX3_MOVE_DISAB         AT %MB300.7049 : BOOL; {DE:"vb7049 Ax3 Move disable"}
    VB_AX3_RAPIDO_FEED        AT %MB300.7050 : BOOL; {DE:"vb7050 Ax3 Use Fast Feed Vq"}
    VB_AX3_BOB_INV_DIR        AT %MB300.7051 : BOOL; {DE:"vb7051 Ax3 Reverse winder direction"}
    VB_AX3_GET_ORIG           AT %MB300.7052 : BOOL; {DE:"vb7052 Ax3 Enable origin acquisition"}
    VB_AX3_ZEROED             AT %MB300.7053 : BOOL; {DE:"vb7053 Ax3 Zeroed"}
    VB_AX3_IN_QUOTE           AT %MB300.7054 : BOOL; {DE:"vb7054 Ax3 In position"}
    VB_AX3_START_TST_VEL      AT %MB300.7055 : BOOL; {DE:"vb7055 Ax3 Start Speed Test"}
    VB_AX3_IN_TEST            AT %MB300.7056 : BOOL; {DE:"vb7056 Ax3 In Test Mode"}
    VB_AX3_USE_QUO_JOG        AT %MB300.7057 : BOOL; {DE:"vb7057 Ax3 Jog: use specific Vq"}

    VN_AX3_OVERRIDE           AT %MW400.3041 : INT;  {DE:"vn3041 Ax3 Indipendent Override"}
    VN_AX3_VEL_PERC_JOG       AT %MW400.3042 : INT;  {DE:"vn3042 Ax3 Jog Speed %"}
    VN_AX3_FOLL_MODE          AT %MW400.3043 : INT;  {DE:"vn3043 Ax3 Follow mode"}
    VN_AX3_FOLL_CONF          AT %MW400.3044 : INT;  {DE:"vn3044 Ax3 Follow configuration"}
    VN_AX3_FOLL_MASTER_NUM    AT %MW400.3045 : INT;  {DE:"vn3045 Ax3 N. of encoder to follow"}
    VN_AX3_FOLL_ERR           AT %MW400.3046 : INT;  {DE:"vn3046 Ax3 Follow functions error code"}
    VN_AX3_CMD_DRIVE          AT %MW400.3047 : INT;  {DE:"vn3047 Ax3 Control word to digital drive (bit)"}
    VN_AX3_VEL_PERC_SEMI      AT %MW400.3049 : INT;  {DE:"vn3049 Ax3 Semi-automatic Speed %"}
    VN_AX3_VEL_PERC_TST_VEL   AT %MW400.3050 : INT;  {DE:"vn3050 Ax3 Speed-Test speed %"}
    VN_AX3_FASE_ZERO          AT %MW400.3051 : INT;  {DE:"vn3051 Ax3 Reset phase"}
    VN_AX3_FASE               AT %MW400.3052 : INT;  {DE:"vn3052 Ax3 Phase"}
    VN_AX3_STATO              AT %MW400.3053 : INT;  {DE:"vn3053 Ax3 Status (bit)"}
    VN_AX3_STATO_ISO          AT %MW400.3054 : INT;  {DE:"vn3054 Ax3 ISO status (bit)"}
    VN_AX3_STATO_DRIVE        AT %MW400.3055 : INT;  {DE:"vn3055 Ax3 Status word from digital drive (bit)"}

    VQ_AX3_INCR_JOG           AT %MD500.7041 : DINT; {DE:"vq7041 Ax3 Jog increase"}
    VQ_AX3_QUO_SEMI           AT %MD500.7042 : DINT; {DE:"vq7042 Ax3 Semi-automatic position"}
    VQ_AX3_FEED_JOG           AT %MD500.7043 : DINT; {DE:"vq7043 Ax3 Jog Feed [mm/min]"}
    VQ_AX3_FOLL_NUM           AT %MD500.7044 : DINT; {DE:"vq7044 Ax3 Follow factor numerator"}
    VQ_AX3_FOLL_DEN           AT %MD500.7045 : DINT; {DE:"vq7045 Ax3 Follow factor denominator"}
    VQ_AX3_BOB_AVA            AT %MD500.7046 : DINT; {DE:"vq7046 Ax3 Reversing forward Threshold"}
    VQ_AX3_BOB_IND            AT %MD500.7047 : DINT; {DE:"vq7047 Ax3 Reversing backward Threshold"}
    VQ_AX3_FEED_SEMI          AT %MD500.7051 : DINT; {DE:"vq7051 Ax3 Jog and Semi-automatic Feed"}
    VQ_AX3_CUR_FEED           AT %MD500.7052 : DINT; {DE:"vq7052 Ax3 Instantaneous Speed Theoretical module"}
    VQ_AX3_VEL_RIF_IMP_S      AT %MD500.7053 : DINT; {DE:"vq7053 Ax3 Speed Test result"}
    VQ_AX3_MONITOR_1          AT %MD500.7054 : DINT; {DE:"vq7054 Ax3 Monitor 1        "}
    VQ_AX3_MONITOR_2          AT %MD500.7055 : DINT; {DE:"vq7055 Ax3 Monitor 2        "}
    
    {G:"AXIS-4 Variables"}

    VB_AX4_JOG_PIU            AT %MB300.7061 : BOOL; {DE:"vb7061 Ax4 Jog+"}
    VB_AX4_JOG_MENO           AT %MB300.7062 : BOOL; {DE:"vb7062 Ax4 Jog-"}
    VB_AX4_JOG_INCR_PIU       AT %MB300.7063 : BOOL; {DE:"vb7063 Ax4 Incremental Jog+"}
    VB_AX4_JOG_INCR_MENO      AT %MB300.7064 : BOOL; {DE:"vb7064 Ax4 Incremental Jog-"}
    VB_AX4_START_SEMI         AT %MB300.7065 : BOOL; {DE:"vb7065 Ax4 Start Semi-automatic"}
    VB_AX4_START_ZERO         AT %MB300.7066 : BOOL; {DE:"vb7066 Ax4 Start Zero"}
    VB_AX4_PID_DISAB          AT %MB300.7067 : BOOL; {DE:"vb7067 Ax4 PID disable"}
    VB_AX4_START_DISAB        AT %MB300.7068 : BOOL; {DE:"vb7068 Ax4 Start disable"}
    VB_AX4_MOVE_DISAB         AT %MB300.7069 : BOOL; {DE:"vb7069 Ax4 Move disable"}
    VB_AX4_RAPIDO_FEED        AT %MB300.7070 : BOOL; {DE:"vb7070 Ax4 Use Fast Feed Vq"}
    VB_AX4_BOB_INV_DIR        AT %MB300.7071 : BOOL; {DE:"vb7071 Ax4 Reverse winder direction"}
    VB_AX4_GET_ORIG           AT %MB300.7072 : BOOL; {DE:"vb7072 Ax4 Enable origin acquisition"}
    VB_AX4_ZEROED             AT %MB300.7073 : BOOL; {DE:"vb7073 Ax4 Zeroed"}
    VB_AX4_IN_QUOTE           AT %MB300.7074 : BOOL; {DE:"vb7074 Ax4 In position"}
    VB_AX4_START_TST_VEL      AT %MB300.7075 : BOOL; {DE:"vb7075 Ax4 Start Speed Test"}
    VB_AX4_IN_TEST            AT %MB300.7076 : BOOL; {DE:"vb7076 Ax4 In Test Mode"}
    VB_AX4_USE_QUO_JOG        AT %MB300.7077 : BOOL; {DE:"vb7077 Ax4 Jog: use specific Vq"}

    VN_AX4_OVERRIDE           AT %MW400.3061 : INT;  {DE:"vn3061 Ax4 Indipendent Override"}
    VN_AX4_VEL_PERC_JOG       AT %MW400.3062 : INT;  {DE:"vn3062 Ax4 Jog Speed %"}
    VN_AX4_FOLL_MODE          AT %MW400.3063 : INT;  {DE:"vn3063 Ax4 Follow mode"}
    VN_AX4_FOLL_CONF          AT %MW400.3064 : INT;  {DE:"vn3064 Ax4 Follow configuration"}
    VN_AX4_FOLL_MASTER_NUM    AT %MW400.3065 : INT;  {DE:"vn3065 Ax4 N. of encoder to follow"}
    VN_AX4_FOLL_ERR           AT %MW400.3066 : INT;  {DE:"vn3066 Ax4 Follow functions error code"}
    VN_AX4_CMD_DRIVE          AT %MW400.3067 : INT;  {DE:"vn3067 Ax4 Control word to digital drive (bit)"}
    VN_AX4_VEL_PERC_SEMI      AT %MW400.3069 : INT;  {DE:"vn3069 Ax4 Semi-automatic Speed %"}
    VN_AX4_VEL_PERC_TST_VEL   AT %MW400.3070 : INT;  {DE:"vn3070 Ax4 Speed-Test speed %"}
    VN_AX4_FASE_ZERO          AT %MW400.3071 : INT;  {DE:"vn3071 Ax4 Reset phase"}
    VN_AX4_FASE               AT %MW400.3072 : INT;  {DE:"vn3072 Ax4 Phase"}
    VN_AX4_STATO              AT %MW400.3073 : INT;  {DE:"vn3073 Ax4 Status (bit)"}
    VN_AX4_STATO_ISO          AT %MW400.3074 : INT;  {DE:"vn3074 Ax4 ISO status (bit)"}
    VN_AX4_STATO_DRIVE        AT %MW400.3075 : INT;  {DE:"vn3075 Ax4 Status word from digital drive (bit)"}

    VQ_AX4_INCR_JOG           AT %MD500.7061 : DINT; {DE:"vq7061 Ax4 Jog increase"}
    VQ_AX4_QUO_SEMI           AT %MD500.7062 : DINT; {DE:"vq7062 Ax4 Semi-automatic position"}
    VQ_AX4_FEED_JOG           AT %MD500.7063 : DINT; {DE:"vq7063 Ax4 Jog Feed [mm/min]"}
    VQ_AX4_FOLL_NUM           AT %MD500.7064 : DINT; {DE:"vq7064 Ax4 Follow factor numerator"}
    VQ_AX4_FOLL_DEN           AT %MD500.7065 : DINT; {DE:"vq7065 Ax4 Follow factor denominator"}
    VQ_AX4_BOB_AVA            AT %MD500.7066 : DINT; {DE:"vq7066 Ax4 Reversing forward Threshold"}
    VQ_AX4_BOB_IND            AT %MD500.7067 : DINT; {DE:"vq7067 Ax4 Reversing backward Threshold"}
    VQ_AX4_FEED_SEMI          AT %MD500.7071 : DINT; {DE:"vq7071 Ax4 Jog and Semi-automatic Feed"}
    VQ_AX4_CUR_FEED           AT %MD500.7072 : DINT; {DE:"vq7072 Ax4 Instantaneous Speed Theoretical module"}
    VQ_AX4_VEL_RIF_IMP_S      AT %MD500.7073 : DINT; {DE:"vq7073 Ax4 Speed Test result"}
    VQ_AX4_MONITOR_1          AT %MD500.7074 : DINT; {DE:"vq7074 Ax4 Monitor 1        "}
    VQ_AX4_MONITOR_2          AT %MD500.7075 : DINT; {DE:"vq7075 Ax4 Monitor 2        "}
    
END_VAR
]]>
			</lib>
			<lib name="c:\program files (x86)\sipro\siax pc tools\catalog\siaxm32\PLC\basic.pll" fullXml="false" link="true">
				<![CDATA[(*
 *
 * MDPlc source file: C:\Documents and Settings\axel7\Desktop\Posit\Librerie\Basic.pll
 * for project:
 * 10.02.2011 - l.l.
 *)


    (*********************)
    (*                   *)
    (*     FUNCTIONS     *)
    (*                   *)
    (*********************)

FUNCTION BitToWord : WORD

{ DE:"Compose a word from 16 bits" }

    VAR_INPUT
    b0 : BOOL;
    b1 : BOOL;
    b2 : BOOL;
    b3 : BOOL;
    b4 : BOOL;
    b5 : BOOL;
    b6 : BOOL;
    b7 : BOOL;
    b8 : BOOL;
    b9 : BOOL;
    b10 : BOOL;
    b11 : BOOL;
    b12 : BOOL;
    b13 : BOOL;
    b14 : BOOL;
    b15 : BOOL;
    END_VAR

    { CODE:IL }
    LD      b15
    TO_UINT
    SHL     15
    ST      BitToWord

    LD      b14
    TO_UINT
    SHL     14
    ADD     BitToWord
    ST      BitToWord

    LD      b13
    TO_UINT
    SHL     13
    ADD     BitToWord
    ST      BitToWord

    LD      b12
    TO_UINT
    SHL     12
    ADD     BitToWord
    ST      BitToWord

    LD      b11
    TO_UINT
    SHL     11
    ADD     BitToWord
    ST      BitToWord

    LD      b10
    TO_UINT
    SHL     10
    ADD     BitToWord
    ST      BitToWord

    LD      b9
    TO_UINT
    SHL     9
    ADD     BitToWord
    ST      BitToWord

    LD      b8
    TO_UINT
    SHL     8
    ADD     BitToWord
    ST      BitToWord

    LD      b7
    TO_UINT
    SHL     7
    ADD     BitToWord
    ST      BitToWord

    LD      b6
    TO_UINT
    SHL     6
    ADD     BitToWord
    ST      BitToWord

    LD      b5
    TO_UINT
    SHL     5
    ADD     BitToWord
    ST      BitToWord

    LD      b4
    TO_UINT
    SHL     4
    ADD     BitToWord
    ST      BitToWord

    LD      b3
    TO_UINT
    SHL     3
    ADD     BitToWord
    ST      BitToWord

    LD      b2
    TO_UINT
    SHL     2
    ADD     BitToWord
    ST      BitToWord

    LD      b1
    TO_UINT
    SHL     1
    ADD     BitToWord
    ST      BitToWord

    LD      b0
    TO_UINT
    ADD     BitToWord
    ST      BitToWord

END_FUNCTION

FUNCTION BitToByte : USINT

{ DE:"Compose a byte from 8 bits" }

    VAR_INPUT
    b0 : BOOL;
    b1 : BOOL;
    b2 : BOOL;
    b3 : BOOL;
    b4 : BOOL;
    b5 : BOOL;
    b6 : BOOL;
    b7 : BOOL;
    END_VAR

    { CODE:IL }
    LD      b7
    TO_USINT
    SHL     7
    ST      BitToByte

    LD      b6
    TO_USINT
    SHL     6
    ADD     BitToByte
    ST      BitToByte

    LD      b5
    TO_USINT
    SHL     5
    ADD     BitToByte
    ST      BitToByte

    LD      b4
    TO_USINT
    SHL     4
    ADD     BitToByte
    ST      BitToByte

    LD      b3
    TO_USINT
    SHL     3
    ADD     BitToByte
    ST      BitToByte

    LD      b2
    TO_USINT
    SHL     2
    ADD     BitToByte
    ST      BitToByte

    LD      b1
    TO_USINT
    SHL     1
    ADD     BitToByte
    ST      BitToByte

    LD      b0
    TO_USINT
    ADD     BitToByte
    ST      BitToByte
END_FUNCTION

FUNCTION ByteToWord : UINT

{ DE:"Compose a word from 2 bytes" }

    VAR_INPUT
    byte0 : BYTE;
    byte1 : BYTE;
    END_VAR

    { CODE:IL }
    (*---------- WORD in memoria IEEE --------*)
    (*                                        *)
    (*  WORD -> | H byte0 | L byte0 |         *)
    (*                                        *)
    (*----------------------------------------*)

    (*  Low byte *)

    LD      byte0
    TO_UINT
    ST      ByteToWord

    (*  High byte *)

    LD      byte1
    TO_UINT
    SHL     8
    ADD     ByteToWord
    ST      ByteToWord
END_FUNCTION

    (***************************)
    (*                         *)
    (*     FUNCTION BLOCKS     *)
    (*                         *)
    (***************************)

FUNCTION_BLOCK SR

{ DE:"Bistable, set dominant" }

    VAR_INPUT
    s1 : BOOL;
    r : BOOL;
    END_VAR

    VAR_OUTPUT
    q1 : BOOL;
    END_VAR

    { CODE:IL }
    LDN     r
    AND     q1
    OR      s1
    ST      q1
END_FUNCTION_BLOCK

FUNCTION_BLOCK RS

{ DE:"Bistable, reset dominant" }

    VAR_INPUT
    s : BOOL;
    r1 : BOOL;
    END_VAR

    VAR_OUTPUT
    q1 : BOOL;
    END_VAR

    { CODE:IL }
    LD      s
    OR      q1
    ANDN    r1
    ST      q1
END_FUNCTION_BLOCK

FUNCTION_BLOCK R_TRIG

{ DE:"Rising edge detector" }

    VAR_INPUT
    clk : BOOL;
    END_VAR

    VAR_OUTPUT
    q : BOOL;
    END_VAR

    VAR
    m : BOOL := TRUE;
    END_VAR

    { CODE:IL }
    LD      clk
    ANDN    m
    ST      q

    LD      clk
    ST      m
END_FUNCTION_BLOCK

FUNCTION_BLOCK FF_D

{ DE:"D-type flip-flop" }

    VAR_INPUT
    d : BOOL;
    clk : BOOL;
    END_VAR

    VAR_OUTPUT
    q : BOOL;
    END_VAR

    VAR
    m : BOOL := TRUE;
    ok : BOOL;
    END_VAR

    { CODE:IL }
    LD      clk
    ANDN    m
    ST      ok

    LD      clk
    ST      m

    LD      ok
    RETCN

    LD      d
    ST      q
END_FUNCTION_BLOCK

FUNCTION_BLOCK F_TRIG

{ DE:"Falling edge detector" }

    VAR_INPUT
    clk : BOOL;
    END_VAR

    VAR_OUTPUT
    q : BOOL;
    END_VAR

    VAR
    m : BOOL := FALSE;
    END_VAR

    { CODE:IL }
    LDN     clk
    AND     m
    ST      q

    LD      clk
    ST      m
END_FUNCTION_BLOCK

FUNCTION_BLOCK ByteToBit

{ DE:"Split a byte into bits" }

    VAR_INPUT
    byte : BYTE;
    END_VAR

    VAR_OUTPUT
    b0 : BOOL;
    b1 : BOOL;
    b2 : BOOL;
    b3 : BOOL;
    b4 : BOOL;
    b5 : BOOL;
    b6 : BOOL;
    b7 : BOOL;
    END_VAR

    { CODE:IL }
            LD      byte
            AND     16#0001
            NE      0
            ST      b0

            LD      byte
            AND     16#0002
            NE      0
            ST      b1

            LD      byte
            AND     16#0004
            NE      0
            ST      b2

            LD      byte
            AND     16#0008
            NE      0
            ST      b3

            LD      byte
            AND     16#0010
            NE      0
            ST      b4

            LD      byte
            AND     16#0020
            NE      0
            ST      b5

            LD      byte
            AND     16#0040
            NE      0
            ST      b6

            LD      byte
            AND     16#0080
            NE      0
            ST      b7
END_FUNCTION_BLOCK

FUNCTION_BLOCK WordToBit

{ DE:"Split a word into bits" }

    VAR_INPUT
    word : WORD;
    END_VAR

    VAR_OUTPUT
    b0 : BOOL;
    b1 : BOOL;
    b2 : BOOL;
    b3 : BOOL;
    b4 : BOOL;
    b5 : BOOL;
    b6 : BOOL;
    b7 : BOOL;
    b8 : BOOL;
    b9 : BOOL;
    b10 : BOOL;
    b11 : BOOL;
    b12 : BOOL;
    b13 : BOOL;
    b14 : BOOL;
    b15 : BOOL;
    END_VAR

    { CODE:IL }
            LD      word
            AND     16#0001
            NE      0
            ST      b0

            LD      word
            AND     16#0002
            NE      0
            ST      b1

            LD      word
            AND     16#0004
            NE      0
            ST      b2

            LD      word
            AND     16#0008
            NE      0
            ST      b3

            LD      word
            AND     16#0010
            NE      0
            ST      b4

            LD      word
            AND     16#0020
            NE      0
            ST      b5

            LD      word
            AND     16#0040
            NE      0
            ST      b6

            LD      word
            AND     16#0080
            NE      0
            ST      b7

            LD      word
            AND     16#0100
            NE      0
            ST      b8

            LD      word
            AND     16#0200
            NE      0
            ST      b9

            LD      word
            AND     16#0400
            NE      0
            ST      b10

            LD      word
            AND     16#0800
            NE      0
            ST      b11

            LD      word
            AND     16#1000
            NE      0
            ST      b12

            LD      word
            AND     16#2000
            NE      0
            ST      b13

            LD      word
            AND     16#4000
            NE      0
            ST      b14

            LD      word
            AND     16#8000
            NE      0
            ST      b15
END_FUNCTION_BLOCK

FUNCTION_BLOCK WordToByte

{ DE:"Split a word into two bytes" }

    VAR_INPUT
    w : UINT;
    END_VAR

    VAR_OUTPUT
    byte0 : USINT;
    byte1 : USINT;
    END_VAR

    { CODE:IL }
    (*---------- WORD in memoria IEEE --------*)
    (*                                        *)
    (*  WORD -> | H byte0 | L byte0 |         *)
    (*                                        *)
    (*----------------------------------------*)

    (*  Low byte *)

    LD      w
    TO_USINT
    ST      byte0

    (*  High byte *)

    LD      w
    SHR     8
    TO_USINT
    ST      byte1
END_FUNCTION_BLOCK

]]>
			</lib>
			<lib name="c:\program files (x86)\sipro\siax pc tools\catalog\siaxm32\PLC\Chn1_v1.pll" fullXml="false" link="true">
				<![CDATA[(*
 *
 * MDPlc source file: SysChn1_v1.pll
 * for project:
 * 20.04.2012 - s.v.
 *)


VAR_GLOBAL

    {G:"Channel-1 Variables"}

    VB_CHN_START              AT %MB300.7901 : BOOL; {DE:"vb7901 Start"}
    VB_CHN_STOP_HOLD          AT %MB300.7902 : BOOL; {DE:"vb7902 Hold"}
    VB_CHN_RESET              AT %MB300.7903 : BOOL; {DE:"vb7903 Reset"}
    VB_CHN_RELEASE            AT %MB300.7904 : BOOL; {DE:"vb7904 Release"}
    VB_CHN_EXEC_SINGLE        AT %MB300.7905 : BOOL; {DE:"vb7905 Single"}
    VB_CHN_HOLD_AXES          AT %MB300.7906 : BOOL; {DE:"vb7906 Hold Axes"}
    VB_CHN_START_ZERO         AT %MB300.7907 : BOOL; {DE:"vb7907 Start Zero Sequence"}
    VB_CHN_AUTO_RUNNING       AT %MB300.7908 : BOOL; {DE:"vb7908 Auto Running"}
    VB_CHN_IN_EMERG           AT %MB300.7909 : BOOL; {DE:"vb7909 Emergency"}
    VB_CHN_UDT_BUSY           AT %MB300.7910 : BOOL; {DE:"vb7910 Udt Busy"}
    VB_CHN_I_JOG_PIU          AT %MB300.7911 : BOOL; {DE:"vb7911 Jog+ Single Operation"}
    VB_CHN_I_JOG_MENO         AT %MB300.7912 : BOOL; {DE:"vb7912 Jog- Single Operation"}
    VB_CHN_I_START            AT %MB300.7913 : BOOL; {DE:"vb7913 Start Single Operation"}
    VB_CHN_START_CMDA         AT %MB300.7915 : BOOL; {DE:"vb7915 CMDA Start Command"}
    VB_CHN_JOG_INTP           AT %MB300.7916 : BOOL; {DE:"vb7916 Interpolated Jog enable"}
    VB_CHN_JOG_RETRACT        AT %MB300.7917 : BOOL; {DE:"vb7917 Jog Retract            "}
    VB_CHN_IN_MOVE_SINGLE     AT %MB300.7918 : BOOL; {DE:"vb7918 Interpolated Movement Single Execution"}    

    VN_CHN_OVERRIDE_G1        AT %MW400.3901 : INT;  {DE:"vn3901 Override Feed G1"}
    VN_CHN_OVERRIDE_G0        AT %MW400.3902 : INT;  {DE:"vn3902 Override Feed G0"}
    VN_CHN_OVERRIDE_SPEED     AT %MW400.3903 : INT;  {DE:"vn3903 Override Speed"}
    VN_CHN_ORIG_ACT           AT %MW400.3905 : INT;  {DE:"vn3905 Active Origin"}
    VN_CHN_STATUS             AT %MW400.3906 : INT;  {DE:"vn3906 Channel Status"}
    VN_CHN_INTP_STATUS        AT %MW400.3907 : INT;  {DE:"vn3907 Interpolator Status"}
    VN_CHN_GRP_STATUS         AT %MW400.3908 : INT;  {DE:"vn3908 Interpolator Group Status"}
    VN_CHN_STATUS_CMDA        AT %MW400.3909 : INT;  {DE:"vn3909 CMDA management status"}
    VN_CHN_UDT_STATUS         AT %MW400.3910 : INT;  {DE:"vn3910 UDT management status"}
    VN_CHN_ENAB_SINGLE_OPER   AT %MW400.3911 : INT;  {DE:"vn3911 Vb single operation enable"}
    VN_CHN_ENAB_OPER          AT %MW400.3912 : INT;  {DE:"vn3912 Operations enable"}
    VN_CHN_STATO_INTERF       AT %MW400.3913 : INT;  {DE:"vn3913 Operator interface state"}
    VN_CHN_TGS_STATUS         AT %MW400.3914 : INT;  {DE:"vn3914 Teach management state"}
    VN_CHN_FILE_REQ           AT %MW400.3915 : INT;  {DE:"vn3915 NC file request"}
    VN_CHN_PROT_UDT_BUSY      AT %MW400.3916 : INT;  {DE:"vn3916 Cnt Protocol udt Command not executed cause there is another command active"}
    VN_CHN_PLC_UDT_BUSY       AT %MW400.3917 : INT;  {DE:"vn3917 Cnt Plc udt Command not executed cause there is another command active"}
    
    VN_CHN_READ_TOOL_NUM      AT %MW400.4061 : INT;  {DE:"vn4061 Tool Read"}
    VN_CHN_MOUNT_TOOL_NUM     AT %MW400.4062 : INT;  {DE:"vn4062 Tool Mount"}
    VN_CHN_GOSUB_PAR          AT %MW400.4063 : INT;  {DE:"vn4063 Gosub Parameter"}
    VN_CHN_SPINDLE_DIR        AT %MW400.4064 : INT;  {DE:"vn4064 Spindle linked to interpolated group direction"}    

    VQ_CHN_CUR_SPEED          AT %MD500.7904 : DINT; {DE:"vq7904 Current Speed"}
    VQ_CHN_SET_SPEED          AT %MD500.7905 : DINT; {DE:"vq7905 Set Speed"}
    VQ_CHN_GOSUB_PAR          AT %MD500.7906 : DINT; {DE:"vq7906 Gosub Parameter"}
    VQ_CHN_DELAY_TIMER        AT %MD500.7907 : DINT; {DE:"vq7907 Residual Delay Time"}
    VQ_CHN_CUR_FEED           AT %MD500.7908 : DINT; {DE:"vq7908 Current Feed [mm/min]"}
    VQ_CHN_SET_FEED           AT %MD500.7909 : DINT; {DE:"vq7909 Set Feed [mm/min]"}
    VQ_CHN_AX_SEL             AT %MD500.7911 : DINT; {DE:"vq7911 Axes selection"}
    VQ_CHN_JOG_INTP_FEED      AT %MD500.7912 : DINT; {DE:"vq7912 Interpoled Jog Feed [mm/min]"}
    VQ_CHN_INCR_JOG_INTP      AT %MD500.7913 : DINT; {DE:"vq7913 Interpoled Jog increase"}
    
    VQ_CHN_PIECE_DIM_X        AT %MD500.8061 : DINT; {DE:"vq8061 Piece Dim X"}
    VQ_CHN_PIECE_DIM_Y        AT %MD500.8062 : DINT; {DE:"vq8062 Piece Dim Y"}
    VQ_CHN_PIECE_DIM_Z        AT %MD500.8063 : DINT; {DE:"vq8063 Piece Dim Z"}
    VQ_CHN_MNT_TOOL_RADIUS    AT %MD500.8064 : DINT; {DE:"vq8064 Mount Tool Radius"}
    VQ_CHN_MNT_TOOL_LENGTH    AT %MD500.8065 : DINT; {DE:"vq8065 Mount Tool Length"}

END_VAR
]]>
			</lib>
			<lib name="c:\program files (x86)\sipro\siax pc tools\catalog\siaxm32\PLC\System_v1.pll" fullXml="false" link="true">
				<![CDATA[(*
 *
 * MDPlc source file: System_v1.pll
 * for project:
 * 30.08.2012 - s.v.
 *)


VAR_GLOBAL

    {G:"System Variables"}
    VB_SYS_REBOOT_BY_WDOG      AT %MB300.7801 : BOOL; {DE:"vb7801 Cnc Reboot caused by watchdog "}
    VB_SYS_BKP_INVALID         AT %MB300.7802 : BOOL; {DE:"vb7802 Retained Area not Valid       "}
    VB_SYS_PROT_WDOG           AT %MB300.7803 : BOOL; {DE:"vb7803 Vb Set to 0 each 2 Plc cycle  "}
    VB_SYS_LOW_BATTERY         AT %MB300.7804 : BOOL; {DE:"vb7804 Backup battery discharged     "}    
    VB_SYS_CNC_BOOT_DONE       AT %MB300.7805 : BOOL; {DE:"vb7805 Cnc Boot Done"}
    VB_SYS_GEST_RELOAD         AT %MB300.7806 : BOOL; {DE:"vb7806 Reload in progress"}
    VB_SYS_GNP_BUSY            AT %MB300.7807 : BOOL; {DE:"vb7807 Nodes parameters management in progress"}
    VB_SYS_CNC_ENABLED         AT %MB300.7808 : BOOL; {DE:"vb7808 Cnc Enabled"}
    VB_SYS_XCOP_READY          AT %MB300.7809 : BOOL; {DE:"vb7809 CanOpen Ready"}
    VB_SYS_USB_KEY_IN          AT %MB300.7810 : BOOL; {DE:"vb7810 USB key connected"}
    VB_SYS_GEST_CNC_FILE       AT %MB300.7811 : BOOL; {DE:"vb7811 CNC file management parameters"}
    VB_SYS_KEY_PRESS           AT %MB300.7812 : BOOL; {DE:"vb7812 Key pressed"}
    VB_SYS_XCOP_OPERATIONAL    AT %MB300.7813 : BOOL; {DE:"vb7813 All CanOpen nodes switched to operational mode"}
    VB_SYS_ECAT_OPERATIONAL    AT %MB300.7814 : BOOL; {DE:"vb7814 All Ethercat nodes switched to operational mode"}
    VB_SYS_MECHATR_READY       AT %MB300.7815 : BOOL; {DE:"vb7815 Mechatrolink ready (all nets ready)"}
    VB_SYS_ECAT_DCS_NOT_SYNC   AT %MB300.7816 : BOOL; {DE:"vb7816 Ethercat distributed clock not Sync "}
    VB_SYS_CMD_FILE_RUNNING    AT %MB300.7817 : BOOL; {DE:"vb7817 Cmd files in execution             "}
    VB_SYS_ENAB_COPY_LOG       AT %MB300.7818 : BOOL; {DE:"vb7818 Log File copy on C disk Enabled    "}
    VB_DISAB_PLC_ATT_OUT       AT %MB300.7820 : BOOL; {DE:"vb7820 Digital outputs managed by PLC disabled"}
    VB_SYS_BUTTON_STATE        AT %MB300.7821 : BOOL; {DE:"vb7821 Front Button State                     "}

    VN_SYS_OMNI_OPER           AT %MW400.3801 : INT;  {DE:"vn3801 Cnc state (bit)"}
    VN_SYS_PLC_STATUS          AT %MW400.3802 : INT;  {DE:"vn3802 Plc state"}
    VN_SYS_PLC_FUN_ERR_CODE    AT %MW400.3803 : INT;  {DE:"vn3803 Plc functions code error"}
    VN_SYS_PAGE_ID             AT %MW400.3804 : INT;  {DE:"vn3804 Page Id"}
    VN_SYS_OBJ_ID              AT %MW400.3805 : INT;  {DE:"vn3805 Obj Id"}
    VN_SYS_KEY_CODE            AT %MW400.3806 : INT;  {DE:"vn3806 Pressed key code"}
    VN_SYS_PUT_KEY_CODE        AT %MW400.3807 : INT;  {DE:"vn3807 Simulated key code"}
    VN_SYS_PAGE_ID_RO          AT %MW400.3808 : INT;  {DE:"vn3808 Page Id (read only)"}
    VN_SYS_DISAB_AX_HW_FC      AT %MW400.3809 : INT;  {DE:"vn3809 Hardware limit switch disable"}
    VN_SYS_IN_TEST             AT %MW400.3810 : INT;  {DE:"vn3810 Test mode selection"}
    VN_SYS_RELOAD_PAR_AX       AT %MW400.3811 : INT;  {DE:"vn3811 Axis file parameters management"}
    VN_SYS_RELOAD_PAR_PID      AT %MW400.3812 : INT;  {DE:"vn3812 Pid file parameters management"}
    VN_SYS_RELOAD_PAR_MAC      AT %MW400.3813 : INT;  {DE:"vn3813 Machine file parameters management"}
    VN_SYS_RELOAD_PAR_COP      AT %MW400.3814 : INT;  {DE:"vn3814 CanOpen file parameters management"}
    VN_SYS_RELOAD_PAR_ORIG     AT %MW400.3816 : INT;  {DE:"vn3816 Origins file parameters management"}
    VN_SYS_RELOAD_PAR_TOOLS    AT %MW400.3817 : INT;  {DE:"vn3817 Tools file parameters management"}
    VN_SYS_RELOAD_PLC          AT %MW400.3821 : INT;  {DE:"vn3821 Plc file management"}
    VN_SYS_GNP_STATUS          AT %MW400.3823 : INT;  {DE:"vn3823 Nodes file parameters management"}
    VN_SYS_RELOAD_PROG         AT %MW400.3825 : INT;  {DE:"vn3825 Program file management"}
    VN_SYS_ECAT_STATUS         AT %MW400.3826 : INT;  {DE:"vn3826 stato della rete ethercat "}
    VN_SYS_GRAPH_STATUS        AT %MW400.3827 : INT;  {DE:"vn3827 Graphic Interface Status"}
    VN_SYS_CNC_HALT            AT %MW400.3828 : INT;  {DE:"vn3828 CNC Halt State         "}
    
    
    VQ_SYS_AX_MOVING           AT %MD500.7801 : DINT; {DE:"vq7801 Mask of moving axes"}
    VQ_SYS_AX_NOT_IN_QUOTE     AT %MD500.7802 : DINT; {DE:"vq7802 Mask of axes not in quote"}
    VQ_SYS_PLC_CYCLE_COUNT     AT %MD500.7803 : DINT; {DE:"vq7803 Plc cycle counter"}
    VQ_SYS_SOCK_PKT_COUNT_1    AT %MD500.7804 : DINT; {DE:"vq7804 counter of receiving packets on port 12001"}
    VQ_SYS_SOCK_PKT_COUNT_2    AT %MD500.7805 : DINT; {DE:"vq7805 counter of receiving packets on port 12002"}
    VQ_SYS_SOCK_PKT_COUNT_3    AT %MD500.7806 : DINT; {DE:"vq7806 counter of receiving packets on port 12003"}
    VQ_SYS_SOCK_PKT_COUNT_4    AT %MD500.7807 : DINT; {DE:"vq7807 counter of receiving packets on port 12033"}
    VQ_SYS_SOCK_PKT_COUNT_5    AT %MD500.7808 : DINT; {DE:"vq7808 counter of receiving packets on port 12101"}
    VQ_SYS_SOCK_PKT_COUNT_6    AT %MD500.7809 : DINT; {DE:"vq7809 counter of receiving packets on port 12103"}    
    VQ_SYS_AXES_IN_TEST        AT %MD500.7811 : DINT; {DE:"vq7811 Mask of axes in test"}
    VQ_SYS_ECAT_CYC_LOST       AT %MD500.7813 : DINT; {DE:"vq7813 Ethercat: Lost Cyclic Frame   "}    
    VQ_SYS_DEBUG               AT %MD500.7817 : DINT; {DE:"vq7817 Debug Enable                  "}        
    VQ_SYS_HEAP_MAX_ONE_FREE   AT %MD500.7818 : DINT; {DE:"vq7818 Max near Area Free            "}        
    VQ_SYS_HEAP_MEM_FREE       AT %MD500.7819 : DINT; {DE:"vq7819 N. Byte Heap Memory Free      "}        
    VQ_SYS_HEAP_MEM_TOT        AT %MD500.7820 : DINT; {DE:"vq7820 N. Byte Heap Memory Total     "}            

END_VAR
]]>
			</lib>
			<lib name="C:\Program Files (x86)\Sipro\Siax PC Tools\Catalog\SiaxM32\PLC\Ax5_8_v1.pll" fullXml="false" link="true">
				<![CDATA[(*
 *
 * MDPlc source file: Ax5_8_v1.pll
 * for project:
 * 20.04.2012 - s.v.
 *)


VAR_GLOBAL

    {G:"AXIS-5 Variables"}

    VB_AX5_JOG_PIU            AT %MB300.7081 : BOOL; {DE:"vb7081 Ax5 Jog+"}
    VB_AX5_JOG_MENO           AT %MB300.7082 : BOOL; {DE:"vb7082 Ax5 Jog-"}
    VB_AX5_JOG_INCR_PIU       AT %MB300.7083 : BOOL; {DE:"vb7083 Ax5 Incremental Jog+"}
    VB_AX5_JOG_INCR_MENO      AT %MB300.7084 : BOOL; {DE:"vb7084 Ax5 Incremental Jog-"}
    VB_AX5_START_SEMI         AT %MB300.7085 : BOOL; {DE:"vb7085 Ax5 Start Semi-automatic"}
    VB_AX5_START_ZERO         AT %MB300.7086 : BOOL; {DE:"vb7086 Ax5 Start Zero"}
    VB_AX5_PID_DISAB          AT %MB300.7087 : BOOL; {DE:"vb7087 Ax5 PID disable"}
    VB_AX5_START_DISAB        AT %MB300.7088 : BOOL; {DE:"vb7088 Ax5 Start disable"}
    VB_AX5_MOVE_DISAB         AT %MB300.7089 : BOOL; {DE:"vb7089 Ax5 Move disable"}
    VB_AX5_RAPIDO_FEED        AT %MB300.7090 : BOOL; {DE:"vb7090 Ax5 Use Fast Feed Vq"}
    VB_AX5_BOB_INV_DIR        AT %MB300.7091 : BOOL; {DE:"vb7091 Ax5 Reverse winder direction"}
    VB_AX5_GET_ORIG           AT %MB300.7092 : BOOL; {DE:"vb7092 Ax5 Enable origin acquisition"}
    VB_AX5_ZEROED             AT %MB300.7093 : BOOL; {DE:"vb7093 Ax5 Zeroed"}
    VB_AX5_IN_QUOTE           AT %MB300.7094 : BOOL; {DE:"vb7094 Ax5 In position"}
    VB_AX5_START_TST_VEL      AT %MB300.7095 : BOOL; {DE:"vb7095 Ax5 Start Speed Test"}
    VB_AX5_IN_TEST            AT %MB300.7096 : BOOL; {DE:"vb7096 Ax5 In Test Mode"}
    VB_AX5_USE_QUO_JOG        AT %MB300.7097 : BOOL; {DE:"vb7097 Ax5 Jog: use specific Vq"}

    VN_AX5_OVERRIDE           AT %MW400.3081 : INT;  {DE:"vn3081 Ax5 Indipendent Override"}
    VN_AX5_VEL_PERC_JOG       AT %MW400.3082 : INT;  {DE:"vn3082 Ax5 Jog Speed %"}
    VN_AX5_FOLL_MODE          AT %MW400.3083 : INT;  {DE:"vn3083 Ax5 Follow mode"}
    VN_AX5_FOLL_CONF          AT %MW400.3084 : INT;  {DE:"vn3084 Ax5 Follow configuration"}
    VN_AX5_FOLL_MASTER_NUM    AT %MW400.3085 : INT;  {DE:"vn3085 Ax5 N. of encoder to follow"}
    VN_AX5_FOLL_ERR           AT %MW400.3086 : INT;  {DE:"vn3086 Ax5 Follow functions error code"}
    VN_AX5_CMD_DRIVE          AT %MW400.3087 : INT;  {DE:"vn3087 Ax5 Control word to digital drive (bit)"}
    VN_AX5_VEL_PERC_SEMI      AT %MW400.3089 : INT;  {DE:"vn3089 Ax5 Semi-automatic Speed %"}
    VN_AX5_VEL_PERC_TST_VEL   AT %MW400.3090 : INT;  {DE:"vn3090 Ax5 Speed-Test speed %"}
    VN_AX5_FASE_ZERO          AT %MW400.3091 : INT;  {DE:"vn3091 Ax5 Reset phase"}
    VN_AX5_FASE               AT %MW400.3092 : INT;  {DE:"vn3092 Ax5 Phase"}
    VN_AX5_STATO              AT %MW400.3093 : INT;  {DE:"vn3093 Ax5 Status (bit)"}
    VN_AX5_STATO_ISO          AT %MW400.3094 : INT;  {DE:"vn3094 Ax5 ISO status (bit)"}
    VN_AX5_STATO_DRIVE        AT %MW400.3095 : INT;  {DE:"vn3095 Ax5 Status word from digital drive (bit)"}

    VQ_AX5_INCR_JOG           AT %MD500.7081 : DINT; {DE:"vq7081 Ax5 Jog increase"}
    VQ_AX5_QUO_SEMI           AT %MD500.7082 : DINT; {DE:"vq7082 Ax5 Semi-automatic position"}
    VQ_AX5_FEED_JOG           AT %MD500.7083 : DINT; {DE:"vq7083 Ax5 Jog Feed [mm/min]"}
    VQ_AX5_FOLL_NUM           AT %MD500.7084 : DINT; {DE:"vq7084 Ax5 Follow factor numerator"}
    VQ_AX5_FOLL_DEN           AT %MD500.7085 : DINT; {DE:"vq7085 Ax5 Follow factor denominator"}
    VQ_AX5_BOB_AVA            AT %MD500.7086 : DINT; {DE:"vq7086 Ax5 Reversing forward Threshold"}
    VQ_AX5_BOB_IND            AT %MD500.7087 : DINT; {DE:"vq7087 Ax5 Reversing backward Threshold"}
    VQ_AX5_FEED_SEMI          AT %MD500.7091 : DINT; {DE:"vq7091 Ax5 Jog and Semi-automatic Feed"}
    VQ_AX5_CUR_FEED           AT %MD500.7092 : DINT; {DE:"vq7092 Ax5 Instantaneous Speed Theoretical module"}
    VQ_AX5_VEL_RIF_IMP_S      AT %MD500.7093 : DINT; {DE:"vq7093 Ax5 Speed Test result"}
    VQ_AX5_MONITOR_1          AT %MD500.7094 : DINT; {DE:"vq7094 Ax5 Monitor 1        "}
    VQ_AX5_MONITOR_2          AT %MD500.7095 : DINT; {DE:"vq7095 Ax5 Monitor 2        "}
    
    {G:"AXIS-6 Variables"}

    VB_AX6_JOG_PIU            AT %MB300.7101 : BOOL; {DE:"vb7101 Ax6 Jog+"}
    VB_AX6_JOG_MENO           AT %MB300.7102 : BOOL; {DE:"vb7102 Ax6 Jog-"}
    VB_AX6_JOG_INCR_PIU       AT %MB300.7103 : BOOL; {DE:"vb7103 Ax6 Incremental Jog+"}
    VB_AX6_JOG_INCR_MENO      AT %MB300.7104 : BOOL; {DE:"vb7104 Ax6 Incremental Jog-"}
    VB_AX6_START_SEMI         AT %MB300.7105 : BOOL; {DE:"vb7105 Ax6 Start Semi-automatic"}
    VB_AX6_START_ZERO         AT %MB300.7106 : BOOL; {DE:"vb7106 Ax6 Start Zero"}
    VB_AX6_PID_DISAB          AT %MB300.7107 : BOOL; {DE:"vb7107 Ax6 PID disable"}
    VB_AX6_START_DISAB        AT %MB300.7108 : BOOL; {DE:"vb7108 Ax6 Start disable"}
    VB_AX6_MOVE_DISAB         AT %MB300.7109 : BOOL; {DE:"vb7109 Ax6 Move disable"}
    VB_AX6_RAPIDO_FEED        AT %MB300.7110 : BOOL; {DE:"vb7110 Ax6 Use Fast Feed Vq"}
    VB_AX6_BOB_INV_DIR        AT %MB300.7111 : BOOL; {DE:"vb7111 Ax6 Reverse winder direction"}
    VB_AX6_GET_ORIG           AT %MB300.7112 : BOOL; {DE:"vb7112 Ax6 Enable origin acquisition"}
    VB_AX6_ZEROED             AT %MB300.7113 : BOOL; {DE:"vb7113 Ax6 Zeroed"}
    VB_AX6_IN_QUOTE           AT %MB300.7114 : BOOL; {DE:"vb7114 Ax6 In position"}
    VB_AX6_START_TST_VEL      AT %MB300.7115 : BOOL; {DE:"vb7115 Ax6 Start Speed Test"}
    VB_AX6_IN_TEST            AT %MB300.7116 : BOOL; {DE:"vb7116 Ax6 In Test Mode"}
    VB_AX6_USE_QUO_JOG        AT %MB300.7117 : BOOL; {DE:"vb7117 Ax6 Jog: use specific Vq"}

    VN_AX6_OVERRIDE           AT %MW400.3101 : INT;  {DE:"vn3101 Ax6 Indipendent Override"}
    VN_AX6_VEL_PERC_JOG       AT %MW400.3102 : INT;  {DE:"vn3102 Ax6 Jog Speed %"}
    VN_AX6_FOLL_MODE          AT %MW400.3103 : INT;  {DE:"vn3103 Ax6 Follow mode"}
    VN_AX6_FOLL_CONF          AT %MW400.3104 : INT;  {DE:"vn3104 Ax6 Follow configuration"}
    VN_AX6_FOLL_MASTER_NUM    AT %MW400.3105 : INT;  {DE:"vn3105 Ax6 N. of encoder to follow"}
    VN_AX6_FOLL_ERR           AT %MW400.3106 : INT;  {DE:"vn3106 Ax6 Follow functions error code"}
    VN_AX6_CMD_DRIVE          AT %MW400.3107 : INT;  {DE:"vn3107 Ax6 Control word to digital drive (bit)"}
    VN_AX6_VEL_PERC_SEMI      AT %MW400.3109 : INT;  {DE:"vn3109 Ax6 Semi-automatic Speed %"}
    VN_AX6_VEL_PERC_TST_VEL   AT %MW400.3110 : INT;  {DE:"vn3110 Ax6 Speed-Test speed %"}
    VN_AX6_FASE_ZERO          AT %MW400.3111 : INT;  {DE:"vn3111 Ax6 Reset phase"}
    VN_AX6_FASE               AT %MW400.3112 : INT;  {DE:"vn3112 Ax6 Phase"}
    VN_AX6_STATO              AT %MW400.3113 : INT;  {DE:"vn3113 Ax6 Status (bit)"}
    VN_AX6_STATO_ISO          AT %MW400.3114 : INT;  {DE:"vn3114 Ax6 ISO status (bit)"}
    VN_AX6_STATO_DRIVE        AT %MW400.3115 : INT;  {DE:"vn3115 Ax6 Status word from digital drive (bit)"}

    VQ_AX6_INCR_JOG           AT %MD500.7101 : DINT; {DE:"vq7101 Ax6 Jog increase"}
    VQ_AX6_QUO_SEMI           AT %MD500.7102 : DINT; {DE:"vq7102 Ax6 Semi-automatic position"}
    VQ_AX6_FEED_JOG           AT %MD500.7103 : DINT; {DE:"vq7103 Ax6 Jog Feed [mm/min]"}
    VQ_AX6_FOLL_NUM           AT %MD500.7104 : DINT; {DE:"vq7104 Ax6 Follow factor numerator"}
    VQ_AX6_FOLL_DEN           AT %MD500.7105 : DINT; {DE:"vq7105 Ax6 Follow factor denominator"}
    VQ_AX6_BOB_AVA            AT %MD500.7106 : DINT; {DE:"vq7106 Ax6 Reversing forward Threshold"}
    VQ_AX6_BOB_IND            AT %MD500.7107 : DINT; {DE:"vq7107 Ax6 Reversing backward Threshold"}
    VQ_AX6_FEED_SEMI          AT %MD500.7111 : DINT; {DE:"vq7111 Ax6 Jog and Semi-automatic Feed"}
    VQ_AX6_CUR_FEED           AT %MD500.7112 : DINT; {DE:"vq7112 Ax6 Instantaneous Speed Theoretical module"}
    VQ_AX6_VEL_RIF_IMP_S      AT %MD500.7113 : DINT; {DE:"vq7113 Ax6 Speed Test result"}
    VQ_AX6_MONITOR_1          AT %MD500.7114 : DINT; {DE:"vq7114 Ax6 Monitor 1        "}
    VQ_AX6_MONITOR_2          AT %MD500.7115 : DINT; {DE:"vq7115 Ax6 Monitor 2        "}
    
    {G:"AXIS-7 Variables"}

    VB_AX7_JOG_PIU            AT %MB300.7121 : BOOL; {DE:"vb7121 Ax7 Jog+"}
    VB_AX7_JOG_MENO           AT %MB300.7122 : BOOL; {DE:"vb7122 Ax7 Jog-"}
    VB_AX7_JOG_INCR_PIU       AT %MB300.7123 : BOOL; {DE:"vb7123 Ax7 Incremental Jog+"}
    VB_AX7_JOG_INCR_MENO      AT %MB300.7124 : BOOL; {DE:"vb7124 Ax7 Incremental Jog-"}
    VB_AX7_START_SEMI         AT %MB300.7125 : BOOL; {DE:"vb7125 Ax7 Start Semi-automatic"}
    VB_AX7_START_ZERO         AT %MB300.7126 : BOOL; {DE:"vb7126 Ax7 Start Zero"}
    VB_AX7_PID_DISAB          AT %MB300.7127 : BOOL; {DE:"vb7127 Ax7 PID disable"}
    VB_AX7_START_DISAB        AT %MB300.7128 : BOOL; {DE:"vb7128 Ax7 Start disable"}
    VB_AX7_MOVE_DISAB         AT %MB300.7129 : BOOL; {DE:"vb7129 Ax7 Move disable"}
    VB_AX7_RAPIDO_FEED        AT %MB300.7130 : BOOL; {DE:"vb7130 Ax7 Use Fast Feed Vq"}
    VB_AX7_BOB_INV_DIR        AT %MB300.7131 : BOOL; {DE:"vb7131 Ax7 Reverse winder direction"}
    VB_AX7_GET_ORIG           AT %MB300.7132 : BOOL; {DE:"vb7132 Ax7 Enable origin acquisition"}
    VB_AX7_ZEROED             AT %MB300.7133 : BOOL; {DE:"vb7133 Ax7 Zeroed"}
    VB_AX7_IN_QUOTE           AT %MB300.7134 : BOOL; {DE:"vb7134 Ax7 In position"}
    VB_AX7_START_TST_VEL      AT %MB300.7135 : BOOL; {DE:"vb7135 Ax7 Start Speed Test"}
    VB_AX7_IN_TEST            AT %MB300.7136 : BOOL; {DE:"vb7136 Ax7 In Test Mode"}
    VB_AX7_USE_QUO_JOG        AT %MB300.7137 : BOOL; {DE:"vb7137 Ax7 Jog: use specific Vq"}

    VN_AX7_OVERRIDE           AT %MW400.3121 : INT;  {DE:"vn3121 Ax7 Indipendent Override"}
    VN_AX7_VEL_PERC_JOG       AT %MW400.3122 : INT;  {DE:"vn3122 Ax7 Jog Speed %"}
    VN_AX7_FOLL_MODE          AT %MW400.3123 : INT;  {DE:"vn3123 Ax7 Follow mode"}
    VN_AX7_FOLL_CONF          AT %MW400.3124 : INT;  {DE:"vn3124 Ax7 Follow configuration"}
    VN_AX7_FOLL_MASTER_NUM    AT %MW400.3125 : INT;  {DE:"vn3125 Ax7 N. of encoder to follow"}
    VN_AX7_FOLL_ERR           AT %MW400.3126 : INT;  {DE:"vn3126 Ax7 Follow functions error code"}
    VN_AX7_CMD_DRIVE          AT %MW400.3127 : INT;  {DE:"vn3127 Ax7 Control word to digital drive (bit)"}
    VN_AX7_VEL_PERC_SEMI      AT %MW400.3129 : INT;  {DE:"vn3129 Ax7 Semi-automatic Speed %"}
    VN_AX7_VEL_PERC_TST_VEL   AT %MW400.3130 : INT;  {DE:"vn3130 Ax7 Speed-Test speed %"}
    VN_AX7_FASE_ZERO          AT %MW400.3131 : INT;  {DE:"vn3131 Ax7 Reset phase"}
    VN_AX7_FASE               AT %MW400.3132 : INT;  {DE:"vn3132 Ax7 Phase"}
    VN_AX7_STATO              AT %MW400.3133 : INT;  {DE:"vn3133 Ax7 Status (bit)"}
    VN_AX7_STATO_ISO          AT %MW400.3134 : INT;  {DE:"vn3134 Ax7 ISO status (bit)"}
    VN_AX7_STATO_DRIVE        AT %MW400.3135 : INT;  {DE:"vn3135 Ax7 Status word from digital drive (bit)"}

    VQ_AX7_INCR_JOG           AT %MD500.7121 : DINT; {DE:"vq7121 Ax7 Jog increase"}
    VQ_AX7_QUO_SEMI           AT %MD500.7122 : DINT; {DE:"vq7122 Ax7 Semi-automatic position"}
    VQ_AX7_FEED_JOG           AT %MD500.7123 : DINT; {DE:"vq7123 Ax7 Jog Feed [mm/min]"}
    VQ_AX7_FOLL_NUM           AT %MD500.7124 : DINT; {DE:"vq7124 Ax7 Follow factor numerator"}
    VQ_AX7_FOLL_DEN           AT %MD500.7125 : DINT; {DE:"vq7125 Ax7 Follow factor denominator"}
    VQ_AX7_BOB_AVA            AT %MD500.7126 : DINT; {DE:"vq7126 Ax7 Reversing forward Threshold"}
    VQ_AX7_BOB_IND            AT %MD500.7127 : DINT; {DE:"vq7127 Ax7 Reversing backward Threshold"}
    VQ_AX7_FEED_SEMI          AT %MD500.7131 : DINT; {DE:"vq7131 Ax7 Jog and Semi-automatic Feed"}
    VQ_AX7_CUR_FEED           AT %MD500.7132 : DINT; {DE:"vq7132 Ax7 Instantaneous Speed Theoretical module"}
    VQ_AX7_VEL_RIF_IMP_S      AT %MD500.7133 : DINT; {DE:"vq7133 Ax7 Speed Test result"}
    VQ_AX7_MONITOR_1          AT %MD500.7134 : DINT; {DE:"vq7134 Ax7 Monitor 1        "}
    VQ_AX7_MONITOR_2          AT %MD500.7135 : DINT; {DE:"vq7135 Ax7 Monitor 2        "}
    
    {G:"AXIS-8 Variables"}

    VB_AX8_JOG_PIU            AT %MB300.7141 : BOOL; {DE:"vb7141 Ax8 Jog+"}
    VB_AX8_JOG_MENO           AT %MB300.7142 : BOOL; {DE:"vb7142 Ax8 Jog-"}
    VB_AX8_JOG_INCR_PIU       AT %MB300.7143 : BOOL; {DE:"vb7143 Ax8 Incremental Jog+"}
    VB_AX8_JOG_INCR_MENO      AT %MB300.7144 : BOOL; {DE:"vb7144 Ax8 Incremental Jog-"}
    VB_AX8_START_SEMI         AT %MB300.7145 : BOOL; {DE:"vb7145 Ax8 Start Semi-automatic"}
    VB_AX8_START_ZERO         AT %MB300.7146 : BOOL; {DE:"vb7146 Ax8 Start Zero"}
    VB_AX8_PID_DISAB          AT %MB300.7147 : BOOL; {DE:"vb7147 Ax8 PID disable"}
    VB_AX8_START_DISAB        AT %MB300.7148 : BOOL; {DE:"vb7148 Ax8 Start disable"}
    VB_AX8_MOVE_DISAB         AT %MB300.7149 : BOOL; {DE:"vb7149 Ax8 Move disable"}
    VB_AX8_RAPIDO_FEED        AT %MB300.7150 : BOOL; {DE:"vb7150 Ax8 Use Fast Feed Vq"}
    VB_AX8_BOB_INV_DIR        AT %MB300.7151 : BOOL; {DE:"vb7151 Ax8 Reverse winder direction"}
    VB_AX8_GET_ORIG           AT %MB300.7152 : BOOL; {DE:"vb7152 Ax8 Enable origin acquisition"}
    VB_AX8_ZEROED             AT %MB300.7153 : BOOL; {DE:"vb7153 Ax8 Zeroed"}
    VB_AX8_IN_QUOTE           AT %MB300.7154 : BOOL; {DE:"vb7154 Ax8 In position"}
    VB_AX8_START_TST_VEL      AT %MB300.7155 : BOOL; {DE:"vb7155 Ax8 Start Speed Test"}
    VB_AX8_IN_TEST            AT %MB300.7156 : BOOL; {DE:"vb7156 Ax8 In Test Mode"}
    VB_AX8_USE_QUO_JOG        AT %MB300.7157 : BOOL; {DE:"vb7157 Ax8 Jog: use specific Vq"}

    VN_AX8_OVERRIDE           AT %MW400.3141 : INT;  {DE:"vn3141 Ax8 Indipendent Override"}
    VN_AX8_VEL_PERC_JOG       AT %MW400.3142 : INT;  {DE:"vn3142 Ax8 Jog Speed %"}
    VN_AX8_FOLL_MODE          AT %MW400.3143 : INT;  {DE:"vn3143 Ax8 Follow mode"}
    VN_AX8_FOLL_CONF          AT %MW400.3144 : INT;  {DE:"vn3144 Ax8 Follow configuration"}
    VN_AX8_FOLL_MASTER_NUM    AT %MW400.3145 : INT;  {DE:"vn3145 Ax8 N. of encoder to follow"}
    VN_AX8_FOLL_ERR           AT %MW400.3146 : INT;  {DE:"vn3146 Ax8 Follow functions error code"}
    VN_AX8_CMD_DRIVE          AT %MW400.3147 : INT;  {DE:"vn3147 Ax8 Control word to digital drive (bit)"}
    VN_AX8_VEL_PERC_SEMI      AT %MW400.3149 : INT;  {DE:"vn3149 Ax8 Semi-automatic Speed %"}
    VN_AX8_VEL_PERC_TST_VEL   AT %MW400.3150 : INT;  {DE:"vn3150 Ax8 Speed-Test speed %"}
    VN_AX8_FASE_ZERO          AT %MW400.3151 : INT;  {DE:"vn3151 Ax8 Reset phase"}
    VN_AX8_FASE               AT %MW400.3152 : INT;  {DE:"vn3152 Ax8 Phase"}
    VN_AX8_STATO              AT %MW400.3153 : INT;  {DE:"vn3153 Ax8 Status (bit)"}
    VN_AX8_STATO_ISO          AT %MW400.3154 : INT;  {DE:"vn3154 Ax8 ISO status (bit)"}
    VN_AX8_STATO_DRIVE        AT %MW400.3155 : INT;  {DE:"vn3155 Ax8 Status word from digital drive (bit)"}

    VQ_AX8_INCR_JOG           AT %MD500.7141 : DINT; {DE:"vq7141 Ax8 Jog increase"}
    VQ_AX8_QUO_SEMI           AT %MD500.7142 : DINT; {DE:"vq7142 Ax8 Semi-automatic position"}
    VQ_AX8_FEED_JOG           AT %MD500.7143 : DINT; {DE:"vq7143 Ax8 Jog Feed [mm/min]"}
    VQ_AX8_FOLL_NUM           AT %MD500.7144 : DINT; {DE:"vq7144 Ax8 Follow factor numerator"}
    VQ_AX8_FOLL_DEN           AT %MD500.7145 : DINT; {DE:"vq7145 Ax8 Follow factor denominator"}
    VQ_AX8_BOB_AVA            AT %MD500.7146 : DINT; {DE:"vq7146 Ax8 Reversing forward Threshold"}
    VQ_AX8_BOB_IND            AT %MD500.7147 : DINT; {DE:"vq7147 Ax8 Reversing backward Threshold"}
    VQ_AX8_FEED_SEMI          AT %MD500.7151 : DINT; {DE:"vq7151 Ax8 Jog and Semi-automatic Feed"}
    VQ_AX8_CUR_FEED           AT %MD500.7152 : DINT; {DE:"vq7152 Ax8 Instantaneous Speed Theoretical module"}
    VQ_AX8_VEL_RIF_IMP_S      AT %MD500.7153 : DINT; {DE:"vq7153 Ax8 Speed Test result"}
    VQ_AX8_MONITOR_1          AT %MD500.7154 : DINT; {DE:"vq7154 Ax8 Monitor 1        "}
    VQ_AX8_MONITOR_2          AT %MD500.7155 : DINT; {DE:"vq7155 Ax8 Monitor 2        "}
    
END_VAR
]]>
			</lib>
			<lib name="C:\Program Files (x86)\Sipro\Siax PC Tools\Catalog\SiaxM32\PLC\Ax9_12_v1.pll" fullXml="false" link="true">
				<![CDATA[(*
 *
 * MDPlc source file: Ax9_12_v1.pll
 * for project:
 * 20.04.2012 - s.v.
 *)


VAR_GLOBAL

    {G:"AXIS-9 Variables"}

    VB_AX9_JOG_PIU             AT %MB300.7161 : BOOL; {DE:"vb7161 Ax9 Jog+"}
    VB_AX9_JOG_MENO            AT %MB300.7162 : BOOL; {DE:"vb7162 Ax9 Jog-"}
    VB_AX9_JOG_INCR_PIU        AT %MB300.7163 : BOOL; {DE:"vb7163 Ax9 Incremental Jog+"}
    VB_AX9_JOG_INCR_MENO       AT %MB300.7164 : BOOL; {DE:"vb7164 Ax9 Incremental Jog-"}
    VB_AX9_START_SEMI          AT %MB300.7165 : BOOL; {DE:"vb7165 Ax9 Start Semi-automatic"}
    VB_AX9_START_ZERO          AT %MB300.7166 : BOOL; {DE:"vb7166 Ax9 Start Zero"}
    VB_AX9_PID_DISAB           AT %MB300.7167 : BOOL; {DE:"vb7167 Ax9 PID disable"}
    VB_AX9_START_DISAB         AT %MB300.7168 : BOOL; {DE:"vb7168 Ax9 Start disable"}
    VB_AX9_MOVE_DISAB          AT %MB300.7169 : BOOL; {DE:"vb7169 Ax9 Move disable"}
    VB_AX9_RAPIDO_FEED         AT %MB300.7170 : BOOL; {DE:"vb7170 Ax9 Use Fast Feed Vq"}
    VB_AX9_BOB_INV_DIR         AT %MB300.7171 : BOOL; {DE:"vb7171 Ax9 Reverse winder direction"}
    VB_AX9_GET_ORIG            AT %MB300.7172 : BOOL; {DE:"vb7172 Ax9 Enable origin acquisition"}
    VB_AX9_ZEROED              AT %MB300.7173 : BOOL; {DE:"vb7173 Ax9 Zeroed"}
    VB_AX9_IN_QUOTE            AT %MB300.7174 : BOOL; {DE:"vb7174 Ax9 In position"}
    VB_AX9_START_TST_VEL       AT %MB300.7175 : BOOL; {DE:"vb7175 Ax9 Start Speed Test"}
    VB_AX9_IN_TEST             AT %MB300.7176 : BOOL; {DE:"vb7176 Ax9 In Test Mode"}
    VB_AX9_USE_QUO_JOG         AT %MB300.7177 : BOOL; {DE:"vb7177 Ax9 Jog: use specific Vq"}

    VN_AX9_OVERRIDE            AT %MW400.3161 : INT;  {DE:"vn3161 Ax9 Indipendent Override"}
    VN_AX9_VEL_PERC_JOG        AT %MW400.3162 : INT;  {DE:"vn3162 Ax9 Jog Speed %"}
    VN_AX9_FOLL_MODE           AT %MW400.3163 : INT;  {DE:"vn3163 Ax9 Follow mode"}
    VN_AX9_FOLL_CONF           AT %MW400.3164 : INT;  {DE:"vn3164 Ax9 Follow configuration"}
    VN_AX9_FOLL_MASTER_NUM     AT %MW400.3165 : INT;  {DE:"vn3165 Ax9 N. of encoder to follow"}
    VN_AX9_FOLL_ERR            AT %MW400.3166 : INT;  {DE:"vn3166 Ax9 Follow functions error code"}
    VN_AX9_CMD_DRIVE           AT %MW400.3167 : INT;  {DE:"vn3167 Ax9 Control word to digital drive (bit)"}
    VN_AX9_VEL_PERC_SEMI       AT %MW400.3169 : INT;  {DE:"vn3169 Ax9 Semi-automatic Speed %"}
    VN_AX9_VEL_PERC_TST_VEL    AT %MW400.3170 : INT;  {DE:"vn3170 Ax9 Speed-Test speed %"}
    VN_AX9_FASE_ZERO           AT %MW400.3171 : INT;  {DE:"vn3171 Ax9 Reset phase"}
    VN_AX9_FASE                AT %MW400.3172 : INT;  {DE:"vn3172 Ax9 Phase"}
    VN_AX9_STATO               AT %MW400.3173 : INT;  {DE:"vn3173 Ax9 Status (bit)"}
    VN_AX9_STATO_ISO           AT %MW400.3174 : INT;  {DE:"vn3174 Ax9 ISO status (bit)"}
    VN_AX9_STATO_DRIVE         AT %MW400.3175 : INT;  {DE:"vn3175 Ax9 Status word from digital drive (bit)"}

    VQ_AX9_INCR_JOG            AT %MD500.7161 : DINT; {DE:"vq7161 Ax9 Jog increase"}
    VQ_AX9_QUO_SEMI            AT %MD500.7162 : DINT; {DE:"vq7162 Ax9 Semi-automatic position"}
    VQ_AX9_FEED_JOG            AT %MD500.7163 : DINT; {DE:"vq7163 Ax9 Jog Feed [mm/min]"}
    VQ_AX9_FOLL_NUM            AT %MD500.7164 : DINT; {DE:"vq7164 Ax9 Follow factor numerator"}
    VQ_AX9_FOLL_DEN            AT %MD500.7165 : DINT; {DE:"vq7165 Ax9 Follow factor denominator"}
    VQ_AX9_BOB_AVA             AT %MD500.7166 : DINT; {DE:"vq7166 Ax9 Reversing forward Threshold"}
    VQ_AX9_BOB_IND             AT %MD500.7167 : DINT; {DE:"vq7167 Ax9 Reversing backward Threshold"}
    VQ_AX9_FEED_SEMI           AT %MD500.7171 : DINT; {DE:"vq7171 Ax9 Jog and Semi-automatic Feed"}
    VQ_AX9_CUR_FEED            AT %MD500.7172 : DINT; {DE:"vq7172 Ax9 Instantaneous Speed Theoretical module"}
    VQ_AX9_VEL_RIF_IMP_S       AT %MD500.7173 : DINT; {DE:"vq7173 Ax9 Speed Test result"}
    VQ_AX9_MONITOR_1           AT %MD500.7174 : DINT; {DE:"vq7174 Ax9 Monitor 1        "}
    VQ_AX9_MONITOR_2           AT %MD500.7175 : DINT; {DE:"vq7175 Ax9 Monitor 2        "}
    
    {G:"AXIS-10 Variables"}

    VB_AX10_JOG_PIU            AT %MB300.7181 : BOOL; {DE:"vb7181 Ax10 Jog+"}
    VB_AX10_JOG_MENO           AT %MB300.7182 : BOOL; {DE:"vb7182 Ax10 Jog-"}
    VB_AX10_JOG_INCR_PIU       AT %MB300.7183 : BOOL; {DE:"vb7183 Ax10 Incremental Jog+"}
    VB_AX10_JOG_INCR_MENO      AT %MB300.7184 : BOOL; {DE:"vb7184 Ax10 Incremental Jog-"}
    VB_AX10_START_SEMI         AT %MB300.7185 : BOOL; {DE:"vb7185 Ax10 Start Semi-automatic"}
    VB_AX10_START_ZERO         AT %MB300.7186 : BOOL; {DE:"vb7186 Ax10 Start Zero"}
    VB_AX10_PID_DISAB          AT %MB300.7187 : BOOL; {DE:"vb7187 Ax10 PID disable"}
    VB_AX10_START_DISAB        AT %MB300.7188 : BOOL; {DE:"vb7188 Ax10 Start disable"}
    VB_AX10_MOVE_DISAB         AT %MB300.7189 : BOOL; {DE:"vb7189 Ax10 Move disable"}
    VB_AX10_RAPIDO_FEED        AT %MB300.7190 : BOOL; {DE:"vb7190 Ax10 Use Fast Feed Vq"}
    VB_AX10_BOB_INV_DIR        AT %MB300.7191 : BOOL; {DE:"vb7191 Ax10 Reverse winder direction"}
    VB_AX10_GET_ORIG           AT %MB300.7192 : BOOL; {DE:"vb7192 Ax10 Enable origin acquisition"}
    VB_AX10_ZEROED             AT %MB300.7193 : BOOL; {DE:"vb7193 Ax10 Zeroed"}
    VB_AX10_IN_QUOTE           AT %MB300.7194 : BOOL; {DE:"vb7194 Ax10 In position"}
    VB_AX10_START_TST_VEL      AT %MB300.7195 : BOOL; {DE:"vb7195 Ax10 Start Speed Test"}
    VB_AX10_IN_TEST            AT %MB300.7196 : BOOL; {DE:"vb7196 Ax10 In Test Mode"}
    VB_AX10_USE_QUO_JOG        AT %MB300.7197 : BOOL; {DE:"vb7197 Ax10 Jog: use specific Vq"}

    VN_AX10_OVERRIDE           AT %MW400.3181 : INT;  {DE:"vn3181 Ax10 Indipendent Override"}
    VN_AX10_VEL_PERC_JOG       AT %MW400.3182 : INT;  {DE:"vn3182 Ax10 Jog Speed %"}
    VN_AX10_FOLL_MODE          AT %MW400.3183 : INT;  {DE:"vn3183 Ax10 Follow mode"}
    VN_AX10_FOLL_CONF          AT %MW400.3184 : INT;  {DE:"vn3184 Ax10 Follow configuration"}
    VN_AX10_FOLL_MASTER_NUM    AT %MW400.3185 : INT;  {DE:"vn3185 Ax10 N. of encoder to follow"}
    VN_AX10_FOLL_ERR           AT %MW400.3186 : INT;  {DE:"vn3186 Ax10 Follow functions error code"}
    VN_AX10_CMD_DRIVE          AT %MW400.3187 : INT;  {DE:"vn3187 Ax10 Control word to digital drive (bit)"}
    VN_AX10_VEL_PERC_SEMI      AT %MW400.3189 : INT;  {DE:"vn3189 Ax10 Semi-automatic Speed %"}
    VN_AX10_VEL_PERC_TST_VEL   AT %MW400.3190 : INT;  {DE:"vn3190 Ax10 Speed-Test speed %"}
    VN_AX10_FASE_ZERO          AT %MW400.3191 : INT;  {DE:"vn3191 Ax10 Reset phase"}
    VN_AX10_FASE               AT %MW400.3192 : INT;  {DE:"vn3192 Ax10 Phase"}
    VN_AX10_STATO              AT %MW400.3193 : INT;  {DE:"vn3193 Ax10 Status (bit)"}
    VN_AX10_STATO_ISO          AT %MW400.3194 : INT;  {DE:"vn3194 Ax10 ISO status (bit)"}
    VN_AX10_STATO_DRIVE        AT %MW400.3195 : INT;  {DE:"vn3195 Ax10 Status word from digital drive (bit)"}

    VQ_AX10_INCR_JOG           AT %MD500.7181 : DINT; {DE:"vq7181 Ax10 Jog increase"}
    VQ_AX10_QUO_SEMI           AT %MD500.7182 : DINT; {DE:"vq7182 Ax10 Semi-automatic position"}
    VQ_AX10_FEED_JOG           AT %MD500.7183 : DINT; {DE:"vq7183 Ax10 Jog Feed [mm/min]"}
    VQ_AX10_FOLL_NUM           AT %MD500.7184 : DINT; {DE:"vq7184 Ax10 Follow factor numerator"}
    VQ_AX10_FOLL_DEN           AT %MD500.7185 : DINT; {DE:"vq7185 Ax10 Follow factor denominator"}
    VQ_AX10_BOB_AVA            AT %MD500.7186 : DINT; {DE:"vq7186 Ax10 Reversing forward Threshold"}
    VQ_AX10_BOB_IND            AT %MD500.7187 : DINT; {DE:"vq7187 Ax10 Reversing backward Threshold"}
    VQ_AX10_FEED_SEMI          AT %MD500.7191 : DINT; {DE:"vq7191 Ax10 Jog and Semi-automatic Feed"}
    VQ_AX10_CUR_FEED           AT %MD500.7192 : DINT; {DE:"vq7192 Ax10 Instantaneous Speed Theoretical module"}
    VQ_AX10_VEL_RIF_IMP_S      AT %MD500.7193 : DINT; {DE:"vq7193 Ax10 Speed Test result"}
    VQ_AX10_MONITOR_1          AT %MD500.7194 : DINT; {DE:"vq7194 Ax10 Monitor 1       "}
    VQ_AX10_MONITOR_2          AT %MD500.7195 : DINT; {DE:"vq7195 Ax10 Monitor 2       "}
    
    {G:"AXIS-11 Variables"}

    VB_AX11_JOG_PIU            AT %MB300.7201 : BOOL; {DE:"vb7201 Ax11 Jog+"}
    VB_AX11_JOG_MENO           AT %MB300.7202 : BOOL; {DE:"vb7202 Ax11 Jog-"}
    VB_AX11_JOG_INCR_PIU       AT %MB300.7203 : BOOL; {DE:"vb7203 Ax11 Incremental Jog+"}
    VB_AX11_JOG_INCR_MENO      AT %MB300.7204 : BOOL; {DE:"vb7204 Ax11 Incremental Jog-"}
    VB_AX11_START_SEMI         AT %MB300.7205 : BOOL; {DE:"vb7205 Ax11 Start Semi-automatic"}
    VB_AX11_START_ZERO         AT %MB300.7206 : BOOL; {DE:"vb7206 Ax11 Start Zero"}
    VB_AX11_PID_DISAB          AT %MB300.7207 : BOOL; {DE:"vb7207 Ax11 PID disable"}
    VB_AX11_START_DISAB        AT %MB300.7208 : BOOL; {DE:"vb7208 Ax11 Start disable"}
    VB_AX11_MOVE_DISAB         AT %MB300.7209 : BOOL; {DE:"vb7209 Ax11 Move disable"}
    VB_AX11_RAPIDO_FEED        AT %MB300.7210 : BOOL; {DE:"vb7210 Ax11 Use Fast Feed Vq"}
    VB_AX11_BOB_INV_DIR        AT %MB300.7211 : BOOL; {DE:"vb7211 Ax11 Reverse winder direction"}
    VB_AX11_GET_ORIG           AT %MB300.7212 : BOOL; {DE:"vb7212 Ax11 Enable origin acquisition"}
    VB_AX11_ZEROED             AT %MB300.7213 : BOOL; {DE:"vb7213 Ax11 Zeroed"}
    VB_AX11_IN_QUOTE           AT %MB300.7214 : BOOL; {DE:"vb7214 Ax11 In position"}
    VB_AX11_START_TST_VEL      AT %MB300.7215 : BOOL; {DE:"vb7215 Ax11 Start Speed Test"}
    VB_AX11_IN_TEST            AT %MB300.7216 : BOOL; {DE:"vb7216 Ax11 In Test Mode"}
    VB_AX11_USE_QUO_JOG        AT %MB300.7217 : BOOL; {DE:"vb7217 Ax11 Jog: use specific Vq"}

    VN_AX11_OVERRIDE           AT %MW400.3201 : INT;  {DE:"vn3201 Ax11 Indipendent Override"}
    VN_AX11_VEL_PERC_JOG       AT %MW400.3202 : INT;  {DE:"vn3202 Ax11 Jog Speed %"}
    VN_AX11_FOLL_MODE          AT %MW400.3203 : INT;  {DE:"vn3203 Ax11 Follow mode"}
    VN_AX11_FOLL_CONF          AT %MW400.3204 : INT;  {DE:"vn3204 Ax11 Follow configuration"}
    VN_AX11_FOLL_MASTER_NUM    AT %MW400.3205 : INT;  {DE:"vn3205 Ax11 N. of encoder to follow"}
    VN_AX11_FOLL_ERR           AT %MW400.3206 : INT;  {DE:"vn3206 Ax11 Follow functions error code"}
    VN_AX11_CMD_DRIVE          AT %MW400.3207 : INT;  {DE:"vn3207 Ax11 Control word to digital drive (bit)"}
    VN_AX11_VEL_PERC_SEMI      AT %MW400.3209 : INT;  {DE:"vn3209 Ax11 Semi-automatic Speed %"}
    VN_AX11_VEL_PERC_TST_VEL   AT %MW400.3210 : INT;  {DE:"vn3210 Ax11 Speed-Test speed %"}
    VN_AX11_FASE_ZERO          AT %MW400.3211 : INT;  {DE:"vn3211 Ax11 Reset phase"}
    VN_AX11_FASE               AT %MW400.3212 : INT;  {DE:"vn3212 Ax11 Phase"}
    VN_AX11_STATO              AT %MW400.3213 : INT;  {DE:"vn3213 Ax11 Status (bit)"}
    VN_AX11_STATO_ISO          AT %MW400.3214 : INT;  {DE:"vn3214 Ax11 ISO status (bit)"}
    VN_AX11_STATO_DRIVE        AT %MW400.3215 : INT;  {DE:"vn3215 Ax11 Status word from digital drive (bit)"}

    VQ_AX11_INCR_JOG           AT %MD500.7201 : DINT; {DE:"vq7201 Ax11 Jog increase"}
    VQ_AX11_QUO_SEMI           AT %MD500.7202 : DINT; {DE:"vq7202 Ax11 Semi-automatic position"}
    VQ_AX11_FEED_JOG           AT %MD500.7203 : DINT; {DE:"vq7203 Ax11 Jog Feed [mm/min]"}
    VQ_AX11_FOLL_NUM           AT %MD500.7204 : DINT; {DE:"vq7204 Ax11 Follow factor numerator"}
    VQ_AX11_FOLL_DEN           AT %MD500.7205 : DINT; {DE:"vq7205 Ax11 Follow factor denominator"}
    VQ_AX11_BOB_AVA            AT %MD500.7206 : DINT; {DE:"vq7206 Ax11 Reversing forward Threshold"}
    VQ_AX11_BOB_IND            AT %MD500.7207 : DINT; {DE:"vq7207 Ax11 Reversing backward Threshold"}
    VQ_AX11_FEED_SEMI          AT %MD500.7211 : DINT; {DE:"vq7211 Ax11 Jog and Semi-automatic Feed"}
    VQ_AX11_CUR_FEED           AT %MD500.7212 : DINT; {DE:"vq7212 Ax11 Instantaneous Speed Theoretical module"}
    VQ_AX11_VEL_RIF_IMP_S      AT %MD500.7213 : DINT; {DE:"vq7213 Ax11 Speed Test result"}
    VQ_AX11_MONITOR_1          AT %MD500.7214 : DINT; {DE:"vq7214 Ax11 Monitor 1       "}
    VQ_AX11_MONITOR_2          AT %MD500.7215 : DINT; {DE:"vq7215 Ax11 Monitor 2       "}
    
    {G:"AXIS-12 Variables"}

    VB_AX12_JOG_PIU            AT %MB300.7221 : BOOL; {DE:"vb7221 Ax12 Jog+"}
    VB_AX12_JOG_MENO           AT %MB300.7222 : BOOL; {DE:"vb7222 Ax12 Jog-"}
    VB_AX12_JOG_INCR_PIU       AT %MB300.7223 : BOOL; {DE:"vb7223 Ax12 Incremental Jog+"}
    VB_AX12_JOG_INCR_MENO      AT %MB300.7224 : BOOL; {DE:"vb7224 Ax12 Incremental Jog-"}
    VB_AX12_START_SEMI         AT %MB300.7225 : BOOL; {DE:"vb7225 Ax12 Start Semi-automatic"}
    VB_AX12_START_ZERO         AT %MB300.7226 : BOOL; {DE:"vb7226 Ax12 Start Zero"}
    VB_AX12_PID_DISAB          AT %MB300.7227 : BOOL; {DE:"vb7227 Ax12 PID disable"}
    VB_AX12_START_DISAB        AT %MB300.7228 : BOOL; {DE:"vb7228 Ax12 Start disable"}
    VB_AX12_MOVE_DISAB         AT %MB300.7229 : BOOL; {DE:"vb7229 Ax12 Move disable"}
    VB_AX12_RAPIDO_FEED        AT %MB300.7230 : BOOL; {DE:"vb7230 Ax12 Use Fast Feed Vq"}
    VB_AX12_BOB_INV_DIR        AT %MB300.7231 : BOOL; {DE:"vb7231 Ax12 Reverse winder direction"}
    VB_AX12_GET_ORIG           AT %MB300.7232 : BOOL; {DE:"vb7232 Ax12 Enable origin acquisition"}
    VB_AX12_ZEROED             AT %MB300.7233 : BOOL; {DE:"vb7233 Ax12 Zeroed"}
    VB_AX12_IN_QUOTE           AT %MB300.7234 : BOOL; {DE:"vb7234 Ax12 In position"}
    VB_AX12_START_TST_VEL      AT %MB300.7235 : BOOL; {DE:"vb7235 Ax12 Start Speed Test"}
    VB_AX12_IN_TEST            AT %MB300.7236 : BOOL; {DE:"vb7236 Ax12 In Test Mode"}
    VB_AX12_USE_QUO_JOG        AT %MB300.7237 : BOOL; {DE:"vb7237 Ax12 Jog: use specific Vq"}

    VN_AX12_OVERRIDE           AT %MW400.3221 : INT;  {DE:"vn3221 Ax12 Indipendent Override"}
    VN_AX12_VEL_PERC_JOG       AT %MW400.3222 : INT;  {DE:"vn3222 Ax12 Jog Speed %"}
    VN_AX12_FOLL_MODE          AT %MW400.3223 : INT;  {DE:"vn3223 Ax12 Follow mode"}
    VN_AX12_FOLL_CONF          AT %MW400.3224 : INT;  {DE:"vn3224 Ax12 Follow configuration"}
    VN_AX12_FOLL_MASTER_NUM    AT %MW400.3225 : INT;  {DE:"vn3225 Ax12 N. of encoder to follow"}
    VN_AX12_FOLL_ERR           AT %MW400.3226 : INT;  {DE:"vn3226 Ax12 Follow functions error code"}
    VN_AX12_CMD_DRIVE          AT %MW400.3227 : INT;  {DE:"vn3227 Ax12 Control word to digital drive (bit)"}
    VN_AX12_VEL_PERC_SEMI      AT %MW400.3229 : INT;  {DE:"vn3229 Ax12 Semi-automatic Speed %"}
    VN_AX12_VEL_PERC_TST_VEL   AT %MW400.3230 : INT;  {DE:"vn3230 Ax12 Speed-Test speed %"}
    VN_AX12_FASE_ZERO          AT %MW400.3231 : INT;  {DE:"vn3231 Ax12 Reset phase"}
    VN_AX12_FASE               AT %MW400.3232 : INT;  {DE:"vn3232 Ax12 Phase"}
    VN_AX12_STATO              AT %MW400.3233 : INT;  {DE:"vn3233 Ax12 Status (bit)"}
    VN_AX12_STATO_ISO          AT %MW400.3234 : INT;  {DE:"vn3234 Ax12 ISO status (bit)"}
    VN_AX12_STATO_DRIVE        AT %MW400.3235 : INT;  {DE:"vn3235 Ax12 Status word from digital drive (bit)"}

    VQ_AX12_INCR_JOG           AT %MD500.7221 : DINT; {DE:"vq7221 Ax12 Jog increase"}
    VQ_AX12_QUO_SEMI           AT %MD500.7222 : DINT; {DE:"vq7222 Ax12 Semi-automatic position"}
    VQ_AX12_FEED_JOG           AT %MD500.7223 : DINT; {DE:"vq7223 Ax12 Jog Feed [mm/min]"}
    VQ_AX12_FOLL_NUM           AT %MD500.7224 : DINT; {DE:"vq7224 Ax12 Follow factor numerator"}
    VQ_AX12_FOLL_DEN           AT %MD500.7225 : DINT; {DE:"vq7225 Ax12 Follow factor denominator"}
    VQ_AX12_BOB_AVA            AT %MD500.7226 : DINT; {DE:"vq7226 Ax12 Reversing forward Threshold"}
    VQ_AX12_BOB_IND            AT %MD500.7227 : DINT; {DE:"vq7227 Ax12 Reversing backward Threshold"}
    VQ_AX12_FEED_SEMI          AT %MD500.7231 : DINT; {DE:"vq7231 Ax12 Jog and Semi-automatic Feed"}
    VQ_AX12_CUR_FEED           AT %MD500.7232 : DINT; {DE:"vq7232 Ax12 Instantaneous Speed Theoretical module"}
    VQ_AX12_VEL_RIF_IMP_S      AT %MD500.7233 : DINT; {DE:"vq7233 Ax12 Speed Test result"}
    VQ_AX12_MONITOR_1          AT %MD500.7234 : DINT; {DE:"vq7234 Ax12 Monitor 1       "}
    VQ_AX12_MONITOR_2          AT %MD500.7235 : DINT; {DE:"vq7235 Ax12 Monitor 2       "}
    
END_VAR
]]>
			</lib>
			<lib name="C:\Program Files (x86)\Sipro\Siax PC Tools\Catalog\SiaxM32\PLC\Chn2_v1.pll" fullXml="false" link="true">
				<![CDATA[(*
 *
 * MDPlc source file: Chn2_v1.pll
 * for project:
 * 20.04.2012 - s.v.
 *)


VAR_GLOBAL

    {G:"Channel-2 Variables"}

    VB_CHN2_START              AT %MB300.7921 : BOOL; {DE:"vb7921 Start"}
    VB_CHN2_STOP_HOLD          AT %MB300.7922 : BOOL; {DE:"vb7922 Hold"}
    VB_CHN2_RESET              AT %MB300.7923 : BOOL; {DE:"vb7923 Reset"}
    VB_CHN2_RELEASE            AT %MB300.7924 : BOOL; {DE:"vb7924 Release"}
    VB_CHN2_EXEC_SINGLE        AT %MB300.7925 : BOOL; {DE:"vb7925 Single"}
    VB_CHN2_HOLD_AXES          AT %MB300.7926 : BOOL; {DE:"vb7926 Hold Axes"}
    VB_CHN2_START_ZERO         AT %MB300.7927 : BOOL; {DE:"vb7927 Start Zero Sequence"}
    VB_CHN2_AUTO_RUNNING       AT %MB300.7928 : BOOL; {DE:"vb7928 Auto Running"}
    VB_CHN2_IN_EMERG           AT %MB300.7929 : BOOL; {DE:"vb7929 Emergency"}
    VB_CHN2_UDT_BUSY           AT %MB300.7930 : BOOL; {DE:"vb7930 Udt Busy"}
    VB_CHN2_I_JOG_PIU          AT %MB300.7931 : BOOL; {DE:"vb7931 Jog+ Single Operation"}
    VB_CHN2_I_JOG_MENO         AT %MB300.7932 : BOOL; {DE:"vb7932 Jog- Single Operation"}
    VB_CHN2_I_START            AT %MB300.7933 : BOOL; {DE:"vb7933 Start Single Operation"}
    VB_CHN2_START_CMDA         AT %MB300.7935 : BOOL; {DE:"vb7935 CMDA Start Command"}
    VB_CHN2_JOG_INTP           AT %MB300.7936 : BOOL; {DE:"vb7936 Interpolated Jog enable"}
    VB_CHN2_JOG_RETRACT        AT %MB300.7937 : BOOL; {DE:"vb7937 Jog Retract            "}
    VB_CHN2_IN_MOVE_SINGLE     AT %MB300.7938 : BOOL; {DE:"vb7938 Interpolated Movement Single Execution"}    
    
    VN_CHN2_OVERRIDE_G1        AT %MW400.3921 : INT;  {DE:"vn3921 Override Feed G1"}
    VN_CHN2_OVERRIDE_G0        AT %MW400.3922 : INT;  {DE:"vn3922 Override Feed G0"}
    VN_CHN2_OVERRIDE_SPEED     AT %MW400.3923 : INT;  {DE:"vn3923 Override Speed"}
    VN_CHN2_ORIG_ACT           AT %MW400.3925 : INT;  {DE:"vn3925 Active Origin"}
    VN_CHN2_STATUS             AT %MW400.3926 : INT;  {DE:"vn3926 Channel Status"}
    VN_CHN2_INTP_STATUS        AT %MW400.3927 : INT;  {DE:"vn3927 Interpolator Status"}
    VN_CHN2_GRP_STATUS         AT %MW400.3928 : INT;  {DE:"vn3928 Interpolator Group Status"}
    VN_CHN2_STATUS_CMDA        AT %MW400.3929 : INT;  {DE:"vn3929 CMDA management status"}
    VN_CHN2_UDT_STATUS         AT %MW400.3930 : INT;  {DE:"vn3930 UDT management status"}
    VN_CHN2_ENAB_SINGLE_OPER   AT %MW400.3931 : INT;  {DE:"vn3931 Vb single operation enable"}
    VN_CHN2_ENAB_OPER          AT %MW400.3932 : INT;  {DE:"vn3932 Operations enable"}
    VN_CHN2_STATO_INTERF       AT %MW400.3933 : INT;  {DE:"vn3933 Operator interface state"}
    VN_CHN2_TGS_STATUS         AT %MW400.3934 : INT;  {DE:"vn3934 Teach management state"}
    VN_CHN2_FILE_REQ           AT %MW400.3935 : INT;  {DE:"vn3935 NC file request"}
    VN_CHN2_PROT_UDT_BUSY      AT %MW400.3936 : INT;  {DE:"vn3936 Cnt Protocol udt Command not executed cause there is another command active"}
    VN_CHN2_PLC_UDT_BUSY       AT %MW400.3937 : INT;  {DE:"vn3937 Cnt Plc udt Command not executed cause there is another command active"}
    
    VN_CHN2_READ_TOOL_NUM      AT %MW400.4066 : INT;  {DE:"vn4066 Tool Read"}
    VN_CHN2_MOUNT_TOOL_NUM     AT %MW400.4067 : INT;  {DE:"vn4067 Tool Mount"}
    VN_CHN2_GOSUB_PAR          AT %MW400.4068 : INT;  {DE:"vn4068 Gosub Parameter"}
    VN_CHN2_SPINDLE_DIR        AT %MW400.4069 : INT;  {DE:"vn4069 Spindle linked to interpolated group direction"}    
    
    VQ_CHN2_CUR_SPEED          AT %MD500.7924 : DINT; {DE:"vq7924 Current Speed"}
    VQ_CHN2_SET_SPEED          AT %MD500.7925 : DINT; {DE:"vq7925 Set Speed"}
    VQ_CHN2_GOSUB_PAR          AT %MD500.7926 : DINT; {DE:"vq7926 Gosub Parameter"}
    VQ_CHN2_DELAY_TIMER        AT %MD500.7927 : DINT; {DE:"vq7927 Residual Delay Time"}
    VQ_CHN2_CUR_FEED           AT %MD500.7928 : DINT; {DE:"vq7928 Current Feed [mm/min]"}
    VQ_CHN2_SET_FEED           AT %MD500.7929 : DINT; {DE:"vq7929 Set Feed [mm/min]"}
    VQ_CHN2_AX_SEL             AT %MD500.7931 : DINT; {DE:"vq7931 Axes selection"}
    VQ_CHN2_JOG_INTP_FEED      AT %MD500.7932 : DINT; {DE:"vq7932 Interpoled Jog Feed [mm/min]"}
    VQ_CHN2_INCR_JOG_INTP      AT %MD500.7933 : DINT; {DE:"vq7933 Interpoled Jog increase"}
    
    VQ_CHN2_PIECE_DIM_X        AT %MD500.8081 : DINT; {DE:"vq8081 Piece Dim X"}
    VQ_CHN2_PIECE_DIM_Y        AT %MD500.8082 : DINT; {DE:"vq8082 Piece Dim Y"}
    VQ_CHN2_PIECE_DIM_Z        AT %MD500.8083 : DINT; {DE:"vq8083 Piece Dim Z"}
    VQ_CHN2_MNT_TOOL_RADIUS    AT %MD500.8084 : DINT; {DE:"vq8084 Mount Tool Radius"}
    VQ_CHN2_MNT_TOOL_LENGTH    AT %MD500.8085 : DINT; {DE:"vq8085 Mount Tool Length"}

END_VAR
]]>
			</lib>
			<lib name="C:\Program Files (x86)\Sipro\Siax PC Tools\Catalog\SiaxM32\PLC\Chn3_v1.pll" fullXml="false" link="true">
				<![CDATA[(*
 *
 * MDPlc source file: Chn3_v1.pll
 * for project:
 * 20.04.2012 - s.v.
 *)


VAR_GLOBAL

    {G:"Channel-3 Variables"}

    VB_CHN3_START              AT %MB300.7941 : BOOL; {DE:"vb7941 Start"}
    VB_CHN3_STOP_HOLD          AT %MB300.7942 : BOOL; {DE:"vb7942 Hold"}
    VB_CHN3_RESET              AT %MB300.7943 : BOOL; {DE:"vb7943 Reset"}
    VB_CHN3_RELEASE            AT %MB300.7944 : BOOL; {DE:"vb7944 Release"}
    VB_CHN3_EXEC_SINGLE        AT %MB300.7945 : BOOL; {DE:"vb7945 Single"}
    VB_CHN3_HOLD_AXES          AT %MB300.7946 : BOOL; {DE:"vb7946 Hold Axes"}
    VB_CHN3_START_ZERO         AT %MB300.7947 : BOOL; {DE:"vb7947 Start Zero Sequence"}
    VB_CHN3_AUTO_RUNNING       AT %MB300.7948 : BOOL; {DE:"vb7948 Auto Running"}
    VB_CHN3_IN_EMERG           AT %MB300.7949 : BOOL; {DE:"vb7949 Emergency"}
    VB_CHN3_UDT_BUSY           AT %MB300.7950 : BOOL; {DE:"vb7950 Udt Busy"}
    VB_CHN3_I_JOG_PIU          AT %MB300.7951 : BOOL; {DE:"vb7951 Jog+ Single Operation"}
    VB_CHN3_I_JOG_MENO         AT %MB300.7952 : BOOL; {DE:"vb7952 Jog- Single Operation"}
    VB_CHN3_I_START            AT %MB300.7953 : BOOL; {DE:"vb7953 Start Single Operation"}
    VB_CHN3_START_CMDA         AT %MB300.7955 : BOOL; {DE:"vb7955 CMDA Start Command"}
    VB_CHN3_JOG_INTP           AT %MB300.7956 : BOOL; {DE:"vb7956 Interpolated Jog enable"}
    VB_CHN3_JOG_RETRACT        AT %MB300.7957 : BOOL; {DE:"vb7957 Jog Retract            "}
    VB_CHN3_IN_MOVE_SINGLE     AT %MB300.7958 : BOOL; {DE:"vb7958 Interpolated Movement Single Execution"}    
    
    VN_CHN3_OVERRIDE_G1        AT %MW400.3941 : INT;  {DE:"vn3941 Override Feed G1"}
    VN_CHN3_OVERRIDE_G0        AT %MW400.3942 : INT;  {DE:"vn3942 Override Feed G0"}
    VN_CHN3_OVERRIDE_SPEED     AT %MW400.3943 : INT;  {DE:"vn3943 Override Speed"}
    VN_CHN3_ORIG_ACT           AT %MW400.3945 : INT;  {DE:"vn3945 Active Origin"}
    VN_CHN3_STATUS             AT %MW400.3946 : INT;  {DE:"vn3946 Channel Status"}
    VN_CHN3_INTP_STATUS        AT %MW400.3947 : INT;  {DE:"vn3947 Interpolator Status"}
    VN_CHN3_GRP_STATUS         AT %MW400.3948 : INT;  {DE:"vn3948 Interpolator Group Status"}
    VN_CHN3_STATUS_CMDA        AT %MW400.3949 : INT;  {DE:"vn3949 CMDA management status"}
    VN_CHN3_UDT_STATUS         AT %MW400.3950 : INT;  {DE:"vn3950 UDT management status"}
    VN_CHN3_ENAB_SINGLE_OPER   AT %MW400.3951 : INT;  {DE:"vn3951 Vb single operation enable"}
    VN_CHN3_ENAB_OPER          AT %MW400.3952 : INT;  {DE:"vn3952 Operations enable"}
    VN_CHN3_STATO_INTERF       AT %MW400.3953 : INT;  {DE:"vn3953 Operator interface state"}
    VN_CHN3_TGS_STATUS         AT %MW400.3954 : INT;  {DE:"vn3954 Teach management state"}
    VN_CHN3_FILE_REQ           AT %MW400.3955 : INT;  {DE:"vn3955 NC file request"}
    VN_CHN3_PROT_UDT_BUSY      AT %MW400.3956 : INT;  {DE:"vn3956 Cnt Protocol udt Command not executed cause there is another command active"}
    VN_CHN3_PLC_UDT_BUSY       AT %MW400.3957 : INT;  {DE:"vn3957 Cnt Plc udt Command not executed cause there is another command active"}
    
    VN_CHN3_READ_TOOL_NUM      AT %MW400.4071 : INT;  {DE:"vn4071 Tool Read"}
    VN_CHN3_MOUNT_TOOL_NUM     AT %MW400.4072 : INT;  {DE:"vn4072 Tool Mount"}
    VN_CHN3_GOSUB_PAR          AT %MW400.4073 : INT;  {DE:"vn4073 Gosub Parameter"}
    VN_CHN3_SPINDLE_DIR        AT %MW400.4074 : INT;  {DE:"vn4074 Spindle linked to interpolated group direction"}    
    
    VQ_CHN3_CUR_SPEED          AT %MD500.7944 : DINT; {DE:"vq7944 Current Speed"}
    VQ_CHN3_SET_SPEED          AT %MD500.7945 : DINT; {DE:"vq7945 Set Speed"}
    VQ_CHN3_GOSUB_PAR          AT %MD500.7946 : DINT; {DE:"vq7946 Gosub Parameter"}
    VQ_CHN3_DELAY_TIMER        AT %MD500.7947 : DINT; {DE:"vq7947 Residual Delay Time"}
    VQ_CHN3_CUR_FEED           AT %MD500.7948 : DINT; {DE:"vq7948 Current Feed [mm/min]"}
    VQ_CHN3_SET_FEED           AT %MD500.7949 : DINT; {DE:"vq7949 Set Feed [mm/min]"}
    VQ_CHN3_AX_SEL             AT %MD500.7951 : DINT; {DE:"vq7951 Axes selection"}
    VQ_CHN3_JOG_INTP_FEED      AT %MD500.7952 : DINT; {DE:"vq7952 Interpoled Jog Feed [mm/min]"}
    VQ_CHN3_INCR_JOG_INTP      AT %MD500.7953 : DINT; {DE:"vq7953 Interpoled Jog increase"}
    
    VQ_CHN3_PIECE_DIM_X        AT %MD500.8101 : DINT; {DE:"vq8101 Piece Dim X"}
    VQ_CHN3_PIECE_DIM_Y        AT %MD500.8102 : DINT; {DE:"vq8102 Piece Dim Y"}
    VQ_CHN3_PIECE_DIM_Z        AT %MD500.8103 : DINT; {DE:"vq8103 Piece Dim Z"}
    VQ_CHN3_MNT_TOOL_RADIUS    AT %MD500.8104 : DINT; {DE:"vq8104 Mount Tool Radius"}
    VQ_CHN3_MNT_TOOL_LENGTH    AT %MD500.8105 : DINT; {DE:"vq8105 Mount Tool Length"}

END_VAR
]]>
			</lib>
			<lib name="DefVar.PLL" fullXml="false" link="true">
				<![CDATA[(*
 *
 * MDPlc source file: DefVar.PLL
 *
 * Date = "14/05/2024 08:42:47"
 *)


VAR_GLOBAL


    {G:"Application_Variables"}

    C1_PrgName                              AT %MB700.1    : STRING[ 80 ]; {DE:"va1    - Nome del programma CN da eseguire"}
    C1_UdfName                              AT %MB700.2    : STRING[ 80 ]; {DE:"va2    - Nome UDF - ( parametri, tabellone, profilo )"}
    C2_PrgName                              AT %MB700.11   : STRING[ 80 ]; {DE:"va11   - Nome del programma CN da eseguire"}
    C2_UdfName                              AT %MB700.12   : STRING[ 80 ]; {DE:"va12   - Nome UDF - ( parametri, tabellone, profilo )"}
    Sup_PrgName                             AT %MB700.21   : STRING[ 80 ]; {DE:"va21   - Nome del programma CN del canale 3"}
    App_Ver                                 AT %MB700.31   : STRING[ 80 ]; {DE:"va31   - Versione applicativo"}


    VbEnableCamme                           AT %MB300.1    : BOOL;         {DE:"vb1    - Comando di abilitazione camme ( globale )"}
    Vb2_C1_Apritensione                     AT %MB300.2    : BOOL;         {DE:"vb2    - Vb attivazione apritenzione cucitrice 1"}
    Vb3_C2_Apritensione                     AT %MB300.3    : BOOL;         {DE:"vb3    - Vb attivazione apritenzione cucitrice 2"}
    Vb4_C1_InCucitura                       AT %MB300.4    : BOOL;         {DE:"vb4    - Vb a On quando sono in cucitura e gira l'ago"}
    Vb5_C2_InCucitura                       AT %MB300.5    : BOOL;         {DE:"vb5    - Vb a On quando sono in cucitura e gira l'ago"}
    Vb6_PinzeOkTestManut                    AT %MB300.6    : BOOL;         {DE:"vb6    - Vb a On quando le pinze dei caricatori e cucitrici sono posizionate bene per manutenzione"}
    Vb7_TestManutRun                        AT %MB300.7    : BOOL;         {DE:"vb7    - Vb a On quando sono in ciclo manutenzione"}
    Vb8_ExitAutomatico                      AT %MB300.8    : BOOL;         {DE:"vb8    - Vb a On quando sono fermo con tutti i programmi e posso uscire dall'automatico per liberare l'hmi"}
    Vb9_ChiudePiegatore4                    AT %MB300.9    : BOOL;         {DE:"vb9    - chiudo il piegatore 4 prima che arrivi la pinza del caricatore va a sbattere"}
    Vb10_StepResetCanale3                   AT %MB300.10   : BOOL;         {DE:"vb10   - fatto per gestire lo stop nella macchina a stati canale 3"}
    Vb11_StepResetCanale3_1                 AT %MB300.11   : BOOL;         {DE:"vb11   - fatto per gestire lo stop nella macchina a stati canale 3 messa a on per gestire lo step piegatore"}
    Vb12_StepResetCanale3_2                 AT %MB300.12   : BOOL;         {DE:"vb12   - fatto per gestire lo stop nella macchina a stati canale 3 messa a on per gestire lo step traslatore"}
    Vb13_C1_BloccoFiloINI                   AT %MB300.13   : BOOL;         {DE:"vb13   - Vb attivazione blocco filo inizio cucitura cucitrice 1"}
    Vb14_C1_BloccoFiloEND                   AT %MB300.14   : BOOL;         {DE:"vb14   - Vb attivazione blocco filo fine cucitura cucitrice 1"}
    Vb15_C2_BloccoFiloINI                   AT %MB300.15   : BOOL;         {DE:"vb15   - Vb attivazione blocco filo inizio cucitura cucitrice 2"}
    Vb16_C2_BloccoFiloEND                   AT %MB300.16   : BOOL;         {DE:"vb16   - Vb attivazione blocco filo fine cucitura cucitrice 2"}
    Vb20_ResetContapezziUser                AT %MB300.20   : BOOL;         {DE:"vb20   - Vb reset contatore pezzi"}
    Vb21_Tasca_dx_sx                        AT %MB300.21   : BOOL;         {DE:"vb21   - ON = Attiva alternanza programma Dx e Sx"}
    Vb22_device_lentezza_tasca              AT %MB300.22   : BOOL;         {DE:"vb22   - ON = attivo"}
    Vb23_CmdRaffreddamentoAgo_C1            AT %MB300.23   : BOOL;         {DE:"vb23   - Vb comando raffreddamento ago"}
    Vb24_CmdRaffreddamentoAgo_C2            AT %MB300.24   : BOOL;         {DE:"vb24   - Vb comando raffreddamento ago"}
    Vb30_C1_InCucitura                      AT %MB300.30   : BOOL;         {DE:"vb30   - =1 sono all'iterno di una cucitura (anche se sono in HOLD)"}
    Vb31_C2_InCucitura                      AT %MB300.31   : BOOL;         {DE:"vb31   - =1 sono all'iterno di una cucitura (anche se sono in HOLD)"}
    Vb32_C1_StopCucitura                    AT %MB300.32   : BOOL;         {DE:"vb32   - =1 è stata fermata la cucitura (Stop o rottura filo)"}
    Vb33_C2_StopCucitura                    AT %MB300.33   : BOOL;         {DE:"vb33   - =1 è stata fermata la cucitura (Stop o rottura filo)"}
    Vb34_FinitoCucitura_C1                  AT %MB300.34   : BOOL;         {DE:"vb34   - =1 è finita la cucitura"}
    Vb35_FinitoCucitura_C2                  AT %MB300.35   : BOOL;         {DE:"vb35   - =1 è finita la cucitura"}
    Vb36_Clear_OPT1                         AT %MB300.36   : BOOL;         {DE:"vb36   - =1 clear uscita OPT1 (retrattile)"}
    Vb37_Clear_OPT2                         AT %MB300.37   : BOOL;         {DE:"vb37   - =1 clear uscita OPT2 (ranocchia)"}
    Vb38_Clear_OPT3                         AT %MB300.38   : BOOL;         {DE:"vb38   - =1 clear uscita OPT3 (salto piedino)"}
    Vb39_Clear_OPT1_C2                      AT %MB300.39   : BOOL;         {DE:"vb39   - =1 clear uscita OPT1"}
    Vb40_Clear_OPT2_C2                      AT %MB300.40   : BOOL;         {DE:"vb40   - =1 clear uscita OPT2"}
    Vb41_Clear_OPT3_C2                      AT %MB300.41   : BOOL;         {DE:"vb41   - =1 clear uscita OPT3 (salto piedino)"}
    Vb42_PrimaTasca_C1                      AT %MB300.42   : BOOL;         {DE:"vb42   - =1 macchina appena accesa e non ho mai cucito"}
    Vb43_TestCuciPrimaTasca_C1              AT %MB300.43   : BOOL;         {DE:"vb43   - =1 ho premuto test cucitura sulla prima tasca senza mai aver cucito"}
    Vb44_PrimaTasca_C2                      AT %MB300.44   : BOOL;         {DE:"vb44   - =1 macchina appena accesa e non ho mai cucito"}
    Vb45_TestCuciPrimaTasca_C2              AT %MB300.45   : BOOL;         {DE:"vb45   - =1 ho premuto test cucitura sulla prima tasca senza mai aver cucito"}
    MacchinaAzzerata                        AT %MB300.50   : BOOL;         {DE:"vb50   - Flag macchina azzerata"}
    RichiestaStartCuci2                     AT %MB300.51   : BOOL;         {DE:"vb51   - Richiesta di start cucitrice 2"}
    Vb52RichiestaZeroAxDaHmiC1              AT %MB300.52   : BOOL;         {DE:"vb52   - Richiesta di azzeramento pinza X + Y da parte dell'interfaccia C1"}
    Vb53RichiestaZeroAxDaHmiC2              AT %MB300.53   : BOOL;         {DE:"vb53   - Richiesta di azzeramento pinza X + Y da parte dell'interfaccia C2"}
    Vb54HmiDiag_XP_YP_C1                    AT %MB300.54   : BOOL;         {DE:"vb54   - Richiesta di diagonale hmi X POSITIVO Y POSITIVO C1"}
    Vb55HmiDiag_XP_YM_C1                    AT %MB300.55   : BOOL;         {DE:"vb55   - Richiesta di diagonale hmi X POSITIVO Y NEGATIVO C1"}
    Vb56HmiDiag_XM_YP_C1                    AT %MB300.56   : BOOL;         {DE:"vb56   - Richiesta di diagonale hmi X NEGATIVO Y POSITIVO C1"}
    Vb57HmiDiag_XM_YM_C1                    AT %MB300.57   : BOOL;         {DE:"vb57   - Richiesta di diagonale hmi X NEGATIVO Y NEGATIVO C1"}
    Vb58HmiDiag_XP_YP_C2                    AT %MB300.58   : BOOL;         {DE:"vb58   - Richiesta di diagonale hmi X POSITIVO Y POSITIVO C2"}
    Vb59HmiDiag_XP_YM_C2                    AT %MB300.59   : BOOL;         {DE:"vb59   - Richiesta di diagonale hmi X POSITIVO Y NEGATIVO C2"}
    Vb60HmiDiag_XM_YP_C2                    AT %MB300.60   : BOOL;         {DE:"vb60   - Richiesta di diagonale hmi X NEGATIVO Y POSITIVO C2"}
    Vb61HmiDiag_XM_YM_C2                    AT %MB300.61   : BOOL;         {DE:"vb61   - Richiesta di diagonale hmi X NEGATIVO Y NEGATIVO C2"}
    Vb62HmiJogXP_C1                         AT %MB300.62   : BOOL;         {DE:"vb62   - Richiesta jog + asse X C1"}
    Vb63HmiJogXM_C1                         AT %MB300.63   : BOOL;         {DE:"vb63   - Richiesta jog - asse X C1"}
    Vb64HmiJogYP_C1                         AT %MB300.64   : BOOL;         {DE:"vb64   - Richiesta jog + asse Y C1"}
    Vb65HmiJogYM_C1                         AT %MB300.65   : BOOL;         {DE:"vb65   - Richiesta jog - asse Y C1"}
    Vb66HmiJogXP_C2                         AT %MB300.66   : BOOL;         {DE:"vb66   - Richiesta jog + asse X C2"}
    Vb67HmiJogXM_C2                         AT %MB300.67   : BOOL;         {DE:"vb67   - Richiesta jog - asse X C2"}
    Vb68HmiJogYP_C2                         AT %MB300.68   : BOOL;         {DE:"vb68   - Richiesta jog + asse Y C2"}
    Vb69HmiJogYM_C2                         AT %MB300.69   : BOOL;         {DE:"vb69   - Richiesta jog - asse Y C2"}
    Vb72HmiMoveXY_C1                        AT %MB300.72   : BOOL;         {DE:"vb72   - Richiesta di spostamento assi XY da Modifica_programmi.java"}
    Vb73HmiMoveXY_C2                        AT %MB300.73   : BOOL;         {DE:"vb73   - Richiesta di spostamento assi XY da Modifica_programmi.java"}
    Vb74HmiMoveXY_PieAlto_C1                AT %MB300.74   : BOOL;         {DE:"vb74   - Richiesta di spostamento assi XY da Modifica_programmi.java con piedino alto"}
    Vb75HmiMoveXY_PieAlto_C2                AT %MB300.75   : BOOL;         {DE:"vb75   - Richiesta di spostamento assi XY da Modifica_programmi.java con piedino alto"}
    Vb76EnableCucitureInfinite_C1           AT %MB300.76   : BOOL;         {DE:"vb76   - =1 fa cuciture infinite"}
    Vb77EnableCucitureInfinite_C2           AT %MB300.77   : BOOL;         {DE:"vb77   - =1 fa cuciture infinite"}
    Vb78SetVelManualeAsseAgo_C1             AT %MB300.78   : BOOL;         {DE:"vb78   - =1 setta la velocità manuale nei parametri assi dell'ago"}
    Vb79SetVelManualeAsseAgo_C2             AT %MB300.79   : BOOL;         {DE:"vb79   - =1 setta la velocità manuale nei parametri assi dell'ago"}
    Vb80ShowIconaTools                      AT %MB300.80   : BOOL;         {DE:"vb80   - =1 permette a HMI di mostrare l'icona per andare alla pagina tools"}
    Vb81PremutoResetAccensione              AT %MB300.81   : BOOL;         {DE:"vb81   - =1 se premo il verde mentre il pulsante reset piegatore è premuto"}
    Vb82FaiFuoriIngombroY_C1                AT %MB300.82   : BOOL;         {DE:"vb82   - = 1 durante azzeramento la pinza prima si muove in Y in dietro"}
    Vb83FaiFuoriIngombroY_C2                AT %MB300.83   : BOOL;         {DE:"vb83   - = 1 durante azzeramento la pinza prima si muove in Y in dietro"}
    Vb84PiegatoreRisalito                   AT %MB300.84   : BOOL;         {DE:"vb84   - =1 il sensore nuovo ha rilevato che il piegatore si è sollevato abbastanza per far avanzare il caricatore"}
    Vb85AbilitaSensAltoPieg                 AT %MB300.85   : BOOL;         {DE:"vb85   - =1 abilitia la lettura sel sensore alto piegatore"}
    Vb86In_Azzeramento_C1                   AT %MB300.86   : BOOL;         {DE:"vb86   - =1 sto facendo azzeramento C1"}
    Vb87In_Azzeramento_C2                   AT %MB300.87   : BOOL;         {DE:"vb87   - =1 sto facendo azzeramento C2"}
    Vb88_TascaC1Completata                  AT %MB300.88   : BOOL;         {DE:"vb88   - =1 la tasca C1 è stata cucita e la pinza è tornata sul punto di carico"}
    Vb89_TascaC2Completata                  AT %MB300.89   : BOOL;         {DE:"vb89   - =1 la tasca C2 è stata cucita e la pinza è tornata sul punto di carico"}
    Vb90_AnticipoTrasl_SX                   AT %MB300.90   : BOOL;         {DE:"vb90   - =1 anticipo il movimento del traslatore a sx sopra le pinze di cucitura della testa 1"}
    VbTest                                  AT %MB300.99   : BOOL;         {DE:"vb99   - per test"}
    VbSimulaDbg                             AT %MB300.100  : BOOL;         {DE:"vb100  - Cucitrice simulata ( per debugger )"}
    VbSyncDbg                               AT %MB300.101  : BOOL;         {DE:"vb101  - Variabile di sync ( per debugger )"}
    VbSimulazionePedanaC1                   AT %MB300.102  : BOOL;         {DE:"vb102  - alza e abbassa le pinze tramite vb come se premessi la pedana"}
    VbSimulazionePedanaC2                   AT %MB300.103  : BOOL;         {DE:"vb103  - alza e abbassa le pinze tramite vb come se premessi la pedana"}
    Vb151EnableCarPattine                   AT %MB300.151  : BOOL;         {DE:"vb151  - =1 device caricatore pattina attivo"}
    Vb152KitCarPAttine                      AT %MB300.152  : BOOL;         {DE:"vb152  - =1 il kit carica pattina è attivo (tasto HMI)"}
    Vb153GoCicloCarPAttina                  AT %MB300.153  : BOOL;         {DE:"vb153  - =1 fa partire un ciclo carica pattina"}
    Vb154CarInPosAltaOK                     AT %MB300.154  : BOOL;         {DE:"vb154  - = 1 indica che il caricatore è in posiazione alta"}
    Vb155LasciaPattina                      AT %MB300.155  : BOOL;         {DE:"vb155  - =1 il CN permette al PLC di lasciare la pattina"}
    Vb156PattinaScaricata                   AT %MB300.156  : BOOL;         {DE:"vb156  - =1 il PLC indica al CN che la pattina è stata scaricata e può partire a cucire"}
    Vb157PattinaPassoPasso                  AT %MB300.157  : BOOL;         {DE:"vb157  - =1 attivo ciclo passo passo pattina"}
    Vb158PattinaTestRunning                 AT %MB300.158  : BOOL;         {DE:"vb158  - =1 il ciclo piattina test sta girando"}
    Vb159PattinaTestRunning                 AT %MB300.159  : BOOL;         {DE:"vb159  - =1 il ciclo piattina test sta girando"}
    Vb160PartiACucire                       AT %MB300.160  : BOOL;         {DE:"vb160  - =1 il plc avverte il CN che la pattina è stata caricata e bloccata, ora può effettuare la prima cucitura"}
    Vb170KitTascaCargo                      AT %MB300.170  : BOOL;         {DE:"vb170  - =1 attivo il kit tasca cargo"}
    Vb4000_Automatico                       AT %MB300.4000 : BOOL;         {DE:"vb4000 - /// messa a ON da HMI sono in automatico"}
    Vb4001_StepPiegatore                    AT %MB300.4001 : BOOL;         {DE:"vb4001 - /// messa a ON da HMI il piegatore è passo passo"}
    Vb4002_StepPiegatoreStop                AT %MB300.4002 : BOOL;         {DE:"vb4002 - /// punto di stop piegatore"}
    Vb4003_RqsStopPiegatore                 AT %MB300.4003 : BOOL;         {DE:"vb4003 - /// richiesta di stop piegatore al CN"}
    Vb4004_AvvioPiegatore                   AT %MB300.4004 : BOOL;         {DE:"vb4004 - /// avvio il piegatore da plc"}
    Vb4005_AvvioCaricatore                  AT %MB300.4005 : BOOL;         {DE:"vb4005 - /// avvio il caricatore da plc"}
    Vb4006_StepTraslatore                   AT %MB300.4006 : BOOL;         {DE:"vb4006 - /// messa a ON da HMI il traslatore è passo passo"}
    Vb4007_MemoriaAvviaCaric                AT %MB300.4007 : BOOL;         {DE:"vb4007 - /// memorizzo che ho premuto start e quindi appena possibile il caricatore può avanzare"}
    Vb4008_AgoSu_C1                         AT %MB300.4008 : BOOL;         {DE:"vb4008 - /// riporta l'ago C1 nella posizione alta"}
    Vb4009_AgoSu_C2                         AT %MB300.4009 : BOOL;         {DE:"vb4009 - /// riporta l'ago C2 nella posizione alta"}
    Vb4010_PrgPiegatoreRun                  AT %MB300.4010 : BOOL;         {DE:"vb4010 - finchè gira il ciclo piegatore nel cn questa vb = ON"}
    Vb4011_TascaOk                          AT %MB300.4011 : BOOL;         {DE:"vb4011"}
    Vb4012_FlagTascaPronta                  AT %MB300.4012 : BOOL;         {DE:"vb4012 - a ON tasca pronta per caricare"}
    Vb4013_DisableLancia                    AT %MB300.4013 : BOOL;         {DE:"vb4013 - finchè è a ON Blocco il pedale della lancia"}
    Vb4014JogFastSlow                       AT %MB300.4014 : BOOL;         {DE:"vb4014 - hmi = 0 Jog normale(fast) =1 Jog Lento"}
    Vb4015_PrgCaricatoreRun                 AT %MB300.4015 : BOOL;         {DE:"vb4015 - finchè gira il ciclo caricatore nel cn questa vb = ON"}
    Vb4016_PrgTraslatoreRun                 AT %MB300.4016 : BOOL;         {DE:"vb4016 - se il traslatore è in una fase di movimento questa vb = ON"}
    Vb4017_AttesaTascaIsRunning             AT %MB300.4017 : BOOL;         {DE:"vb4017 - il ciclo di attesa tasca in CicloAutomatico sta girando"}
    Vb4018_TrigrHMITascaCucita              AT %MB300.4018 : BOOL;         {DE:"vb4018 - ad On quando una tasca è stata cucita completamente"}
    Vb4021_Piegatore1_ON                    AT %MB300.4021 : BOOL;         {DE:"vb4021 - Primo piegatore attivato"}
    Vb4022_Piegatore2_ON                    AT %MB300.4022 : BOOL;         {DE:"vb4022 - Secondo piegatore attivato"}
    Vb4023_Piegatore3_ON                    AT %MB300.4023 : BOOL;         {DE:"vb4023 - Terzo piegatore attivato"}
    Vb4024_Piegatore4_ON                    AT %MB300.4024 : BOOL;         {DE:"vb4024 - Quarto piegatore attivato"}
    Vb4025_Piegatore1_OFF                   AT %MB300.4025 : BOOL;         {DE:"vb4025 - Primo piegatore disattivato"}
    Vb4026_Piegatore2_OFF                   AT %MB300.4026 : BOOL;         {DE:"vb4026 - Secondo piegatore disattivato"}
    Vb4027_Piegatore3_OFF                   AT %MB300.4027 : BOOL;         {DE:"vb4027 - Terzo piegatore disattivato"}
    Vb4028_Piegatore4_OFF                   AT %MB300.4028 : BOOL;         {DE:"vb4028 - Quarto piegatore disattivato"}
    Vb4031_AppScaricatoreInPos              AT %MB300.4031 : BOOL;         {DE:"vb4031 - dopo un tempo che la valvola o54_Scaric_dx_sx è a ON"}
    Vb4032_AppScaricatoreStrBarre           AT %MB300.4032 : BOOL;         {DE:"vb4032 - avvio le barre insieme alla pinza alta"}
    Vb4033_RitardoAvanzataCaricatore        AT %MB300.4033 : BOOL;         {DE:"vb4033 - finchè è ad 1 il caricatore non può avanzare (ritardo dopo la barra2 on)"}
    Vb4034_ScaricOnSuRasafilo               AT %MB300.4034 : BOOL;         {DE:"vb4034 - se On la prima barra parte sul rasafilo finale, se off dopo che le pinze solo alte"}
    Vb4035_Sync_scartafilo                  AT %MB300.4035 : BOOL;         {DE:"vb4035 - Nell'udf G275 alza vb4035 e quando la rimetto a false la cucitura riparte (G283.0 fermata temporanea)"}
    Vb4036_Enable_Sync_scartafilo           AT %MB300.4036 : BOOL;         {DE:"vb4036 - HMI abilita il ciclo scartafilo sincronizzato con udf"}
    Vb4038_Scatena_scartafilo               AT %MB300.4038 : BOOL;         {DE:"vb4038 - Scatena macchine a stati scartafilo"}
    Vb4042_SyncSplit1                       AT %MB300.4042 : BOOL;         {DE:"vb4042"}
    Vb4043_SyncSplit2                       AT %MB300.4043 : BOOL;         {DE:"vb4043"}
    Vb4045_C1_AxXFermo                      AT %MB300.4045 : BOOL;         {DE:"vb4045 - Flag segnalazione asse  fermo"}
    Vb4046_C1_AxYFermo                      AT %MB300.4046 : BOOL;         {DE:"vb4046 - Flag segnalazione asse  fermo"}
    Vb4047_C1_AxAgoFermo                    AT %MB300.4047 : BOOL;         {DE:"vb4047 - Flag segnalazione asse  fermo"}
    Vb4048_C1_AxCroFermo                    AT %MB300.4048 : BOOL;         {DE:"vb4048 - Flag segnalazione asse  fermo"}
    Vb4049_C1_AsseCARFermo                  AT %MB300.4049 : BOOL;         {DE:"vb4049 - Flag segnalazione asse  fermo"}
    Vb4050_C2_AxXFermo                      AT %MB300.4050 : BOOL;         {DE:"vb4050 - Flag segnalazione asse  fermo"}
    Vb4051_C2_AxYFermo                      AT %MB300.4051 : BOOL;         {DE:"vb4051 - Flag segnalazione asse  fermo"}
    Vb4052_C2_AxAgoFermo                    AT %MB300.4052 : BOOL;         {DE:"vb4052 - Flag segnalazione asse  fermo"}
    Vb4053_C2_AxCroFermo                    AT %MB300.4053 : BOOL;         {DE:"vb4053 - Flag segnalazione asse  fermo"}
    Vb4054_C2_AsseCARFermo                  AT %MB300.4054 : BOOL;         {DE:"vb4054 - Flag segnalazione asse  fermo"}
    Vb4058_C1_AsseX_YFermo                  AT %MB300.4058 : BOOL;         {DE:"vb4058 - Flag segnalazione asse  fermo"}
    Vb4059_C2_AsseX_YFermo                  AT %MB300.4059 : BOOL;         {DE:"vb4059 - Flag segnalazione asse  fermo"}
    Vb4060_HMISaveUdfFile                   AT %MB300.4060 : BOOL;         {DE:"vb4060 - hmi salva udf"}
    Vb4061_AppTensAumentaTesta1             AT %MB300.4061 : BOOL;         {DE:"vb4061 - hmi tasto aumenta tensione testa 1"}
    Vb4062_AppTensDiminuisceTesta1          AT %MB300.4062 : BOOL;         {DE:"vb4062 - hmi tasto diminuisce tensione testa 1"}
    Vb4063_AppTensAumentaTesta2             AT %MB300.4063 : BOOL;         {DE:"vb4063 - hmi tasto aumenta tensione testa 2"}
    Vb4064_AppTensDiminuisceTesta2          AT %MB300.4064 : BOOL;         {DE:"vb4064 - hmi tasto diminuisce tensione testa 2"}
    Vb4065_AppTensAumentaSotto              AT %MB300.4065 : BOOL;         {DE:"vb4065 - hmi tasto aumenta tensione piegatore sopra"}
    Vb4066_AppTensDiminuisceSotto           AT %MB300.4066 : BOOL;         {DE:"vb4066 - hmi tasto diminuisce tensione piegatore sopra"}
    Vb4067_AppTensAumentaSopra              AT %MB300.4067 : BOOL;         {DE:"vb4067 - hmi tasto aumenta tensione piegatore sotto"}
    Vb4068_AppTensDiminuisceSopra           AT %MB300.4068 : BOOL;         {DE:"vb4068 - hmi tasto diminuisce tensione piegatore sotto"}
    Vb4069_AppTensOnSopra                   AT %MB300.4069 : BOOL;         {DE:"vb4069 - hmi tasto attiva tensione piegatore sopra"}
    Vb4070_AppTensOnSotto                   AT %MB300.4070 : BOOL;         {DE:"vb4070 - hmi tasto attiva tensione piegatore sotto"}
    Vb4071_AbilitaContSpolaC1               AT %MB300.4071 : BOOL;         {DE:"vb4071 - /// HMI utilizzato per abilitare il conteggio della spola C1 ( OFF funziona )"}
    Vb4072_AllarmeContSpolaC1               AT %MB300.4072 : BOOL;         {DE:"vb4072 - /// HMI utilizzato per abilitare il conteggio della spola C1 ( OFF funziona )"}
    Vb4073_AbilitaContSpolaC2               AT %MB300.4073 : BOOL;         {DE:"vb4073 - /// HMI utilizzato per abilitare il conteggio della spola C2 ( OFF funziona )"}
    Vb4074_AllarmeContSpolaC2               AT %MB300.4074 : BOOL;         {DE:"vb4074 - /// HMI utilizzato per abilitare il conteggio della spola C2 ( OFF funziona )"}
    Vb4075_GiraAgoFaiSpolaC1                AT %MB300.4075 : BOOL;         {DE:"vb4075 - /// HMI utilizzato per far girare la testa C1 per fare la spola"}
    Vb4076_GiraAgoFaiSpolaC2                AT %MB300.4076 : BOOL;         {DE:"vb4076 - /// HMI utilizzato per far girare la testa C2 per fare la spola"}
    Vb4078_TestHomeC1                       AT %MB300.4078 : BOOL;         {DE:"vb4078 - /// HMI utilizzato per centrare i sensori di zero su dima cucitrice 1"}
    Vb4079_TestHomeC2                       AT %MB300.4079 : BOOL;         {DE:"vb4079 - /// HMI utilizzato per centrare i sensori di zero su dima cucitrice 2"}
    Vb4080_TestFcZeroC1                     AT %MB300.4080 : BOOL;         {DE:"vb4080 - /// HMI utilizzato per centrare i sensori di zero su dima cucitrice 1"}
    Vb4081_TestCaricatorePinzaC1            AT %MB300.4081 : BOOL;         {DE:"vb4081 - /// HMI utilizzato per centrare la pinza del caricatore sulla pinza cucitrice"}
    Vb4082_TestCaricatoreLanciaC1           AT %MB300.4082 : BOOL;         {DE:"vb4082 - /// HMI utilizzato per centrare la pinza del caricatore sulla lancia"}
    Vb4083_TestCaricatoreC2CaricoC1         AT %MB300.4083 : BOOL;         {DE:"vb4083 - /// HMI utilizzato per centrare la pinza del caricatore C2 carico su C1"}
    Vb4084_TestCaricatoreC2ScaricoC2        AT %MB300.4084 : BOOL;         {DE:"vb4084 - /// HMI utilizzato per centrare la pinza del caricatore C2 culla pinza C2"}
    Vb4085_TestFcZeroC2                     AT %MB300.4085 : BOOL;         {DE:"vb4085 - /// HMI utilizzato per centrare i sensori di zero su dima cucitrice 2"}
    Vb4086_SavePosizioni                    AT %MB300.4086 : BOOL;         {DE:"vb4086 - /// HMI in base al test scelto salva i punti"}
    Vb4087_TestLiberaPinzaCaricatore        AT %MB300.4087 : BOOL;         {DE:"vb4087 - /// HMI utilizzato per gestire l'anticipo tra pinza caricatore e C1"}
    Vb4088_TestDisableRiposizionaAgo        AT %MB300.4088 : BOOL;         {DE:"vb4088 - /// HMI utilizzato per non riposizionare l'ago al punto ago alto"}
    Vb4089_TestDisableRiposizionaAgoC2      AT %MB300.4089 : BOOL;         {DE:"vb4089 - /// HMI utilizzato per non riposizionare l'ago al punto ago alto"}
    Vb4090_EnableRotturaFiloC1              AT %MB300.4090 : BOOL;         {DE:"vb4090 - /// HMI utilizzato per abilitare la rottura filo C1 ( OFF funziona )"}
    Vb4091_EnableRotturaFiloC2              AT %MB300.4091 : BOOL;         {DE:"vb4091 - /// HMI utilizzato per abilitare la rottura filo C2 ( OFF funziona )"}
    Vb4092_EnbCountRotturaFiloC1            AT %MB300.4092 : BOOL;         {DE:"vb4092 - /// HMI utilizzato per abilitare  abilitare il conteggio della rottura filo C1"}
    Vb4093_EnbCountRotturaFiloC2            AT %MB300.4093 : BOOL;         {DE:"vb4093 - /// HMI utilizzato per abilitare  abilitare il conteggio della rottura filo C2"}
    Vb4094_EnbScartafiloC1                  AT %MB300.4094 : BOOL;         {DE:"vb4094 - /// HMI utilizzato per abilitare scartafilo C1"}
    Vb4095_EnbScartafiloC2                  AT %MB300.4095 : BOOL;         {DE:"vb4095 - /// HMI utilizzato per abilitare scartafilo C2"}
    Vb4096_AppOnScartafiloC1                AT %MB300.4096 : BOOL;         {DE:"vb4096 - /// utilizzato da cn per abilitare scartafilo C1"}
    Vb4097_AppOnScartafiloC2                AT %MB300.4097 : BOOL;         {DE:"vb4097 - /// utilizzato da cn per abilitare scartafilo C2"}
    Vb4098_OnSeqScartafiloC1                AT %MB300.4098 : BOOL;         {DE:"vb4098 - /// utilizzato da plc per abilitare scartafilo C1"}
    Vb4099_OnSeqScartafiloC2                AT %MB300.4099 : BOOL;         {DE:"vb4099 - /// utilizzato da plc per abilitare scartafilo C2"}
    Vb4100_                                 AT %MB300.4100 : BOOL;         {DE:"vb4100"}
    Vb4133_AppMan_o1_Piegatore_1            AT %MB300.4133 : BOOL;         {DE:"vb4133"}
    Vb4134_AppMan_o2_Piegatore_2            AT %MB300.4134 : BOOL;         {DE:"vb4134"}
    Vb4135_AppMan_o3_Piegatore_3            AT %MB300.4135 : BOOL;         {DE:"vb4135"}
    Vb4136_AppMan_o4_Piegatore_4            AT %MB300.4136 : BOOL;         {DE:"vb4136"}
    Vb4137_AppMan_o5_Cambio_corpo           AT %MB300.4137 : BOOL;         {DE:"vb4137"}
    Vb4138_AppMan_o6_Cambio_lama_front      AT %MB300.4138 : BOOL;         {DE:"vb4138"}
    Vb4139_AppMan_o7_Cambio_lame_lateral    AT %MB300.4139 : BOOL;         {DE:"vb4139"}
    Vb4140_AppMan_o8_Cambio_Lamelle_4_5     AT %MB300.4140 : BOOL;         {DE:"vb4140"}
    Vb4141_AppMan_o9_Lancia_AD              AT %MB300.4141 : BOOL;         {DE:"vb4141"}
    Vb4142_AppMan_o10_Piegatore_AD          AT %MB300.4142 : BOOL;         {DE:"vb4142"}
    Vb4143_AppMan_o11_Piegatore_Su_Giu      AT %MB300.4143 : BOOL;         {DE:"vb4143"}
    Vb4144_AppMan_o12_Bilanciere_Su_Giu     AT %MB300.4144 : BOOL;         {DE:"vb4144"}
    Vb4145_AppMan_o13_Lancia_Cargo_Aperta   AT %MB300.4145 : BOOL;         {DE:"vb4145"}
    Vb4146_AppMan_o14_C1_rasafilo           AT %MB300.4146 : BOOL;         {DE:"vb4146"}
    Vb4147_AppMan_o15_EvAspiratore          AT %MB300.4147 : BOOL;         {DE:"vb4147"}
    Vb4148_AppMan_o16_Lancia_Cargo_Chiusa   AT %MB300.4148 : BOOL;         {DE:"vb4148"}
    Vb4149_AppMan_o17_C1_Piedino            AT %MB300.4149 : BOOL;         {DE:"vb4149"}
    Vb4150_AppMan_o18_C1_Pinza_int          AT %MB300.4150 : BOOL;         {DE:"vb4150"}
    Vb4151_AppMan_o19_C1_Pinza_est          AT %MB300.4151 : BOOL;         {DE:"vb4151"}
    Vb4152_AppMan_o20_C1_Retrattile_AC      AT %MB300.4152 : BOOL;         {DE:"vb4152"}
    Vb4153_AppMan_o21_C1_RaffreddamentoAgo  AT %MB300.4153 : BOOL;         {DE:"vb4153"}
    Vb4154_22                               AT %MB300.4154 : BOOL;         {DE:"vb4154"}
    Vb4155_AppMan_o23_Lentezza_Tasca_AD     AT %MB300.4155 : BOOL;         {DE:"vb4155"}
    Vb4156_AppMan_o24_Pinza_carico_Su_Giu   AT %MB300.4156 : BOOL;         {DE:"vb4156"}
    Vb4157_AppMan_o25_C1_Cambio_Pinze       AT %MB300.4157 : BOOL;         {DE:"vb4157"}
    Vb4158_AppMan_o26_C1_Scalino_Piedino    AT %MB300.4158 : BOOL;         {DE:"vb4158"}
    Vb4159_AppMan_o27_C1_Ranocchia_retrat   AT %MB300.4159 : BOOL;         {DE:"vb4159"}
    Vb4160_28                               AT %MB300.4160 : BOOL;         {DE:"vb4160"}
    Vb4161_29                               AT %MB300.4161 : BOOL;         {DE:"vb4161"}
    Vb4162_30                               AT %MB300.4162 : BOOL;         {DE:"vb4162"}
    Vb4163_AppMan_o31_C1_bloccaFiloMagente  AT %MB300.4163 : BOOL;         {DE:"vb4163"}
    Vb4164_AppMan_o32_Enable_AssiXY_C1      AT %MB300.4164 : BOOL;         {DE:"vb4164"}
    Vb4165_AppMan_o33_Valvolone             AT %MB300.4165 : BOOL;         {DE:"vb4165"}
    Vb4166_AppMan_o34_CarPat_FrontBack      AT %MB300.4166 : BOOL;         {DE:"vb4166"}
    Vb4167_AppMan_o35_CarPat_Aghi           AT %MB300.4167 : BOOL;         {DE:"vb4167"}
    Vb4168_AppMan_o36_CarPat_SoffioAghi     AT %MB300.4168 : BOOL;         {DE:"vb4168"}
    Vb4169_AppMan_o37_CarPat_SoffiPattina   AT %MB300.4169 : BOOL;         {DE:"vb4169"}
    Vb4170_AppMan_o38_CarPat_DCGiu          AT %MB300.4170 : BOOL;         {DE:"vb4170"}
    Vb4171_AppMan_o39_CarPat_DCSu           AT %MB300.4171 : BOOL;         {DE:"vb4171"}
    Vb4172_o40                              AT %MB300.4172 : BOOL;         {DE:"vb4172"}
    Vb4173_o41                              AT %MB300.4173 : BOOL;         {DE:"vb4173"}
    Vb4174_o42                              AT %MB300.4174 : BOOL;         {DE:"vb4174"}
    Vb4175_o43                              AT %MB300.4175 : BOOL;         {DE:"vb4175"}
    Vb4176_o44                              AT %MB300.4176 : BOOL;         {DE:"vb4176"}
    Vb4177_o45                              AT %MB300.4177 : BOOL;         {DE:"vb4177"}
    Vb4178_AppMan_o46_C2_rasafilo           AT %MB300.4178 : BOOL;         {DE:"vb4178"}
    Vb4179_o47                              AT %MB300.4179 : BOOL;         {DE:"vb4179"}
    Vb4180_AppMano_48_Enable_AssiXY_C2      AT %MB300.4180 : BOOL;         {DE:"vb4180"}
    Vb4181_AppMan_o49_C2_Piedino            AT %MB300.4181 : BOOL;         {DE:"vb4181"}
    Vb4182_AppMan_o50_C2_Pinza_int          AT %MB300.4182 : BOOL;         {DE:"vb4182"}
    Vb4183_AppMan_o51_PinzaPattina_1        AT %MB300.4183 : BOOL;         {DE:"vb4183"}
    Vb4184_AppMan_o52_PinzaPattina_2        AT %MB300.4184 : BOOL;         {DE:"vb4184"}
    Vb4185_AppMan_o53_C2_RaffreddamentoAgo  AT %MB300.4185 : BOOL;         {DE:"vb4185"}
    Vb4186_AppMan_o54_Scaric_dx_sx          AT %MB300.4186 : BOOL;         {DE:"vb4186"}
    Vb4187_o55                              AT %MB300.4187 : BOOL;         {DE:"vb4187"}
    Vb4188_AppMan_o56_Piza_tras_su_giu      AT %MB300.4188 : BOOL;         {DE:"vb4188"}
    Vb4189_AppMan_o57_C2_Cambio_Pinze       AT %MB300.4189 : BOOL;         {DE:"vb4189"}
    Vb4190_AppMan_o58_C2_Scalino_Piedino    AT %MB300.4190 : BOOL;         {DE:"vb4190"}
    Vb4191_o59                              AT %MB300.4191 : BOOL;         {DE:"vb4191"}
    Vb4192_AppMan_o60_Prima_barra           AT %MB300.4192 : BOOL;         {DE:"vb4192"}
    Vb4193_AppMan_o61_Seconda_barra         AT %MB300.4193 : BOOL;         {DE:"vb4193"}
    Vb4194_o62                              AT %MB300.4194 : BOOL;         {DE:"vb4194"}
    Vb4195_AppMan_C2_bloccaFiloMagente      AT %MB300.4195 : BOOL;         {DE:"vb4195"}
    Vb4196_o64                              AT %MB300.4196 : BOOL;         {DE:"vb4196"}
    Vb4208_AppMagneteTensione               AT %MB300.4208 : BOOL;         {DE:"vb4208"}
    Vb4209_AppMagneteTensioneT2             AT %MB300.4209 : BOOL;         {DE:"vb4209"}
    Vb4210_AppMagneteSopraPiegatore         AT %MB300.4210 : BOOL;         {DE:"vb4210"}
    Vb4211_AppMagneteSottoPiegatore         AT %MB300.4211 : BOOL;         {DE:"vb4211"}
    Vb4333_AppAut_o1_Piegatore_1            AT %MB300.4333 : BOOL;         {DE:"vb4333"}
    Vb4334_AppAut_o2_Piegatore_2            AT %MB300.4334 : BOOL;         {DE:"vb4334"}
    Vb4335_AppAut_o3_Piegatore_3            AT %MB300.4335 : BOOL;         {DE:"vb4335"}
    Vb4336_AppAut_o4_Piegatore_4            AT %MB300.4336 : BOOL;         {DE:"vb4336"}
    Vb4337_AppAut_o5_Cambio_corpo           AT %MB300.4337 : BOOL;         {DE:"vb4337"}
    Vb4338_AppAut_o6_Cambio_lama_front      AT %MB300.4338 : BOOL;         {DE:"vb4338"}
    Vb4339_AppAut_o7_Cambio_lame_lateral    AT %MB300.4339 : BOOL;         {DE:"vb4339"}
    Vb4340_AppAut_o8_Cambio_Lamelle_4_5     AT %MB300.4340 : BOOL;         {DE:"vb4340"}
    Vb4341_AppAut_o9_Lancia_AD              AT %MB300.4341 : BOOL;         {DE:"vb4341"}
    Vb4342_AppAut_o10_Piegatore_AD          AT %MB300.4342 : BOOL;         {DE:"vb4342"}
    Vb4343_AppAut_o11_Piegatore_Su_Giu      AT %MB300.4343 : BOOL;         {DE:"vb4343"}
    Vb4344_AppAut_o12_Bilanciere_Su_Giu     AT %MB300.4344 : BOOL;         {DE:"vb4344"}
    Vb4345_AppAut_o13_Lancia_Cargo_Aperta   AT %MB300.4345 : BOOL;         {DE:"vb4345"}
    Vb4346_AppAut_o14_C1_rasafilo           AT %MB300.4346 : BOOL;         {DE:"vb4346"}
    Vb4347_AppAut_o15_EvAspiratore          AT %MB300.4347 : BOOL;         {DE:"vb4347"}
    Vb4348_AppAut_o16_Lancia_Cargo_Chiusa   AT %MB300.4348 : BOOL;         {DE:"vb4348"}
    Vb4349_AppAut_o17_C1_Piedino            AT %MB300.4349 : BOOL;         {DE:"vb4349"}
    Vb4350_AppAut_o18_C1_Pinza_int          AT %MB300.4350 : BOOL;         {DE:"vb4350"}
    Vb4351_AppAut_o19_C1_Pinza_est          AT %MB300.4351 : BOOL;         {DE:"vb4351"}
    Vb4352_AppAut_o20_C1_Retrattile_AC      AT %MB300.4352 : BOOL;         {DE:"vb4352"}
    Vb4353_AppAut_o21_C1_RaffreddamentoAgo  AT %MB300.4353 : BOOL;         {DE:"vb4353"}
    Vb4354_o22                              AT %MB300.4354 : BOOL;         {DE:"vb4354"}
    Vb4355_AppAut_o23_Lentezza_Tasca_AD     AT %MB300.4355 : BOOL;         {DE:"vb4355"}
    Vb4356_AppAut_o24_Pinza_carico_Su_Giu   AT %MB300.4356 : BOOL;         {DE:"vb4356"}
    Vb4357_AppAut_o25_C1_Cambio_Pinze       AT %MB300.4357 : BOOL;         {DE:"vb4357"}
    Vb4358_AppAut_o26_C1_Scalino_Piedino    AT %MB300.4358 : BOOL;         {DE:"vb4358"}
    Vb4359_AppAut_o27_C1_Ranocchia_retrat   AT %MB300.4359 : BOOL;         {DE:"vb4359"}
    Vb4360_o28                              AT %MB300.4360 : BOOL;         {DE:"vb4360"}
    Vb4361_o29                              AT %MB300.4361 : BOOL;         {DE:"vb4361"}
    Vb4362_o30                              AT %MB300.4362 : BOOL;         {DE:"vb4362"}
    Vb4363_AppAut_o31_C1_bloccaFiloMagente  AT %MB300.4363 : BOOL;         {DE:"vb4363"}
    Vb4364_AppAut_o32_Enable_AssiXY_C1      AT %MB300.4364 : BOOL;         {DE:"vb4364"}
    Vb4365_AppAut_o33_Valvolone             AT %MB300.4365 : BOOL;         {DE:"vb4365"}
    Vb4366_AppAut_o34_CarPat_FrontBack      AT %MB300.4366 : BOOL;         {DE:"vb4366"}
    Vb4367_AppAut_o35_CarPat_Aghi           AT %MB300.4367 : BOOL;         {DE:"vb4367"}
    Vb4368_AppAut_o36_CarPat_SoffioAghi     AT %MB300.4368 : BOOL;         {DE:"vb4368"}
    Vb4369_AppAut_o37_CarPat_SoffiPattina   AT %MB300.4369 : BOOL;         {DE:"vb4369"}
    Vb4370_AppAut_o38_CarPat_DCGiu          AT %MB300.4370 : BOOL;         {DE:"vb4370"}
    Vb4371_AppAut_o39_CarPat_DCSu           AT %MB300.4371 : BOOL;         {DE:"vb4371"}
    Vb4372_o40                              AT %MB300.4372 : BOOL;         {DE:"vb4372"}
    Vb4373_o41                              AT %MB300.4373 : BOOL;         {DE:"vb4373"}
    Vb4374_o42                              AT %MB300.4374 : BOOL;         {DE:"vb4374"}
    Vb4375_o43                              AT %MB300.4375 : BOOL;         {DE:"vb4375"}
    Vb4376_o44                              AT %MB300.4376 : BOOL;         {DE:"vb4376"}
    Vb4377_o45                              AT %MB300.4377 : BOOL;         {DE:"vb4377"}
    Vb4378_AppAut_o46_C2_rasafilo           AT %MB300.4378 : BOOL;         {DE:"vb4378"}
    Vb4379_o47                              AT %MB300.4379 : BOOL;         {DE:"vb4379"}
    Vb4380_AppAuto48_Enable_AssiXY_C2       AT %MB300.4380 : BOOL;         {DE:"vb4380"}
    Vb4381_AppAut_o49_C2_Piedino            AT %MB300.4381 : BOOL;         {DE:"vb4381"}
    Vb4382_AppAut_o50_C2_Pinza_int          AT %MB300.4382 : BOOL;         {DE:"vb4382"}
    Vb4383_AppAut_o51_PinzaPattina_1        AT %MB300.4383 : BOOL;         {DE:"vb4383"}
    Vb4384_AppAut_o52_PinzaPattina_2        AT %MB300.4384 : BOOL;         {DE:"vb4384"}
    Vb4385_AppAut_o53_C2_RaffreddamentoAgo  AT %MB300.4385 : BOOL;         {DE:"vb4385"}
    Vb4386_AppAut_o54_Scaric_dx_sx          AT %MB300.4386 : BOOL;         {DE:"vb4386"}
    Vb4387_o55                              AT %MB300.4387 : BOOL;         {DE:"vb4387"}
    Vb4388_AppAut_o56_Pinza_tras_su_giu     AT %MB300.4388 : BOOL;         {DE:"vb4388"}
    Vb4389_AppAut_o57_C2_Cambio_Pinze       AT %MB300.4389 : BOOL;         {DE:"vb4389"}
    Vb4390_AppAut_o58_C2_Scalino_Piedino    AT %MB300.4390 : BOOL;         {DE:"vb4390"}
    Vb4391_o59                              AT %MB300.4391 : BOOL;         {DE:"vb4391"}
    Vb4392_AppAut_o60_Prima_barra           AT %MB300.4392 : BOOL;         {DE:"vb4392"}
    Vb4393_AppAut_o61_Seconda_barra         AT %MB300.4393 : BOOL;         {DE:"vb4393"}
    Vb4394_o62                              AT %MB300.4394 : BOOL;         {DE:"vb4394"}
    Vb4395_AppAut_o63_C2_bloccaFiloMagente  AT %MB300.4395 : BOOL;         {DE:"vb4395"}
    Vb4396_o64                              AT %MB300.4396 : BOOL;         {DE:"vb4396"}
    Vb4501_AppVbChn3StartHMI                AT %MB300.4501 : BOOL;         {DE:"vb4501 - app pulsante hmi start"}
    Vb4502_AppPosMacchinaPerZero            AT %MB300.4502 : BOOL;         {DE:"vb4502 - a ON tutte i cilindri sono posizionati correttamente per azzeramento"}
    Vb4503_CN_Allarme                       AT %MB300.4503 : BOOL;         {DE:"vb4503 - CN in allarme"}
    Vb4504_AppPosMacchinaPerAutomatico      AT %MB300.4504 : BOOL;         {DE:"vb4504 - a ON tutte i cilindri sono posizionati correttamente per automatico"}
    Vb4505_AppEnbCambioPinze                AT %MB300.4505 : BOOL;         {DE:"vb4505 - a ON abilito i pulsanti cambio pinza"}
    Vb4506_AppCambioPinzeRun                AT %MB300.4506 : BOOL;         {DE:"vb4506 - a ON ho un cambio pinza attivo disabilito Start e automatico"}
    Vb4507_AppManAuto                       AT %MB300.4507 : BOOL;         {DE:"vb4507 - a ON sono in automatico a OFF in manuale"}
    Vb4508_AppHmiPiegatore                  AT %MB300.4508 : BOOL;         {DE:"vb4508 - a tasto hmi piegatore"}
    Vb4509_AppEnbPiegatore                  AT %MB300.4509 : BOOL;         {DE:"vb4509 - a ON abilito il piegatore"}
    Vb4510_AppHmiCaricatore                 AT %MB300.4510 : BOOL;         {DE:"vb4510 - a tasto hmi  caricatore"}
    Vb4511_AppEnbCaricatore                 AT %MB300.4511 : BOOL;         {DE:"vb4511 - a ON abilito il caricatore"}
    Vb4512_AppHmiCucitrice2                 AT %MB300.4512 : BOOL;         {DE:"vb4512 - a tasto hmi cucitrice 2"}
    Vb4513_AppEnbCucitrice2                 AT %MB300.4513 : BOOL;         {DE:"vb4513 - a ON abilito la cucitrice 2"}
    Vb4514_AppHmiScaricatore                AT %MB300.4514 : BOOL;         {DE:"vb4514 - a tasto hmi  scaricatore"}
    Vb4515_AppEnbScaricatore                AT %MB300.4515 : BOOL;         {DE:"vb4515 - a ON abilito lo scaricatore"}
    Vb4516_AppHmiScambioPinzeC1_Car2        AT %MB300.4516 : BOOL;         {DE:"vb4516 - a tasto hmi tipo scambio pinza tra cucitrice 1 e caricatore 2"}
    Vb4518_EnbQuartoXL                      AT %MB300.4518 : BOOL;         {DE:"vb4518 - a ON abilito quarto XL"}
    Vb4519_AppScaricoCortiConPinza          AT %MB300.4519 : BOOL;         {DE:"vb4519 - a ON abilitolo scarico dei pezzi piccoli con la pinza"}
    Vb4520_AppScaricoCortiConPinzaRunning   AT %MB300.4520 : BOOL;         {DE:"vb4520 - a ON mentre sta girando il ciclo scaricatore pezzi piccoli"}
    Vb4521_AppHmiTestPiegatore              AT %MB300.4521 : BOOL;         {DE:"vb4521 - a tasto hmi test piegatore"}
    Vb4522_AppHmiTestTrasl                  AT %MB300.4522 : BOOL;         {DE:"vb4522 - a tasto hmi test traslatore"}
    Vb4523_C2_PinzaDietroUnaTesta           AT %MB300.4523 : BOOL;         {DE:"vb4523 - a ON la pinza cucitura è nella posizione distro perchè ho Solo una testa"}
    Vb4580_EnbSgancioPinzaDopoZero          AT %MB300.4580 : BOOL;         {DE:"vb4580 - a ON sgancia le pinze alla fine dell'azzeramento"}
    Vb4581_EnbAggancioPinzaAutomatico       AT %MB300.4581 : BOOL;         {DE:"vb4581 - a ON aggancia le pinze in automatico"}
    Vb4582_EnbSgancioPinzaFineCucitura      AT %MB300.4582 : BOOL;         {DE:"vb4582 - a ON sgancia le pinze alla fine della cucitura"}
    Vb4583_EnbStartAutomatico               AT %MB300.4583 : BOOL;         {DE:"vb4583 - a ON si avvia dopo l'aggancio delle pinze"}
    Vb4584_EnbPinzeInManuale                AT %MB300.4584 : BOOL;         {DE:"vb4584 - a ON esclude l'aggancio e lo start in  automatico"}
    Vb4601_AppRit_i24_C1_PinzaEstAlta       AT %MB300.4601 : BOOL;         {DE:"vb4601 - ritardo pinza esterna C1"}
    Vb4602_AppRit_i49_FcPinzaTraslBassa     AT %MB300.4602 : BOOL;         {DE:"vb4602 - ritardo pinza traslatore bassa"}
    Vb4603_AppRit_i23_C1_PinzaIntBassa      AT %MB300.4603 : BOOL;         {DE:"vb4603 - ritardo pinza interna alta C1"}
    Vb4701_AppRit                           AT %MB300.4701 : BOOL;         {DE:"vb4701 - ritardo"}
    Vb4801_PulsStartHmiC1                   AT %MB300.4801 : BOOL;         {DE:"vb4801 - pulsante su hmi per start cucitrice 1"}
    Vb4802_PulsResetHmiC1                   AT %MB300.4802 : BOOL;         {DE:"vb4802 - pulsante su hmi per reset cucitrice 1"}
    Vb4803_AppResetHmiC1                    AT %MB300.4803 : BOOL;         {DE:"vb4803 - memorizzo reset cucitrice 1"}
    Vb4805_AppStartCaricatoreC1             AT %MB300.4805 : BOOL;         {DE:"vb4805 - a on sto spostando le pinze cucitrice a punto di carico dopo la cucitura"}
    Vb4806_AppPinzaAltaC1                   AT %MB300.4806 : BOOL;         {DE:"vb4806 - a On con pinza alta"}
    Vb4807_PinzeAlteDopoPC                  AT %MB300.4807 : BOOL;         {DE:"vb4807 - a On alza le pinze dopo aver raggiunto Punti Carico"}
    Vb4901_PulsStartHmiC2                   AT %MB300.4901 : BOOL;         {DE:"vb4901 - pulsante su hmi per start cucitrice 2"}
    Vb4902_PulsResetHmiC2                   AT %MB300.4902 : BOOL;         {DE:"vb4902 - pulsante su hmi per reset cucitrice 2"}
    Vb4903_AppResetHmiC2                    AT %MB300.4903 : BOOL;         {DE:"vb4903 - memorizzo reset cucitrice 2"}
    Vb4904_AppPedaleHmiC2                   AT %MB300.4904 : BOOL;         {DE:"vb4904 - pedale singolo testa 2"}
    Vb4906_AppPinzaIntAltaC2                AT %MB300.4906 : BOOL;         {DE:"vb4906 - a On con pinza alta"}
    Vb4907_PinzeAlteDopoPCC2                AT %MB300.4907 : BOOL;         {DE:"vb4907 - a On alza le pinze dopo aver raggiunto Punti Carico"}
    VbDbg                                   AT %MB300.5000 : BOOL;         {DE:"vb5000"}
    VbCmdAzzAx1                             AT %MB300.7006 : BOOL;         {DE:"vb7006 - Asse 1 - Comando azzeramento asse"}
    VbFlgAzzAx1                             AT %MB300.7013 : BOOL;         {DE:"vb7013 - Asse 1 - Flag asse azzerato"}
    VbFlgPosAx1                             AT %MB300.7014 : BOOL;         {DE:"vb7014 - Asse 1 - Flag asse in posizione"}
    VbCmdAzzAx2                             AT %MB300.7026 : BOOL;         {DE:"vb7026 - Asse 2 - Comando azzeramento asse"}
    VbFlgAzzAx2                             AT %MB300.7033 : BOOL;         {DE:"vb7033 - Asse 2 - Flag asse azzerato"}
    VbFlgPosAx2                             AT %MB300.7034 : BOOL;         {DE:"vb7034 - Asse 2 - Flag asse in posizione"}
    VbCmdAzzAx3                             AT %MB300.7046 : BOOL;         {DE:"vb7046 - Asse 3 - Comando azzeramento asse"}
    VbFlgAzzAx3                             AT %MB300.7053 : BOOL;         {DE:"vb7053 - Asse 3 - Flag asse azzerato"}
    VbFlgPosAx3                             AT %MB300.7054 : BOOL;         {DE:"vb7054 - Asse 3 - Flag asse in posizione"}
    VbCmdAzzAx4                             AT %MB300.7066 : BOOL;         {DE:"vb7066 - Asse 4 - Comando azzeramento asse"}
    VbFlgAzzAx4                             AT %MB300.7073 : BOOL;         {DE:"vb7073 - Asse 4 - Flag asse azzerato"}
    VbFlgPosAx4                             AT %MB300.7074 : BOOL;         {DE:"vb7074 - Asse 4 - Flag asse in posizione"}
    VbCmdAzzAx5                             AT %MB300.7086 : BOOL;         {DE:"vb7086 - Asse 5 - Comando azzeramento asse"}
    VbFlgAzzAx5                             AT %MB300.7093 : BOOL;         {DE:"vb7093 - Asse 5 - Flag asse azzerato"}
    VbFlgPosAx5                             AT %MB300.7094 : BOOL;         {DE:"vb7094 - Asse 5 - Flag asse in posizione"}
    VbCmdAzzAx6                             AT %MB300.7106 : BOOL;         {DE:"vb7106 - Asse 6 - Comando azzeramento asse"}
    VbFlgAzzAx6                             AT %MB300.7113 : BOOL;         {DE:"vb7113 - Asse 6 - Flag asse azzerato"}
    VbFlgPosAx6                             AT %MB300.7114 : BOOL;         {DE:"vb7114 - Asse 6 - Flag asse in posizione"}
    VbCmdAzzAx7                             AT %MB300.7126 : BOOL;         {DE:"vb7126 - Asse 7 - Comando azzeramento asse"}
    VbFlgAzzAx7                             AT %MB300.7133 : BOOL;         {DE:"vb7133 - Asse 7 - Flag asse azzerato"}
    VbFlgPosAx7                             AT %MB300.7134 : BOOL;         {DE:"vb7134 - Asse 7 - Flag asse in posizione"}
    VbCmdAzzAx8                             AT %MB300.7146 : BOOL;         {DE:"vb7146 - Asse 8 - Comando azzeramento asse"}
    VbFlgAzzAx8                             AT %MB300.7153 : BOOL;         {DE:"vb7153 - Asse 8 - Flag asse azzerato"}
    VbFlgPosAx8                             AT %MB300.7154 : BOOL;         {DE:"vb7154 - Asse 8 - Flag asse in posizione"}
    VbCmdAzzAx9                             AT %MB300.7166 : BOOL;         {DE:"vb7166 - Asse 9 - Comando azzeramento asse"}
    VbFlgAzzAx9                             AT %MB300.7173 : BOOL;         {DE:"vb7173 - Asse 9 - Flag asse azzerato"}
    VbFlgPosAx9                             AT %MB300.7174 : BOOL;         {DE:"vb7174 - Asse 9 - Flag asse in posizione"}
    VbCmdAzzAx10                            AT %MB300.7186 : BOOL;         {DE:"vb7186 - Asse 10 - Comando azzeramento asse"}
    VbFlgAzzAx10                            AT %MB300.7193 : BOOL;         {DE:"vb7193 - Asse 10 - Flag asse azzerato"}
    VbFlgPosAx10                            AT %MB300.7194 : BOOL;         {DE:"vb7194 - Asse 10 - Flag asse in posizione"}
    VbChn1Start                             AT %MB300.7901 : BOOL;         {DE:"vb7901 - VB START canale 1"}
    VbChn1Reset                             AT %MB300.7903 : BOOL;         {DE:"vb7903 - VB RESET canale 1"}
    VbChn1AutoRun                           AT %MB300.7908 : BOOL;         {DE:"vb7908 - VB Auto Running canale 1"}
    VbChn2Start                             AT %MB300.7921 : BOOL;         {DE:"vb7921 - VB START canale 2"}
    VbChn2Reset                             AT %MB300.7923 : BOOL;         {DE:"vb7923 - VB RESET canale 2"}
    VbChn2AutoRun                           AT %MB300.7928 : BOOL;         {DE:"vb7928 - VB Auto Running canale 2"}
    VbChn3Start                             AT %MB300.7941 : BOOL;         {DE:"vb7941 - VB START canale 3"}
    VbChn3Reset                             AT %MB300.7943 : BOOL;         {DE:"vb7943 - VB RESET canale 3"}
    VbChn3AutoRun                           AT %MB300.7948 : BOOL;         {DE:"vb7948 - VB Auto Running canale 3"}


    VnErrCodeCamme                          AT %MW400.1    : INT;          {DE:"vn1    - Codice di erore delle funzioni di camme"}
    Vn2CodiceAllarmeXHmi                    AT %MW400.2    : INT;          {DE:"vn2    - codice allarme da visualizzare su HMI"}
    Vn3CodiceAllarmeUdf                     AT %MW400.3    : INT;          {DE:"vn3    - codice allarme lettura udf"}
    Vn4CodiceWarning                        AT %MW400.4    : INT;          {DE:"vn4    - codice warning inviato dal PLC al HMI"}
    Vn10MemoStatoCuci1                      AT %MW400.10   : INT;          {DE:"vn10   - Memorizzo lo stato cuci 1 quando sono in step o reset piegatore ( macchina a stati canale 3 )"}
    VnStatoCuci1                            AT %MW400.11   : INT;          {DE:"vn11   - Stato cuci 1 ( macchina a stati canale 3 )"}
    VnStatoCuci2                            AT %MW400.12   : INT;          {DE:"vn12   - Stato cuci 2 ( macchina a stati canale 3 )"}
    Vn13MemoStatoCuci2                      AT %MW400.13   : INT;          {DE:"vn13   - Memorizzo lo stato cuci 1 quando sono in step traslatore ( macchina a stati canale 3 )"}
    Vn14TipoScartafiloC1                    AT %MW400.14   : INT;          {DE:"vn14   - 0 = no scartafilo, 1 = scartafilo dopo ritorno punto carico 2 = scartafilo ogni rasafilo"}
    Vn15TipoScartafiloC2                    AT %MW400.15   : INT;          {DE:"vn15   - 0 = no scartafilo, 1 = scartafilo dopo ritorno punto carico 2 = scartafilo ogni rasafilo"}
    Vn16GoCuci                              AT %MW400.16   : INT;          {DE:"vn16   - =1 C1_ExeCucitura può partire a cucire,=2 abort C1_ExeCucitura"}
    Vn17GoCuci_C2                           AT %MW400.17   : INT;          {DE:"vn17   - =1 C1_ExeCucitura può partire a cucire,=2 abort C1_ExeCucitura"}
    Fun202VnParIndx_0                       AT %MW400.20   : INT;          {DE:"vn20   - Codice della funzione"}
    Fun202VnParIndx_1                       AT %MW400.21   : INT;          {DE:"vn21   - FunId – identificativo della funzione"}
    Fun202VnParIndx_2                       AT %MW400.22   : INT;          {DE:"vn22   - Indice vb abilitazione della funzione"}
    Fun202VnParIndx_3                       AT %MW400.23   : INT;          {DE:"vn23   - Indice vq contatore"}
    Vn101_Piegatore1_CH                     AT %MW400.101  : INT;          {DE:"vn101  - Numero Primo piegatore attivato"}
    Vn102_Piegatore2_CH                     AT %MW400.102  : INT;          {DE:"vn102  - Numero Secondo piegatore attivato"}
    Vn103_Piegatore3_CH                     AT %MW400.103  : INT;          {DE:"vn103  - Numero Terzo piegatore attivato"}
    Vn104_Piegatore4_CH                     AT %MW400.104  : INT;          {DE:"vn104  - Numero Quarto piegatore attivato"}
    Vn105_Piegatore1_AP                     AT %MW400.105  : INT;          {DE:"vn105  - Numero Primo piegatore disattivato"}
    Vn106_Piegatore2_AP                     AT %MW400.106  : INT;          {DE:"vn106  - Numero Secondo piegatore disattivato"}
    Vn107_Piegatore3_AP                     AT %MW400.107  : INT;          {DE:"vn107  - Numero Terzo piegatore disattivato"}
    Vn108_Piegatore4_AP                     AT %MW400.108  : INT;          {DE:"vn108  - Numero Quarto piegatore disattivato"}
    Vn109_OrdinePiegCH                      AT %MW400.109  : INT;          {DE:"vn109  - ordine chiusura piegatori memorizzato su programma"}
    Vn110_OrdinePiegAP                      AT %MW400.110  : INT;          {DE:"vn110  - ordine apertura piegatori memorizzato su programma"}
    Vn111_EnbEtichetta                      AT %MW400.111  : INT;          {DE:"vn111  - /// a ON abilito la pausa per mettere l'etichetta ( 1 = tutte) ( 2 = 1 si 1 no )"}
    Vn112_AppEtichettaMod_2                 AT %MW400.112  : INT;          {DE:"vn112  - /// utilizzata come appoggio modo 2 ( se serve mettere reset )"}
    Vn115_CopiaSeqPiegFree                  AT %MW400.115  : INT;          {DE:"vn115  - copia sequenza piegatura Free per pagina touch"}
    Vn120_AppEnbScambioPinzeC1_Car2         AT %MW400.120  : INT;          {DE:"vn120  - a 1 abilito tipo scambio pinza tra cucitrice 1 e caricatore 2"}
    Vn131_Debug                             AT %MW400.131  : INT;          {DE:"vn131  - debug su pagina AUTO touch"}
    Vn132_DebugPie                          AT %MW400.132  : INT;          {DE:"vn132  - debug su pagina AUTO touch"}
    Vn133_DebugAuto                         AT %MW400.133  : INT;          {DE:"vn133  - debug su pagina AUTO touch"}
    Vn151_SpeedStep1                        AT %MW400.151  : INT;          {DE:"vn151  - vn velocità jog assi pinza comandati da HMI step 1"}
    Vn152_SpeedStep2                        AT %MW400.152  : INT;          {DE:"vn152  - vn velocità jog assi pinza comandati da HMI step 2"}
    Vn153_SpeedStep3                        AT %MW400.153  : INT;          {DE:"vn153  - vn velocità jog assi pinza comandati da HMI step 3"}
    mc_stati_PiuMenoTensione                AT %MW400.160  : INT;          {DE:"vn160  - indice macchina stati per gestione tasti + - del valore tensione filo"}
    mc_stati_PiuMenoTensioneT2              AT %MW400.161  : INT;          {DE:"vn161  - indice macchina stati per gestione tasti + - del valore tensione filo"}
    Vn162_Read_anaout99                     AT %MW400.162  : INT;          {DE:"vn162"}
    Vn163_Read_anaout100                    AT %MW400.163  : INT;          {DE:"vn163"}
    mc_stati_Carica_Pattina                 AT %MW400.164  : INT;          {DE:"vn164"}
    Vn196_Tasca_DX_C1                       AT %MW400.196  : INT;          {DE:"vn196"}
    Vn197_Tasca_SX_C1                       AT %MW400.197  : INT;          {DE:"vn197"}
    Vn198_Tasca_DX_C2                       AT %MW400.198  : INT;          {DE:"vn198"}
    Vn199_Tasca_SX_C2                       AT %MW400.199  : INT;          {DE:"vn199"}
    Vn200_Tipo_DXSX_Ultima_cucita_su_C1     AT %MW400.200  : INT;          {DE:"vn200  - 0 = nessuna indicazione dalla C1, 1 = la tasca prelevata dal traslatore dalla testa 1 era DX,2 = la tasca prelevata dal traslatore dalla testa 1 era SX"}
    Vn201PrgForkPiegatore                   AT %MW400.201  : INT;          {DE:"vn201"}
    Vn202PrgForkCaricatoreMan               AT %MW400.202  : INT;          {DE:"vn202"}
    Vn203PrgForkResetFolder                 AT %MW400.203  : INT;          {DE:"vn203"}
    VnDeltaCntGiri_C1                       AT %MW400.231  : INT;          {DE:"vn231"}
    VnMemCntGiri_C1                         AT %MW400.232  : INT;          {DE:"vn232"}
    VnDeltaCntGiri_C2                       AT %MW400.233  : INT;          {DE:"vn233"}
    VnMemCntGiri_C2                         AT %MW400.234  : INT;          {DE:"vn234"}
    CodiceDeviceOptional                    AT %MW400.236  : INT;          {DE:"vn236"}
    Vn240AnnoOrologioPLC                    AT %MW400.240  : INT;          {DE:"vn240"}
    Vn241MeseOrologioPLC                    AT %MW400.241  : INT;          {DE:"vn241"}
    Vn242giornoOrologioPLC                  AT %MW400.242  : INT;          {DE:"vn242"}
    Vn243OraOrologioPLC                     AT %MW400.243  : INT;          {DE:"vn243"}
    Vn244MinutiOrologioPLC                  AT %MW400.244  : INT;          {DE:"vn244"}
    Vn245secondiOrologioPLC                 AT %MW400.245  : INT;          {DE:"vn245"}
    Vn246LimiteAnno                         AT %MW400.246  : INT;          {DE:"vn246"}
    Vn247LimiteMese                         AT %MW400.247  : INT;          {DE:"vn247"}
    Vn248LimiteGiorno                       AT %MW400.248  : INT;          {DE:"vn248"}
    Vn_ID_macchina                          AT %MW400.320  : INT;          {DE:"vn320  - vn numero identificatore macchina,"}
    v_ntest                                 AT %MW400.777  : INT;          {DE:"vn777"}
    vntest1                                 AT %MW400.778  : INT;          {DE:"vn778"}
    vntest2                                 AT %MW400.779  : INT;          {DE:"vn779"}
    vntest3                                 AT %MW400.780  : INT;          {DE:"vn780"}
    VnOvdAx1                                AT %MW400.3001 : INT;          {DE:"vn3001 - Asse 1 - Override indipendente"}
    VnFaseZeroAx1                           AT %MW400.3011 : INT;          {DE:"vn3011 - Asse 1 - Fase azzeramento"}
    VnStatoAx1                              AT %MW400.3013 : INT;          {DE:"vn3013 - Asse 1 - Status asse"}
    VnOvdAx2                                AT %MW400.3021 : INT;          {DE:"vn3021 - Asse 2 - Override indipendente"}
    VnFaseZeroAx2                           AT %MW400.3031 : INT;          {DE:"vn3031 - Asse 2 - Fase azzeramento"}
    VnStatoAx2                              AT %MW400.3033 : INT;          {DE:"vn3033 - Asse 2 - Status asse"}
    VnOvdAx3                                AT %MW400.3041 : INT;          {DE:"vn3041 - Asse 3 - Override indipendente"}
    VnVelJogAx3                             AT %MW400.3042 : INT;          {DE:"vn3042"}
    VnVelSemiAutoAx3                        AT %MW400.3049 : INT;          {DE:"vn3049"}
    VnFaseZeroAx3                           AT %MW400.3051 : INT;          {DE:"vn3051 - Asse 3 - Fase azzeramento"}
    VnStatoAx3                              AT %MW400.3053 : INT;          {DE:"vn3053 - Asse 3 - Status asse"}
    VnOvdAx4                                AT %MW400.3061 : INT;          {DE:"vn3061 - Asse 4 - Override indipendente"}
    VnFaseZeroAx4                           AT %MW400.3071 : INT;          {DE:"vn3071 - Asse 4 - Fase azzeramento"}
    VnStatoAx4                              AT %MW400.3073 : INT;          {DE:"vn3073 - Asse 4 - Status asse"}
    VnOvdAx5                                AT %MW400.3081 : INT;          {DE:"vn3081 - Asse 5 - Override indipendente"}
    VnVelJogAx5                             AT %MW400.3082 : INT;          {DE:"vn3082"}
    VnVelSemiAutoAx5                        AT %MW400.3089 : INT;          {DE:"vn3089"}
    VnFaseZeroAx5                           AT %MW400.3091 : INT;          {DE:"vn3091 - Asse 5 - Fase azzeramento"}
    VnStatoAx5                              AT %MW400.3093 : INT;          {DE:"vn3093 - Asse 5 - Status asse"}
    VnOvdAx6                                AT %MW400.3101 : INT;          {DE:"vn3101 - Asse 6 - Override indipendente"}
    VnFaseZeroAx6                           AT %MW400.3111 : INT;          {DE:"vn3111 - Asse 6 - Fase azzeramento"}
    VnStatoAx6                              AT %MW400.3113 : INT;          {DE:"vn3113 - Asse 6 - Status asse"}
    VnOvdAx7                                AT %MW400.3121 : INT;          {DE:"vn3121 - Asse 7 - Override indipendente"}
    VnFaseZeroAx7                           AT %MW400.3131 : INT;          {DE:"vn3131 - Asse 7 - Fase azzeramento"}
    VnStatoAx7                              AT %MW400.3133 : INT;          {DE:"vn3133 - Asse 7 - Status asse"}
    VnOvdAx8                                AT %MW400.3141 : INT;          {DE:"vn3141 - Asse 8 - Override indipendente"}
    VnVelJogAx8                             AT %MW400.3142 : INT;          {DE:"vn3142"}
    VnVelSemiAutoAx8                        AT %MW400.3149 : INT;          {DE:"vn3149"}
    VnFaseZeroAx8                           AT %MW400.3151 : INT;          {DE:"vn3151 - Asse 8 - Fase azzeramento"}
    VnStatoAx8                              AT %MW400.3153 : INT;          {DE:"vn3153 - Asse 8 - Status asse"}
    VnOvdAx9                                AT %MW400.3161 : INT;          {DE:"vn3161 - Asse 9 - Override indipendente"}
    VnFaseZeroAx9                           AT %MW400.3171 : INT;          {DE:"vn3171 - Asse 9 - Fase azzeramento"}
    VnStatoAx9                              AT %MW400.3173 : INT;          {DE:"vn3173 - Asse 9 - Status asse"}
    VnOvdAx10                               AT %MW400.3181 : INT;          {DE:"vn3181 - Asse 10 - Override indipendente"}
    VnVelJogAx10                            AT %MW400.3182 : INT;          {DE:"vn3182"}
    VnVelSemiAutoAx10                       AT %MW400.3189 : INT;          {DE:"vn3189"}
    VnFaseZeroAx10                          AT %MW400.3191 : INT;          {DE:"vn3191 - Asse 10 - Fase azzeramento"}
    VnStatoAx10                             AT %MW400.3193 : INT;          {DE:"vn3193 - Asse 10 - Status asse"}
    Vn3804_PageID                           AT %MW400.3804 : INT;          {DE:"vn3804 - Pagina in esecuzione"}


    CamMode                                 AT %MD500.1    : DINT;         {DE:"vq1    - Camme: modo operativo"}
    CamAxNum                                AT %MD500.2    : DINT;         {DE:"vq2    - Camme: numero dell'asse"}
    CamDigOut                               AT %MD500.3    : DINT;         {DE:"vq3    - Camme: n. uscita digitale o indice VB"}
    CamStart                                AT %MD500.4    : DINT;         {DE:"vq4    - Camme: soglia start"}
    CamStop                                 AT %MD500.5    : DINT;         {DE:"vq5    - Camme: soglia stop"}
    CamModule                               AT %MD500.6    : DINT;         {DE:"vq6    - Camme: modulo"}
    CamCmd                                  AT %MD500.10   : DINT;         {DE:"vq10   - Camme: comando"}
    CamPar1                                 AT %MD500.11   : DINT;         {DE:"vq11   - Camme: parametro 1"}
    CamPar2                                 AT %MD500.12   : DINT;         {DE:"vq12   - Camme: parametro 2"}
    CamPar3                                 AT %MD500.13   : DINT;         {DE:"vq13   - Camme: parametro 3"}
    CamPar4                                 AT %MD500.14   : DINT;         {DE:"vq14   - Camme: parametro 4"}
    CamPar5                                 AT %MD500.15   : DINT;         {DE:"vq15   - Camme: parametro 5"}
    RollPlcAgoModule                        AT %MD500.20   : DINT;         {DE:"vq20   - Rollover asse ago - Modulo"}
    RollPlcAgoQuo                           AT %MD500.21   : DINT;         {DE:"vq21   - Rollover asse ago - Quota dopo il rollover"}
    GoAxPlcAgoErrCode                       AT %MD500.22   : DINT;         {DE:"vq22   - GoAx asse ago - ErrorCode"}
    GoAxPlcAgoModule                        AT %MD500.23   : DINT;         {DE:"vq23   - GoAx asse ago - Modulo per asse tondo"}
    GoAxPlcAgoVel                           AT %MD500.24   : DINT;         {DE:"vq24   - GoAx asse ago - Velocita'"}
    StopPlcAgoErrCode                       AT %MD500.25   : DINT;         {DE:"vq25   - Stop asse ago - ErrorCode"}
    StopPlcAgoQuoObj                        AT %MD500.26   : DINT;         {DE:"vq26   - Stop asse ago - Quota obiettivo"}
    StopPlcAgoFuture                        AT %MD500.27   : DINT;         {DE:"vq27   - Stop asse ago - future espansioni"}
    MovePlcAgoErrCode                       AT %MD500.28   : DINT;         {DE:"vq28   - Mov. asse ago - ErrorCode"}
    MovePlcAgoQuoObj                        AT %MD500.29   : DINT;         {DE:"vq29   - Mov. asse ago - Quota obiettivo"}
    MovePlcAgoVel                           AT %MD500.30   : DINT;         {DE:"vq30   - Mov. asse ago - Velocita'"}
    MovePlcAgoFuture                        AT %MD500.31   : DINT;         {DE:"vq31   - Mov. asse ago - future espansioni"}
    PosAx_C1_AsseX                          AT %MD500.51   : DINT;         {DE:"vq51   - Cucitrice 1 - Asse X"}
    PosAx_C1_AsseY                          AT %MD500.52   : DINT;         {DE:"vq52   - Cucitrice 1 - Asse Y"}
    PosAx_C1_AsseAGO                        AT %MD500.53   : DINT;         {DE:"vq53   - Cucitrice 1 - Asse AGO"}
    PosAx_C1_AsseCRO                        AT %MD500.54   : DINT;         {DE:"vq54   - Cucitrice 1 - Asse CROCHET"}
    PosAx_C1_AsseCAR                        AT %MD500.55   : DINT;         {DE:"vq55   - Cucitrice 1 - Asse CARICATORE"}
    PosAx_C2_AsseX                          AT %MD500.56   : DINT;         {DE:"vq56   - Cucitrice 2 - Asse X"}
    PosAx_C2_AsseY                          AT %MD500.57   : DINT;         {DE:"vq57   - Cucitrice 2 - Asse Y"}
    PosAx_C2_AsseAGO                        AT %MD500.58   : DINT;         {DE:"vq58   - Cucitrice 2 - Asse AGO"}
    PosAx_C2_AsseCRO                        AT %MD500.59   : DINT;         {DE:"vq59   - Cucitrice 2 - Asse CROCHET"}
    PosAx_C2_AsseCAR                        AT %MD500.60   : DINT;         {DE:"vq60   - Cucitrice 2 - Asse CARICATORE"}
    PosAx11                                 AT %MD500.61   : DINT;         {DE:"vq61   - Posizione asse 11"}
    PosAx12                                 AT %MD500.62   : DINT;         {DE:"vq62   - Posizione asse 12"}
    PosAx13                                 AT %MD500.63   : DINT;         {DE:"vq63   - Posizione asse 13"}
    PosAx14                                 AT %MD500.64   : DINT;         {DE:"vq64   - Posizione asse 14"}
    PosAx15                                 AT %MD500.65   : DINT;         {DE:"vq65   - Posizione asse 15"}
    PosAx16                                 AT %MD500.66   : DINT;         {DE:"vq66   - Posizione asse 16"}
    Vq_100_WRITE_FC_ind_X                   AT %MD500.100  : DINT;         {DE:"vq100  - Vq scrittura fine corsa indietro asse X"}
    Vq_101_WRITE_FC_ava_X                   AT %MD500.101  : DINT;         {DE:"vq101  - Vq scrittura fine corsa avanti asse X"}
    Vq_102_WRITE_FC_ind_Y                   AT %MD500.102  : DINT;         {DE:"vq102  - Vq scrittura fine corsa indietro asse Y"}
    Vq_103_WRITE_FC_ava_Y                   AT %MD500.103  : DINT;         {DE:"vq103  - Vq scrittura fine corsa avanti asse Y"}
    Vq_104_READ_FC_ind_X                    AT %MD500.104  : DINT;         {DE:"vq104  - Vq lettura fine corsa indietro asse X"}
    Vq_105_READ_FC_ava_X                    AT %MD500.105  : DINT;         {DE:"vq105  - Vq lettura fine corsa avanti asse X"}
    Vq_106_READ_FC_ind_Y                    AT %MD500.106  : DINT;         {DE:"vq106  - Vq lettura fine corsa indietro asse Y"}
    Vq_107_READ_FC_ava_Y                    AT %MD500.107  : DINT;         {DE:"vq107  - Vq lettura fine corsa avanti asse Y"}
    Vq108_WRITE_Vel_manualeAgo_C1           AT %MD500.108  : DINT;         {DE:"vq108  - Vq da inserire nel parametro asse velocità manuale asse Ago"}
    Vq109_WRITE_Vel_manualeAgo_C2           AT %MD500.109  : DINT;         {DE:"vq109  - Vq da inserire nel parametro asse velocità manuale asse Ago"}
    Vq_110_READ_FC_ind_CARIC                AT %MD500.110  : DINT;         {DE:"vq110  - Vq lettura fine corsa dietro caricatore"}
    Vq_111_READ_FC_ava_CARIC                AT %MD500.111  : DINT;         {DE:"vq111  - Vq lettura fine corsa avanti caricatore"}
    Vq_114_READ_FC_ind_X_C2                 AT %MD500.114  : DINT;         {DE:"vq114  - Vq lettura fine corsa indietro asse X C2"}
    Vq_115_READ_FC_ava_X_C2                 AT %MD500.115  : DINT;         {DE:"vq115  - Vq lettura fine corsa avanti asse X C2"}
    Vq_116_READ_FC_ind_Y_C2                 AT %MD500.116  : DINT;         {DE:"vq116  - Vq lettura fine corsa indietro asse Y V'"}
    Vq_117_READ_FC_ava_Y_C2                 AT %MD500.117  : DINT;         {DE:"vq117  - Vq lettura fine corsa avanti asse Y C2"}
    Vq_118_READ_FC_ind_CARIC_C2             AT %MD500.118  : DINT;         {DE:"vq118  - Vq lettura fine corsa indietro traslatore"}
    Vq_119_READ_FC_ava_CARIC_C2             AT %MD500.119  : DINT;         {DE:"vq119  - Vq lettura fine corsa avanti traslatore"}
    Vq3000_RitPiegatoreAD_ON                AT %MD500.3000 : DINT;         {DE:"vq3000"}
    Vq3001_RitPiegatoreAD_OFF               AT %MD500.3001 : DINT;         {DE:"vq3001"}
    Vq3002_RitPiegatoreAlto_ON              AT %MD500.3002 : DINT;         {DE:"vq3002"}
    Vq3003_RitPiegatoreAlto_OFF             AT %MD500.3003 : DINT;         {DE:"vq3003"}
    Vq3004_RitElettrocPerno_ON              AT %MD500.3004 : DINT;         {DE:"vq3004"}
    Vq3005_RitElettrocPerno_OFF             AT %MD500.3005 : DINT;         {DE:"vq3005"}
    Vq3006_RitPiegatore_1_ON                AT %MD500.3006 : DINT;         {DE:"vq3006"}
    Vq3007_RitPiegatore_1_OFF               AT %MD500.3007 : DINT;         {DE:"vq3007"}
    Vq3008_RitPiegatore_2_ON                AT %MD500.3008 : DINT;         {DE:"vq3008"}
    Vq3009_RitPiegatore_2_OFF               AT %MD500.3009 : DINT;         {DE:"vq3009"}
    Vq3010_RitPiegatore_3_ON                AT %MD500.3010 : DINT;         {DE:"vq3010"}
    Vq3011_RitPiegatore_3_OFF               AT %MD500.3011 : DINT;         {DE:"vq3011"}
    Vq3012_RitPiegatore_4_ON                AT %MD500.3012 : DINT;         {DE:"vq3012"}
    Vq3013_RitPiegatore_4_OFF               AT %MD500.3013 : DINT;         {DE:"vq3013"}
    Vq3014_RitBilancere_ON                  AT %MD500.3014 : DINT;         {DE:"vq3014"}
    Vq3015_RitBilancere_OFF                 AT %MD500.3015 : DINT;         {DE:"vq3015"}
    Vq3016_RitElettrocSotto_ON              AT %MD500.3016 : DINT;         {DE:"vq3016"}
    Vq3017_RitElettrocSotto_OFF             AT %MD500.3017 : DINT;         {DE:"vq3017"}
    Vq3018_RitPosCaricatoreCarico           AT %MD500.3018 : DINT;         {DE:"vq3018"}
    Vq3019_RitPosCaricatoreScarico          AT %MD500.3019 : DINT;         {DE:"vq3019"}
    Vq3020_RitPinzaCaricatore_ON            AT %MD500.3020 : DINT;         {DE:"vq3020"}
    Vq3021_RitPinzaCaricatore_OFF           AT %MD500.3021 : DINT;         {DE:"vq3021"}
    Vq3022_RitLancia_ON                     AT %MD500.3022 : DINT;         {DE:"vq3022 - ////// non utilizzato"}
    Vq3023_RitLancia_OFF                    AT %MD500.3023 : DINT;         {DE:"vq3023"}
    Vq3024_RitCarSopraLancia                AT %MD500.3024 : DINT;         {DE:"vq3024"}
    Vq3025_RitCarRispettoBarra2             AT %MD500.3025 : DINT;         {DE:"vq3025"}
    Vq3050_RitC1_Pinza_est_ON               AT %MD500.3050 : DINT;         {DE:"vq3050 - non utilizzato"}
    Vq3050_RitC1_Pinza_est_OFF              AT %MD500.3051 : DINT;         {DE:"vq3051"}
    Vq3052_RitC1_Pinza_int_ON               AT %MD500.3052 : DINT;         {DE:"vq3052"}
    Vq3053_Tim_C1_Scartafilo                AT %MD500.3053 : DINT;         {DE:"vq3053"}
    Vq3054_C1_VelFeed_Reset                 AT %MD500.3054 : DINT;         {DE:"vq3054 - Velocità movimenti XY durante Reset chiamato da HMI"}
    C1_SogliaVelRaffAgo                     AT %MD500.3057 : DINT;         {DE:"vq3057 - soglia velocita' raffreddamento ago"}
    C2_SogliaVelRaffAgo                     AT %MD500.3058 : DINT;         {DE:"vq3058 - soglia velocita' raffreddamento ago"}
    Vq3060_                                 AT %MD500.3060 : DINT;         {DE:"vq3060 - non utilizzato"}
    Vq3063_Tim_C2_Scartafilo                AT %MD500.3063 : DINT;         {DE:"vq3063"}
    Vq3070_RitPinzaTraslatore_ON            AT %MD500.3070 : DINT;         {DE:"vq3070"}
    Vq3071_RitTras_Scaric                   AT %MD500.3071 : DINT;         {DE:"vq3071"}
    Vq3080_RitScaricatoreDxSx_ON_OK         AT %MD500.3080 : DINT;         {DE:"vq3080"}
    Vq3081_RitScaricatoreDxSx_OFF           AT %MD500.3081 : DINT;         {DE:"vq3081"}
    Vq3082_RitScaricatorePrimaBarra         AT %MD500.3082 : DINT;         {DE:"vq3082"}
    Vq3083_RitScaricatoreSecondaBarra       AT %MD500.3083 : DINT;         {DE:"vq3083"}
    Vq3084_SpostamentoPinzaPezziCorti       AT %MD500.3084 : DINT;         {DE:"vq3084"}
    Vq3085_RitPrimaBarra_ScarSuRasafilo     AT %MD500.3085 : DINT;         {DE:"vq3085"}
    Vq3090_TimeoutSensori                   AT %MD500.3090 : DINT;         {DE:"vq3090"}
    Vq3091_TimeAsp_Lentezza                 AT %MD500.3091 : DINT;         {DE:"vq3091"}
    Vq3092_QuoteLimiteAsseY_C1              AT %MD500.3092 : DINT;         {DE:"vq3092 - se durante l'azzeramento l'asse Y si trova sotto a questa quota allora sposto l'asse Y a questa quota e poi azzero X"}
    Vq3093_QuoteLimiteAsseY_C2              AT %MD500.3093 : DINT;         {DE:"vq3093 - se durante l'azzeramento l'asse Y si trova sotto a questa quota allora sposto l'asse Y a questa quota e poi azzero X"}
    Vq3094_TimeColpoTensione                AT %MD500.3094 : DINT;         {DE:"vq3094 - durata del colpo forte per chiudere la tensione filo"}
    Vq3095_TimeChiusTensTasti               AT %MD500.3095 : DINT;         {DE:"vq3095 - quando premo i teasti Ten+ e Tens- su HMI la tensione rimane chiusa per questo tempo"}
    Vq3106_RitPiegatore_1_ON                AT %MD500.3106 : DINT;         {DE:"vq3106 - variabile per memorizzare tempo su sequenza Standard"}
    Vq3107_RitPiegatore_1_OFF               AT %MD500.3107 : DINT;         {DE:"vq3107 - variabile per memorizzare tempo su sequenza Standard"}
    Vq3108_RitPiegatore_2_ON                AT %MD500.3108 : DINT;         {DE:"vq3108 - variabile per memorizzare tempo su sequenza Standard"}
    Vq3109_RitPiegatore_2_OFF               AT %MD500.3109 : DINT;         {DE:"vq3109 - variabile per memorizzare tempo su sequenza Standard"}
    Vq3110_RitPiegatore_3_ON                AT %MD500.3110 : DINT;         {DE:"vq3110 - variabile per memorizzare tempo su sequenza Standard"}
    Vq3111_RitPiegatore_3_OFF               AT %MD500.3111 : DINT;         {DE:"vq3111 - variabile per memorizzare tempo su sequenza Standard"}
    Vq3112_RitPiegatore_4_ON                AT %MD500.3112 : DINT;         {DE:"vq3112 - variabile per memorizzare tempo su sequenza Standard"}
    Vq3113_RitPiegatore_4_OFF               AT %MD500.3113 : DINT;         {DE:"vq3113 - variabile per memorizzare tempo su sequenza Standard"}
    Vq3114_RitPiegatore_1_ON                AT %MD500.3114 : DINT;         {DE:"vq3114 - variabile per memorizzare tempo su sequenza Curve3"}
    Vq3115_RitPiegatore_1_OFF               AT %MD500.3115 : DINT;         {DE:"vq3115 - variabile per memorizzare tempo su sequenza Curve3"}
    Vq3116_RitPiegatore_2_ON                AT %MD500.3116 : DINT;         {DE:"vq3116 - variabile per memorizzare tempo su sequenza Curve3"}
    Vq3117_RitPiegatore_2_OFF               AT %MD500.3117 : DINT;         {DE:"vq3117 - variabile per memorizzare tempo su sequenza Curve3"}
    Vq3118_RitPiegatore_3_ON                AT %MD500.3118 : DINT;         {DE:"vq3118 - variabile per memorizzare tempo su sequenza Curve3"}
    Vq3119_RitPiegatore_3_OFF               AT %MD500.3119 : DINT;         {DE:"vq3119 - variabile per memorizzare tempo su sequenza Curve3"}
    Vq3120_RitPiegatore_4_ON                AT %MD500.3120 : DINT;         {DE:"vq3120 - variabile per memorizzare tempo su sequenza Curve3"}
    Vq3121_RitPiegatore_4_OFF               AT %MD500.3121 : DINT;         {DE:"vq3121 - variabile per memorizzare tempo su sequenza Curve3"}
    Vq3122_RitPiegatore_1_ON                AT %MD500.3122 : DINT;         {DE:"vq3122 - variabile per memorizzare tempo su sequenza Square"}
    Vq3123_RitPiegatore_1_OFF               AT %MD500.3123 : DINT;         {DE:"vq3123 - variabile per memorizzare tempo su sequenza Square"}
    Vq3124_RitPiegatore_2_ON                AT %MD500.3124 : DINT;         {DE:"vq3124 - variabile per memorizzare tempo su sequenza Square"}
    Vq3125_RitPiegatore_2_OFF               AT %MD500.3125 : DINT;         {DE:"vq3125 - variabile per memorizzare tempo su sequenza Square"}
    Vq3126_RitPiegatore_3_ON                AT %MD500.3126 : DINT;         {DE:"vq3126 - variabile per memorizzare tempo su sequenza Square"}
    Vq3127_RitPiegatore_3_OFF               AT %MD500.3127 : DINT;         {DE:"vq3127 - variabile per memorizzare tempo su sequenza Square"}
    Vq3128_RitPiegatore_4_ON                AT %MD500.3128 : DINT;         {DE:"vq3128 - variabile per memorizzare tempo su sequenza Square"}
    Vq3129_RitPiegatore_4_OFF               AT %MD500.3129 : DINT;         {DE:"vq3129 - variabile per memorizzare tempo su sequenza Square"}
    Vq3130_RitPiegatore_1_ON                AT %MD500.3130 : DINT;         {DE:"vq3130 - variabile per memorizzare tempo su sequenza Free"}
    Vq3131_RitPiegatore_1_OFF               AT %MD500.3131 : DINT;         {DE:"vq3131 - variabile per memorizzare tempo su sequenza Free"}
    Vq3132_RitPiegatore_2_ON                AT %MD500.3132 : DINT;         {DE:"vq3132 - variabile per memorizzare tempo su sequenza Free"}
    Vq3133_RitPiegatore_2_OFF               AT %MD500.3133 : DINT;         {DE:"vq3133 - variabile per memorizzare tempo su sequenza Free"}
    Vq3134_RitPiegatore_3_ON                AT %MD500.3134 : DINT;         {DE:"vq3134 - variabile per memorizzare tempo su sequenza Free"}
    Vq3135_RitPiegatore_3_OFF               AT %MD500.3135 : DINT;         {DE:"vq3135 - variabile per memorizzare tempo su sequenza Free"}
    Vq3136_RitPiegatore_4_ON                AT %MD500.3136 : DINT;         {DE:"vq3136 - variabile per memorizzare tempo su sequenza Free"}
    Vq3137_RitPiegatore_4_OFF               AT %MD500.3137 : DINT;         {DE:"vq3137 - variabile per memorizzare tempo su sequenza Free"}
    Vq3138_RitPiegatore_1_ON                AT %MD500.3138 : DINT;         {DE:"vq3138 - variabile per memorizzare tempo su sequenza Curve5"}
    Vq3139_RitPiegatore_1_OFF               AT %MD500.3139 : DINT;         {DE:"vq3139 - variabile per memorizzare tempo su sequenza Curve5"}
    Vq3140_RitPiegatore_2_ON                AT %MD500.3140 : DINT;         {DE:"vq3140 - variabile per memorizzare tempo su sequenza Curve5"}
    Vq3141_RitPiegatore_2_OFF               AT %MD500.3141 : DINT;         {DE:"vq3141 - variabile per memorizzare tempo su sequenza Curve5"}
    Vq3142_RitPiegatore_3_ON                AT %MD500.3142 : DINT;         {DE:"vq3142 - variabile per memorizzare tempo su sequenza Curve5"}
    Vq3143_RitPiegatore_3_OFF               AT %MD500.3143 : DINT;         {DE:"vq3143 - variabile per memorizzare tempo su sequenza Curve5"}
    Vq3144_RitPiegatore_4_ON                AT %MD500.3144 : DINT;         {DE:"vq3144 - variabile per memorizzare tempo su sequenza Curve5"}
    Vq3145_RitPiegatore_4_OFF               AT %MD500.3145 : DINT;         {DE:"vq3145 - variabile per memorizzare tempo su sequenza Curve5"}
    Vq3200_Time_Pattina_avanti              AT %MD500.3200 : DINT;         {DE:"vq3200 - tempo tra caricatore verso operatore e giu"}
    Vq3201_Time_SoffioPattina               AT %MD500.3201 : DINT;         {DE:"vq3201 - tempo soffi per lasciare la pattina"}
    Vq3202_Time_pinza_blocca_pattin         AT %MD500.3202 : DINT;         {DE:"vq3202 - tempo necessario a far avanzare la pinza blocca pattina sulladima"}
    Vq3203_Ritardo_PartenzaCuciPat          AT %MD500.3203 : DINT;         {DE:"vq3203 - dopo che la prima pinza ha bloccato la pattina, parto a cucire per la prima cucitura"}
    Vq3204_Ritardo_PiegaturaPat             AT %MD500.3204 : DINT;         {DE:"vq3204 - ritardo prima di piegare la pattina"}
    Vq3205_Ritardo_SecondaCuciPat           AT %MD500.3205 : DINT;         {DE:"vq3205 - ritardo la piegatura della pattina e la partenza della seconda cucitura"}
    Vq3500_PosizioneCaricRiposo             AT %MD500.3500 : DINT;         {DE:"vq3500 - posizione caricatore a riposo fuori ingombro"}
    Vq3501_PosizioneCaricCaricoTasca        AT %MD500.3501 : DINT;         {DE:"vq3501 - posizione caricatore carico tasca"}
    Vq3502_PosizioneCaricScaricoTasca       AT %MD500.3502 : DINT;         {DE:"vq3502 - posizione caricatore scarico tasca"}
    Vq3503_PosizioneCaricLiberaPinzaC1      AT %MD500.3503 : DINT;         {DE:"vq3503 - posizione caricatore dopo scarico per abbassare la pinza C1"}
    Vq3504_AppPosizioneCaricLiberaPinzaC1   AT %MD500.3504 : DINT;         {DE:"vq3504 - posizione caricatore dopo scarico per abbassare la pinza C1 calcolata in base alla velocità"}
    Vq3505_CoeffPosizioneCaricLiberaPinzaC1 AT %MD500.3505 : DINT;         {DE:"vq3505 - coefficente calcolo posizione caricatore dopo scarico per abbassare la pinza C1 calcolata in base alla velocità"}
    Vq3510_VelocitaCaricRiposo              AT %MD500.3510 : DINT;         {DE:"vq3510 - Velocità  caricatore a vuoto %"}
    Vq3511_VelocitaCaricLavoro              AT %MD500.3511 : DINT;         {DE:"vq3511 - Velocità  caricatore lavoro %"}
    Vq3512_VelocitaCaricTastiPieCar         AT %MD500.3512 : DINT;         {DE:"vq3512 - Velocità  caricatore quando lo sposto con i tasti piegatore e caricatore %"}
    Vq3513_VelCarAppoggio                   AT %MD500.3513 : DINT;         {DE:"vq3513"}
    Vq3520_PosizioneTraslScaricaC2          AT %MD500.3520 : DINT;         {DE:"vq3520 - posizione traslatore scarico C2"}
    Vq3521_PosizioneTraslAspCaricoTascaC1   AT %MD500.3521 : DINT;         {DE:"vq3521 - posizione traslatore aspetta carico tasca"}
    Vq3522_PosizioneTraslCaricoTascaC1      AT %MD500.3522 : DINT;         {DE:"vq3522 - posizione traslatore carico tasca su cucitrice 1"}
    Vq3523_PosizioneTraslAspScaricoC2       AT %MD500.3523 : DINT;         {DE:"vq3523 - posizione traslatore aspetta scarico su cucitrice 2"}
    Vq3524_AppPosInizio                     AT %MD500.3524 : DINT;         {DE:"vq3524 - appoggio"}
    Vq3525_PosizioneTraslAspScaricoC2_XL    AT %MD500.3525 : DINT;         {DE:"vq3525 - posizione traslatore aspetta scarico su cucitrice 2 quarto XL"}
    Vq3530_VelocitaTraslRiposo              AT %MD500.3530 : DINT;         {DE:"vq3530 - Velocità  traslatore a vuoto %"}
    Vq3531_VelocitaTraslLavoro              AT %MD500.3531 : DINT;         {DE:"vq3531 - Velocità  traslatore lavoro %"}
    Vq3535_PosAsseX_TaraturaPinzaAgo        AT %MD500.3535 : DINT;         {DE:"vq3535 - posizione asse X taratura pinza ago"}
    Vq3536_PosAsseY_TaraturaPinzaAgo        AT %MD500.3536 : DINT;         {DE:"vq3536 - posizione asse Y taratura pinza ago"}
    Vq3540_PuntiAvvioDxSx                   AT %MD500.3540 : DINT;         {DE:"vq3540 - numero punti avvicinamento scaricatore prima della fine cucitura"}
    Vq3550_PosAsseY_C2_OFF                  AT %MD500.3550 : DINT;         {DE:"vq3550 - posizione asse Y cucitrice 2 selezionata"}
    Vq3560_N_PuntiRottFiloC1                AT %MD500.3560 : DINT;         {DE:"vq3560 - punti impostati rottura filo"}
    Vq3561_ContPuntiRottFiloC1              AT %MD500.3561 : DINT;         {DE:"vq3561 - punti contati dalla molla rottura filo"}
    Vq3562_N_PuntiRottFiloC2                AT %MD500.3562 : DINT;         {DE:"vq3562 - punti impostati rottura filo"}
    Vq3563_ContPuntiRottFiloC2              AT %MD500.3563 : DINT;         {DE:"vq3563 - punti contati dalla molla rottura filo"}
    Vq3564_Debug                            AT %MD500.3564 : DINT;         {DE:"vq3564"}
    Vq3565_debug                            AT %MD500.3565 : DINT;         {DE:"vq3565"}
    Vq3566_debug                            AT %MD500.3566 : DINT;         {DE:"vq3566"}
    Vq3591_CNT_CicliAutomaticoUser          AT %MD500.3591 : DINT;         {DE:"vq3591 - conteggio cicli automatico azzerabile da utente            valore 0.001"}
    Vq3592_CNT_CicliAutomaticoVita          AT %MD500.3592 : DINT;         {DE:"vq3592 - conteggio cicli automatico vita macchina                valore 0.001"}
    Vq3593_CNT_CicliAutomaticoVitaX100K     AT %MD500.3593 : DINT;         {DE:"vq3593 - conteggio cicli automatico vita macchina x 100000        a 100000 di vq3592 incrementa valore 0.001"}
    Vq3596_ContPuntiSpolaC1                 AT %MD500.3596 : DINT;         {DE:"vq3596 - conteggio punti fatti"}
    Vq3597_ImpPuntiSpolaC1                  AT %MD500.3597 : DINT;         {DE:"vq3597 - conteggio punti da fare"}
    Vq3598_ContPuntiSpolaC2                 AT %MD500.3598 : DINT;         {DE:"vq3598 - conteggio punti fatti"}
    Vq3599_ImpPuntiSpolaC2                  AT %MD500.3599 : DINT;         {DE:"vq3599 - conteggio punti da fare"}
    GoAxPlcCaricErrCode                     AT %MD500.3600 : DINT;         {DE:"vq3600 - GoAx asse caricatore - ErrorCode"}
    GoAxPlcCariObj                          AT %MD500.3601 : DINT;         {DE:"vq3601 - GoAx asse caricatore - quota obbiettivo"}
    GoAxPlcCaricVel                         AT %MD500.3602 : DINT;         {DE:"vq3602 - GoAx asse caricatore - Velocita'"}
    GoAxPlcCaric                            AT %MD500.3603 : DINT;         {DE:"vq3603 - GoAx asse caricatore - Libera"}


    VdTmpCalc                               AT %ML600.1    : LREAL;        {DE:"vd1    - Usato per calcoli temporanei nel PLC"}
    VdTmpCalcT1                             AT %ML600.2    : LREAL;        {DE:"vd2    - Usato per calcoli temporanei nel PLC"}
    VdTmpCalcT2                             AT %ML600.3    : LREAL;        {DE:"vd3    - Usato per calcoli temporanei nel PLC"}
    VdTmpOP_T1                              AT %ML600.4    : LREAL;        {DE:"vd4    - Usato per calcoli temporanei nel PLC"}
    VdTmpOP_T2                              AT %ML600.5    : LREAL;        {DE:"vd5    - Usato per calcoli temporanei nel PLC"}
    VdTmpOP_T3                              AT %ML600.6    : LREAL;        {DE:"vd6    - Usato per calcoli temporanei nel PLC"}


    i1_Pulsanti_start                       AT %IX100.0    : BOOL;         {DE:"i1"}
    i2_C1_Pedana                            AT %IX100.1    : BOOL;         {DE:"i2"}
    i3_C1_PedanaPiegatore                   AT %IX100.2    : BOOL;         {DE:"i3"}
    i4_C1_FcZeroCrochet                     AT %IX100.3    : BOOL;         {DE:"i4"}
    i5_FcPinzaCaricoAlta                    AT %IX100.4    : BOOL;         {DE:"i5"}
    i6_FcMinCaricatore1                     AT %IX100.5    : BOOL;         {DE:"i6"}
    i7_FcPiegatore_AV                       AT %IX100.6    : BOOL;         {DE:"i7"}
    i8_FcPiegatore_DI                       AT %IX100.7    : BOOL;         {DE:"i8"}
    i9_FcPiegatoreBasso                     AT %IX100.8    : BOOL;         {DE:"i9"}
    i10_Piegatore_Salito                    AT %IX100.9    : BOOL;         {DE:"i10"}
    i11_FcLancia_DI                         AT %IX100.10   : BOOL;         {DE:"i11"}
    i12_Bilanciere_Alto                     AT %IX100.11   : BOOL;         {DE:"i12"}
    i13_Bilanciere_Basso                    AT %IX100.12   : BOOL;         {DE:"i13"}
    i14_Rinforzo_Attivo                     AT %IX100.13   : BOOL;         {DE:"i14"}
    i15_Rinforzo_ready                      AT %IX100.14   : BOOL;         {DE:"i15"}
    i16                                     AT %IX100.15   : BOOL;         {DE:"i16"}
    i17                                     AT %IX100.16   : BOOL;         {DE:"i17"}
    i18_C1_RotturaFilo                      AT %IX100.17   : BOOL;         {DE:"i18"}
    i19_C1_FcMinAsseX                       AT %IX100.18   : BOOL;         {DE:"i19"}
    i20_C1_FcMinAsseY                       AT %IX100.19   : BOOL;         {DE:"i20"}
    i21_Emg                                 AT %IX100.20   : BOOL;         {DE:"i21"}
    i22_C1_FcZeroAgo                        AT %IX100.21   : BOOL;         {DE:"i22"}
    i23_C1_PinzaIntBassa                    AT %IX100.22   : BOOL;         {DE:"i23"}
    i24_C1_PinzaEstAlta                     AT %IX100.23   : BOOL;         {DE:"i24"}
    i25_PulsResetFolder                     AT %IX100.24   : BOOL;         {DE:"i25"}
    i26_C1_PulsStopTesta                    AT %IX100.25   : BOOL;         {DE:"i26"}
    i27_C2_PulsStopTesta                    AT %IX100.26   : BOOL;         {DE:"i27"}
    i28                                     AT %IX100.27   : BOOL;         {DE:"i28"}
    i29                                     AT %IX100.28   : BOOL;         {DE:"i29"}
    i30                                     AT %IX100.29   : BOOL;         {DE:"i30"}
    i31_C1_ReadyAsseX                       AT %IX100.30   : BOOL;         {DE:"i31"}
    i32_C1_ReadyAsseY                       AT %IX100.31   : BOOL;         {DE:"i32"}
    i33_C2_Pedana                           AT %IX100.32   : BOOL;         {DE:"i33"}
    i34                                     AT %IX100.33   : BOOL;         {DE:"i34"}
    i35_Pressostato                         AT %IX100.34   : BOOL;         {DE:"i35"}
    i36                                     AT %IX100.35   : BOOL;         {DE:"i36"}
    i37_C2_FcZeroCrochet                    AT %IX100.36   : BOOL;         {DE:"i37"}
    i38_FcPinzaTraslAlta                    AT %IX100.37   : BOOL;         {DE:"i38"}
    i39_FcMinCaricatore2                    AT %IX100.38   : BOOL;         {DE:"i39"}
    i40                                     AT %IX100.39   : BOOL;         {DE:"i40"}
    i41_CarPat_Top_SUGIu                    AT %IX100.40   : BOOL;         {DE:"i41"}
    i42_CarPat_Middle_SUGIu                 AT %IX100.41   : BOOL;         {DE:"i42"}
    i43_CarPat_Bottom_SUGIu                 AT %IX100.42   : BOOL;         {DE:"i43"}
    i44_CarPat_Tastatore                    AT %IX100.43   : BOOL;         {DE:"i44"}
    i45_CarPat_Empty                        AT %IX100.44   : BOOL;         {DE:"i45"}
    i46_CarPat_BackPos                      AT %IX100.45   : BOOL;         {DE:"i46"}
    i47_C2_ReadyAsseX                       AT %IX100.46   : BOOL;         {DE:"i47"}
    i48_C2_ReadyAsseY                       AT %IX100.47   : BOOL;         {DE:"i48"}
    i49                                     AT %IX100.48   : BOOL;         {DE:"i49"}
    i50_C2_RotturaFilo                      AT %IX100.49   : BOOL;         {DE:"i50"}
    i51_C2_FcMinAsseX                       AT %IX100.50   : BOOL;         {DE:"i51"}
    i52_C2_FcMinAsseY                       AT %IX100.51   : BOOL;         {DE:"i52"}
    i53_C2_FcMaxAsseY                       AT %IX100.52   : BOOL;         {DE:"i53"}
    i54_C2_FcZeroAgo                        AT %IX100.53   : BOOL;         {DE:"i54"}
    i55_C2_FcPinzaIntBassa                  AT %IX100.54   : BOOL;         {DE:"i55"}
    i56                                     AT %IX100.55   : BOOL;         {DE:"i56"}
    i57                                     AT %IX100.56   : BOOL;         {DE:"i57"}
    i58_C2_PulsStopTesta                    AT %IX100.57   : BOOL;         {DE:"i58"}
    i59                                     AT %IX100.58   : BOOL;         {DE:"i59"}
    i60                                     AT %IX100.59   : BOOL;         {DE:"i60"}
    i61                                     AT %IX100.60   : BOOL;         {DE:"i61"}
    i62                                     AT %IX100.61   : BOOL;         {DE:"i62"}
    i63                                     AT %IX100.62   : BOOL;         {DE:"i63"}
    i64                                     AT %IX100.63   : BOOL;         {DE:"i64"}


    o1_Piegatore_1                          AT %QX200.0    : BOOL;         {DE:"o1"}
    o2_Piegatore_2                          AT %QX200.1    : BOOL;         {DE:"o2"}
    o3_Piegatore_3                          AT %QX200.2    : BOOL;         {DE:"o3"}
    o4_Piegatore_4                          AT %QX200.3    : BOOL;         {DE:"o4"}
    o5_Cambio_corpo                         AT %QX200.4    : BOOL;         {DE:"o5"}
    o6_Cambio_lama_front                    AT %QX200.5    : BOOL;         {DE:"o6"}
    o7_Cambio_lame_lateral                  AT %QX200.6    : BOOL;         {DE:"o7"}
    o8_Cambio_Lamelle_4_5                   AT %QX200.7    : BOOL;         {DE:"o8"}
    o9_Lancia_AD                            AT %QX200.8    : BOOL;         {DE:"o9"}
    o10_Piegatore_AD                        AT %QX200.9    : BOOL;         {DE:"o10"}
    o11_Piegatore_Su_Giu                    AT %QX200.10   : BOOL;         {DE:"o11"}
    o12_Bilanciere_Su_Giu                   AT %QX200.11   : BOOL;         {DE:"o12"}
    o13_Lancia_Cargo_Aperta                 AT %QX200.12   : BOOL;         {DE:"o13"}
    o14_C1_rasafilo                         AT %QX200.13   : BOOL;         {DE:"o14"}
    o15_EvAspiratore                        AT %QX200.14   : BOOL;         {DE:"o15"}
    o16_Lancia_Cargo_Chiusa                 AT %QX200.15   : BOOL;         {DE:"o16"}
    o17_C1_Piedino                          AT %QX200.16   : BOOL;         {DE:"o17"}
    o18_C1_Pinza_int                        AT %QX200.17   : BOOL;         {DE:"o18"}
    o19_C1_Pinza_est                        AT %QX200.18   : BOOL;         {DE:"o19"}
    o20_C1_Retrattile_AC                    AT %QX200.19   : BOOL;         {DE:"o20"}
    o21_C1_RaffreddamentoAgo                AT %QX200.20   : BOOL;         {DE:"o21"}
    o22                                     AT %QX200.21   : BOOL;         {DE:"o22"}
    o23_Lentezza_Tasca_AD                   AT %QX200.22   : BOOL;         {DE:"o23"}
    o24_Pinza_carico_Su_Giu                 AT %QX200.23   : BOOL;         {DE:"o24"}
    o25_C1_Cambio_Pinze                     AT %QX200.24   : BOOL;         {DE:"o25"}
    o26_C1_Scalino_Piedino                  AT %QX200.25   : BOOL;         {DE:"o26"}
    o27_C1_Ranocchia_retrat                 AT %QX200.26   : BOOL;         {DE:"o27"}
    o28                                     AT %QX200.27   : BOOL;         {DE:"o28"}
    o29                                     AT %QX200.28   : BOOL;         {DE:"o29"}
    o30                                     AT %QX200.29   : BOOL;         {DE:"o30"}
    o31_C1_bloccaFiloMagente                AT %QX200.30   : BOOL;         {DE:"o31"}
    o32_Enable_AssiXY_C1                    AT %QX200.31   : BOOL;         {DE:"o32"}
    o33_Valvolone                           AT %QX200.32   : BOOL;         {DE:"o33"}
    o34_CarPat_FrontBack                    AT %QX200.33   : BOOL;         {DE:"o34"}
    o35_CarPat_Aghi                         AT %QX200.34   : BOOL;         {DE:"o35"}
    o36_CarPat_SoffioAghi                   AT %QX200.35   : BOOL;         {DE:"o36"}
    o37_CarPat_SoffiPattina                 AT %QX200.36   : BOOL;         {DE:"o37"}
    o38_CarPat_DCGiu                        AT %QX200.37   : BOOL;         {DE:"o38"}
    o39_CarPat_DCSu                         AT %QX200.38   : BOOL;         {DE:"o39"}
    o40                                     AT %QX200.39   : BOOL;         {DE:"o40"}
    o41                                     AT %QX200.40   : BOOL;         {DE:"o41"}
    o42                                     AT %QX200.41   : BOOL;         {DE:"o42"}
    o43                                     AT %QX200.42   : BOOL;         {DE:"o43"}
    o44                                     AT %QX200.43   : BOOL;         {DE:"o44"}
    o45                                     AT %QX200.44   : BOOL;         {DE:"o45"}
    o46_C2_rasafilo                         AT %QX200.45   : BOOL;         {DE:"o46"}
    o47                                     AT %QX200.46   : BOOL;         {DE:"o47"}
    o48_Enable_AssiXY_C2                    AT %QX200.47   : BOOL;         {DE:"o48"}
    o49_C2_Piedino                          AT %QX200.48   : BOOL;         {DE:"o49"}
    o50_C2_Pinza_int                        AT %QX200.49   : BOOL;         {DE:"o50"}
    o51_PinzaPattina_1                      AT %QX200.50   : BOOL;         {DE:"o51"}
    o52_PinzaPattina_2                      AT %QX200.51   : BOOL;         {DE:"o52"}
    o53_C2_RaffreddamentoAgo                AT %QX200.52   : BOOL;         {DE:"o53"}
    o54_Scaric_dx_sx                        AT %QX200.53   : BOOL;         {DE:"o54"}
    o55                                     AT %QX200.54   : BOOL;         {DE:"o55"}
    o56_Pinza_tras_su_giu                   AT %QX200.55   : BOOL;         {DE:"o56"}
    o57_C2_Cambio_Pinze                     AT %QX200.56   : BOOL;         {DE:"o57"}
    o58_C2_Scalino_Piedino                  AT %QX200.57   : BOOL;         {DE:"o58"}
    o59_C2_Retrattile_AC                    AT %QX200.58   : BOOL;         {DE:"o59"}
    o60_Prima_barra                         AT %QX200.59   : BOOL;         {DE:"o60"}
    o61_Seconda_barra                       AT %QX200.60   : BOOL;         {DE:"o61"}
    o62                                     AT %QX200.61   : BOOL;         {DE:"o62"}
    o63_C2_bloccaFiloMagente                AT %QX200.62   : BOOL;         {DE:"o63"}
    o64                                     AT %QX200.63   : BOOL;         {DE:"o64"}

END_VAR

VAR_GLOBAL CONSTANT


    {G:"Application_Constant"}

    MAIN                                    : INT := 1001;
    TOOLS                                   : INT := 1002;
    MOD_PROG                                : INT := 1003;
    ON                                      : INT := 1;
    OFF                                     : INT := 0;
    AX_NULL                                 : INT := 0;
    C1_AsseX                                : INT := 1; { DE:"Cucitrice 1 - Asse X" }
    C1_AsseY                                : INT := 2; { DE:"Cucitrice 1 - Asse Y" }
    C1_AsseAGO                              : INT := 3; { DE:"Cucitrice 1 - Asse AGO" }
    C1_AsseCRO                              : INT := 4; { DE:"Cucitrice 1 - Asse CROCHET" }
    C1_AsseCAR                              : INT := 5; { DE:"Cucitrice 1 - Asse CARICATORE" }
    C2_AsseX                                : INT := 6; { DE:"Cucitrice 2 - Asse X" }
    C2_AsseY                                : INT := 7; { DE:"Cucitrice 2 - Asse Y" }
    C2_AsseAGO                              : INT := 8; { DE:"Cucitrice 2 - Asse AGO" }
    C2_AsseCRO                              : INT := 9; { DE:"Cucitrice 2 - Asse CROCHET" }
    C2_AsseCAR                              : INT := 10; { DE:"Cucitrice 2 - Asse CARICATORE" }
    C1_CHN                                  : INT := 1; { DE:"Cucitrice 1 - canale 1" }
    C2_CHN                                  : INT := 2; { DE:"Cucitrice 2 - canale 2" }
    SUP_CHN                                 : INT := 3; { DE:"Supervisore - canale 3" }
    CAM_MODULE                              : INT := 360; { DE:"Modulo per il calcolo delle camme" }
    C1_ID_CAM_FUORI_ING                     : INT := 1; { DE:"Id camma fuori ingombro ( senza anticipi )" }
    C1_MODE_FUORI_ING                       : INT := 101; { DE:"Mode camma fuori ingombro - uscita su VB" }
    C1_ID_CAM_AGO_ALTO                      : INT := 2; { DE:"Id camma per stop ago alto" }
    C1_MODE_AGO_ALTO                        : INT := 101; { DE:"Mode camma fuori ingombro - uscita su VB" }
    C1_ID_APRITENS                          : INT := 5; { DE:"Id camma apitensione" }
    C1_MODE_APRITENS                        : INT := 101; { DE:"Mode camma apritensione" }
    C1_VB_APRITENS                          : INT := 2; { DE:"VB apritensione" }
    C1_ENA_APRITENS                         : INT := 1001; { DE:"Indice VB abilitazione camma apritensione ( vb1001 )" }
    C1_ID_COLTELLO                          : INT := 6; { DE:"Id camma coltello" }
    C1_MODE_COLTELLO                        : INT := 1; { DE:"Mode camma coltello" }
    C1_OUT_COLTELLO                         : INT := 14; { DE:"DigOut coltello" }
    C1_ENA_COLTELLO                         : INT := 1001; { DE:"Indice VB abilitazione camma coltello ( vb1001 )" }
    C1_ID_BLOCCO_FILO_INI                   : INT := 7; { DE:"Id camma blocco filo durante primo giro" }
    C1_MODE_BLOCCO_FILO_INI                 : INT := 101; { DE:"Mode camma blocco filo durante primo giro" }
    C1_VB_BLOCCO_FILO_INI                   : INT := 13; { DE:"VB blocco filo durante primo giro" }
    C1_ENA_BLOCCO_FILO_INI                  : INT := 1039; { DE:"Indice VB abilitazione camma blocco filo durante primo giro ( vb1001 )" }
    C1_ID_BLOCCO_FILO_END                   : INT := 8; { DE:"Id camma blocco filo durante primo giro" }
    C1_MODE_BLOCCO_FILO_END                 : INT := 101; { DE:"Mode camma blocco filo durante primo giro" }
    C1_VB_BLOCCO_FILO_END                   : INT := 14; { DE:"VB blocco filo durante primo giro" }
    C1_ENA_BLOCCO_FILO_END                  : INT := 1001; { DE:"Indice VB abilitazione camma blocco filo durante primo giro ( vb1001 )" }
    C2_ID_CAM_FUORI_ING                     : INT := 11; { DE:"Id camma fuori ingombro ( senza anticipi )" }
    C2_MODE_FUORI_ING                       : INT := 101; { DE:"Mode camma fuori ingombro - uscita su VB" }
    C2_ID_CAM_AGO_ALTO                      : INT := 12; { DE:"Id camma per stop ago alto" }
    C2_MODE_AGO_ALTO                        : INT := 101; { DE:"Mode camma fuori ingombro - uscita su VB" }
    C2_ID_APRITENS                          : INT := 15; { DE:"Id camma apitensione" }
    C2_MODE_APRITENS                        : INT := 101; { DE:"Mode camma apritensione" }
    C2_VB_APRITENS                          : INT := 3; { DE:"DigOut apritensione" }
    C2_ENA_APRITENS                         : INT := 2001; { DE:"Indice VB abilitazione camma apritensione ( vb2001 )" }
    C2_ID_COLTELLO                          : INT := 16; { DE:"Id camma coltello" }
    C2_MODE_COLTELLO                        : INT := 1; { DE:"Mode camma coltello" }
    C2_OUT_COLTELLO                         : INT := 46; { DE:"DigOut coltello" }
    C2_ENA_COLTELLO                         : INT := 2001; { DE:"Indice VB abilitazione camma coltello ( vb2001 )" }
    C2_ID_BLOCCO_FILO_INI                   : INT := 17; { DE:"Id camma blocco filo durante primo giro" }
    C2_MODE_BLOCCO_FILO_INI                 : INT := 101; { DE:"Mode camma blocco filo durante primo giro" }
    C2_VB_BLOCCO_FILO_INI                   : INT := 15; { DE:"VB blocco filo durante primo giro" }
    C2_ENA_BLOCCO_FILO_INI                  : INT := 2039; { DE:"Indice VB abilitazione camma blocco filo durante primo giro ( vb1001 )" }
    C2_ID_BLOCCO_FILO_END                   : INT := 18; { DE:"Id camma blocco filo durante primo giro" }
    C2_MODE_BLOCCO_FILO_END                 : INT := 101; { DE:"Mode camma blocco filo durante primo giro" }
    C2_VB_BLOCCO_FILO_END                   : INT := 16; { DE:"VB blocco filo durante primo giro" }
    C2_ENA_BLOCCO_FILO_END                  : INT := 2001; { DE:"Indice VB abilitazione camma blocco filo durante primo giro ( vb1001 )" }
    ENABLE_CAMME_IDX                        : INT := 1;
    EnbCountRotturaFiloC1_IDX               : INT := 4092; { DE:"///  HMI utilizzato per abilitare il conteggio della rottura filo C1" }
    EnbCountRotturaFiloC2_IDX               : INT := 4093; { DE:"///  HMI utilizzato per abilitare  abilitare il conteggio della rottura filo C2" }
    ERR_CODE_CAMME_IDX                      : INT := 1;
    INIT_CAM_VQ_IDX                         : INT := 1;
    IO_CTL_CAM_VQ_IDX                       : INT := 10;
    ROLL_PLC_AGO_IDX                        : INT := 20;
    GOAX_PLC_AGO_IDX                        : INT := 22; { DE:"GOAX_PLC_AGO_IDX" }
    STOP_PLC_AGO_IDX                        : INT := 25; { DE:"STOP_PLC_AGO_IDX" }
    MOVE_PLC_AGO_IDX                        : INT := 28; { DE:"MOVE_PLC_AGO_IDX" }
    POS_AX_VQ_BASE_IDX                      : INT := 50; { DE:"Indice prima VQ posizione assi ( PLC )" }
    ContPuntiRottFiloC1_IDX                 : INT := 3561; { DE:"punti contati dalla molla rottura filo" }
    ContPuntiRottFiloC2_IDX                 : INT := 3563; { DE:"punti contati dalla molla rottura filo" }
    GOAX_PLC_CARIC_IDX                      : INT := 3600; { DE:"GOAX_PLC_CARIC_IDX" }
    VD_TMP_CALC_IDX                         : INT := 1;
    VD_TMP_CALC_T1_IDX                      : INT := 2;
    VD_TMP_CALC_T2_IDX                      : INT := 3;
    VD_TMP_OP_T1_IDX                        : INT := 4;
    VD_TMP_OP_T2_IDX                        : INT := 5;
    VD_TMP_OP_T3_IDX                        : INT := 6;
    VCD_RPM_AGO_IDX                         : INT := 1;
    VCD_TENSIONE_IDX                        : INT := 2;
    VCD11_OP1_IDX                           : INT := 11;
    VCD12_OP2_IDX                           : INT := 12;
    VCD13_OP3_IDX                           : INT := 13;
    VCD14_OP4_IDX                           : INT := 14;
    VCD15_OP5_IDX                           : INT := 15;
    VCD16_OP6_IDX                           : INT := 16;
    VCD17_OP7_IDX                           : INT := 17;
    VCD18_OP8_IDX                           : INT := 18;
    VCD19_OP9_IDX                           : INT := 19;
    VCD20_OP10_IDX                          : INT := 20;
    C1_PRG_NAME_IDX                         : INT := 1;
    C1_UDF_NAME_IDX                         : INT := 2;
    C2_PRG_NAME_IDX                         : INT := 11;
    C2_UDF_NAME_IDX                         : INT := 12;
    SUP_PRG_NAME_IDX                        : INT := 21;
    AO97_ValoreTensioneTesta1               : INT := 97; { DE:"valore scrittura analogica per elettrocalamita tensione testa 1 0-10000 mV" }
    AO98_ValoreTensioneTesta2               : INT := 98; { DE:"valore scrittura analogica per elettrocalamita blocca filo testa 1  0-10000 mV" }
    AO99_ValoreElettrocSotto                : INT := 99; { DE:"valore scrittura analogica per elettrocalamita 0-10000 mV" }
    AO100_ValoreElettrocSopra               : INT := 100; { DE:"valore scrittura analogica per elettrocalamita perno 0-10000 mV" }
    C1_NumPuntiRottFilo                     : DINT := 14000; { DE:"punti impostati rottura filo" }
    PLC_VN_TO_VB                            : DINT := 15; { DE:"Copia una vn su 16 vb consecutive" }
    PLC_READ_FORK_VAR                       : DINT := 28; { DE:"Lettura variabile fork" }
    PLC_WRITE_FORK_VAR                      : DINT := 29; { DE:"Scrittura variabile fork" }
    PLC_READ_AX_QUOTE                       : DINT := 70; { DE:"Lettura quota asse" }
    PLC_WRITE_AX_QUOTE                      : DINT := 71; { DE:"Set quota asse" }
    PLC_ROLLOVER_AX                         : DINT := 72; { DE:"Rollover asse" }
    PLC_MOVE_AX_TONDO                       : DINT := 73; { DE:"Movimento asse tondo" }
    PLC_MOVE_AX                             : DINT := 74; { DE:"Movimento asse" }
    PLC_STOP_AX                             : DINT := 75; { DE:"Stop asse" }
    PLC_CHG_QUO_OBJ_AX                      : DINT := 78; { DE:"Modifica quota obiettivo asse" }
    PLC_SET_EMERGENZA                       : DINT := 90; { DE:"Set emergenza" }
    PLC_ENABLE_FOLLOW                       : DINT := 105; { DE:"Abilitazione inseguimento" }
    PLC_DISABLE_FOLLOW                      : DINT := 106; { DE:"Disabilitazione inseguimento" }
    PLC_RESET_ALL_CAM                       : DINT := 120; { DE:"Reset di tutte le camme digitali" }
    PLC_INIT_ONE_CAM                        : DINT := 121; { DE:"Inizializzazione di una camma digitale" }
    PLC_DISABLE_ONE_CAM                     : DINT := 122; { DE:"Disabilitazione di una camma digitale" }
    PLC_ANTICIPO_CAM                        : DINT := 123; { DE:"Set anticipo di una camma digitale" }
    PLC_IO_CTL_CAM                          : DINT := 124; { DE:"IoCtl camma digitale" }
    PLC_AN_OUT_NUM                          : DINT := 140; { DE:"imposta uscita analogica" }
    PLC_AN_OUT_READ                         : DINT := 141; { DE:"legge uscita analogica" }
    PLC_VCD_TO_VD                           : DINT := 168; { DE:"copia una Vcd in una Vd" }
    PLC_VD_TO_VCD                           : DINT := 169; { DE:"copia una Vd in una Vcd" }
    PLC_SET_UDT_CMD                         : DINT := 191; { DE:"Set comandi udt e udf" }
    PLC_ENABLE_IRQ                          : DINT := 200; { DE:"Abilitazione interrupt" }
    PLC_DISABLE_IRQ                         : DINT := 201; { DE:"Disabilitazione interrupt" }
    PLC_ADD_FUN_IRQ                         : DINT := 202; { DE:"Inserimento di una funzione di interrupt" }
    PLC_REMOVE_FUN_IRQ                      : DINT := 203; { DE:"Rimozione di una funzione di interrupt" }
    PLC_READ_AX_PARAM                       : DINT := 210; { DE:"Lettura parametri assi" }
    PLC_WRITE_AX_PARAM                      : DINT := 211; { DE:"Scrittura parametri assi" }
    PLC_SPA_ACC_DEC                         : DINT := 216; { DE:"Calcolo spazio acc e dec" }
    PLC_FORCE_ZEROED                        : DINT := 218; { DE:"Forzatura assi azzerati" }
    PLC_CUCI_SET_PARAM                      : DINT := 280; { DE:"Impostazione parametri di cucitura" }
    PLC_CUCI_CMD                            : DINT := 281; { DE:"Comandi per la cucitrice" }
    PLC_ECAT_SDO_WR                         : DINT := 300; { DE:"Ethercat SDO write" }
    PLC_ECAT_SDO_RD                         : DINT := 301; { DE:"Ethercat SDO read" }
    PLC_ECAT_INFO                           : DINT := 302; { DE:"Ethercat info" }

END_VAR
]]>
			</lib>
			<lib name="DefCuci.PLL" fullXml="false" link="true">
				<![CDATA[(*
 *
 * MDPlc source file: DefCuci.PLL
 *
 * Date = "14/05/2024 08:42:47"
 *)


VAR_GLOBAL


    {G:"Application_Variables"}

    C1_VbEnableCamme           AT %MB300.1001 : BOOL;         {DE:"vb1001 - Comando di abilitazione camme della cucitrice 1"}
    C1_CmdInitCamme            AT %MB300.1002 : BOOL;         {DE:"vb1002 - Comando di inizializzazione delle camme digitali"}
    C1_CmdPiedinoSu            AT %MB300.1003 : BOOL;         {DE:"vb1003 - Comando per alzare il piedino"}
    C1_CmdPiedinoGiu           AT %MB300.1004 : BOOL;         {DE:"vb1004 - Comando per abbassare il piedino"}
    C1_CmdRiposiziona          AT %MB300.1005 : BOOL;         {DE:"vb1005 - Comando di riposizionamento sul punto di cucitura"}
    C1_CmdSimulaAva            AT %MB300.1006 : BOOL;         {DE:"vb1006 - Comando di Simula avanti"}
    C1_CmdSimulaInd            AT %MB300.1007 : BOOL;         {DE:"vb1007 - Comando di Simula indietro"}
    C1_CmdReloadTabellone      AT %MB300.1008 : BOOL;         {DE:"vb1008 - Comando di reload tabellone"}
    C1_CmdHoldRelease          AT %MB300.1009 : BOOL;         {DE:"vb1009 - Comando interno di Hold/Release"}
    C1_CmdHoldHMI              AT %MB300.1010 : BOOL;         {DE:"vb1010 - Comando Hold da HMI"}
    C1_CmdReleaseHMI           AT %MB300.1011 : BOOL;         {DE:"vb1011 - Comando Release da HMI"}
    C1_CmdSaveParam            AT %MB300.1012 : BOOL;         {DE:"vb1012 - Comando di save parametri"}
    C1_CmdGantryCrochet        AT %MB300.1013 : BOOL;         {DE:"vb1013 - Comando di aggancio inseguimento gantry crochet"}
    C1_CmdStdFollowCrochet     AT %MB300.1014 : BOOL;         {DE:"vb1014 - Comando di aggancio inseguimento standard crochet"}
    C1_CmdSganciaCrochet       AT %MB300.1015 : BOOL;         {DE:"vb1015 - Comando di sgancio  inseguimento crochet"}
    C1_CmdSetOffsetAgoTacca    AT %MB300.1016 : BOOL;         {DE:"vb1016 - Comando di set offset ago - tacca di zero"}
    C1_CmdGetOffsetAgoTacca    AT %MB300.1017 : BOOL;         {DE:"vb1017 - Comando di acquisizione offset ago - tacca di zero"}
    C1_CmdSbloccaAgo           AT %MB300.1018 : BOOL;         {DE:"vb1018 - Comando di sblocco dell'ago per movimento 'a mano'"}
    C1_CmdForceLoadProfilo     AT %MB300.1019 : BOOL;         {DE:"vb1019 - Comando di forzatura load profilo"}
    C1_CmdSimulaAvaNpoint      AT %MB300.1020 : BOOL;         {DE:"vb1020 - Comando di Simula avanti n-punti"}
    C1_CmdSimulaIndNpoint      AT %MB300.1021 : BOOL;         {DE:"vb1021 - Comando di Simula indietro n-punti"}
    C1_CmdSimulaAvaCont        AT %MB300.1022 : BOOL;         {DE:"vb1022 - Comando di Simula avanti n-punti"}
    C1_CmdSimulaIndCont        AT %MB300.1023 : BOOL;         {DE:"vb1023 - Comando di Simula indietro n-punti"}
    C1_CmdLoadParam            AT %MB300.1024 : BOOL;         {DE:"vb1024 - Comando di load del file UDF dei parametri"}
    C1_ReloadParam             AT %MB300.1025 : BOOL;         {DE:"vb1025 - Forza il ricalcolo dei parametri"}
    C1_ModoSimulaNpoint        AT %MB300.1026 : BOOL;         {DE:"vb1026 - Modo di Simulazione n-punti (0=tutti i punti  1=ultimo punto)"}
    C1_CmdSimulaPedaleVel      AT %MB300.1027 : BOOL;         {DE:"vb1027 - Pedale per alta velocita' simulazione continua"}
    C1_CuciBufRewind           AT %MB300.1028 : BOOL;         {DE:"vb1028 - Comando Rewind nella ripartenza"}
    C1_AgoFuoriIngombro        AT %MB300.1030 : BOOL;         {DE:"vb1030 - Flag segnalazione asse in camma fuori ingombro"}
    C1_AsseAgoFermo            AT %MB300.1031 : BOOL;         {DE:"vb1031 - Flag segnalazione asse ago fermo"}
    C1_AssiAzzerati            AT %MB300.1032 : BOOL;         {DE:"vb1032 - Flag segnalazione assi azzerati"}
    C1_VbFlgCuciOrMove         AT %MB300.1033 : BOOL;         {DE:"vb1033 - Flag FlgCuciOrMove ( 1=cuci  0=move )"}
    C1_CuciSimulaAuto          AT %MB300.1034 : BOOL;         {DE:"vb1034 - Esecuzione cucitura simulata per il CNC"}
    C1_CuciLastPoint           AT %MB300.1035 : BOOL;         {DE:"vb1035 - Esecuzione ultimo punto di cucitura"}
    C1_CuciLastPointEnaStop    AT %MB300.1036 : BOOL;         {DE:"vb1036 - Consenso stop su ago alto ( last point )"}
    C1_CammaStopAgoAlto        AT %MB300.1037 : BOOL;         {DE:"vb1037 - Camma per stop ago alto"}
    C1_VbFlgG280Running        AT %MB300.1038 : BOOL;         {DE:"vb1038 - Flag FlgG280Running"}
    C1_VbEnableCammeIni        AT %MB300.1039 : BOOL;         {DE:"vb1039 - Comando di abilitazione camme della cucitrice 1 start asse"}
    C1_CuciLastPointAxC        AT %MB300.1040 : BOOL;         {DE:"vb1040 - Last point: gestione hold asse C"}
    C1_VbFlgJtaskRunning       AT %MB300.1041 : BOOL;         {DE:"vb1041 - Flag JTask running"}
    C1_VbFlgJtaskLoopHold      AT %MB300.1042 : BOOL;         {DE:"vb1042 - Flag JTask loop hold"}
    C1_FinitoSimulazione       AT %MB300.1043 : BOOL;         {DE:"vb1043 - il comando Simula è arrivato all'ultimo punto"}
    C1_VbStEnIrqBit            AT %MB300.1850 : BOOL;         {DE:"vb1850 - Stato abilitazione IRQ"}
    C1_VbStEnMovBit            AT %MB300.1851 : BOOL;         {DE:"vb1851 - Stato abilitazione movimento cucitura"}
    C1_VbStDisAlarmBit         AT %MB300.1852 : BOOL;         {DE:"vb1852 - Stato generazione allarme ( 1=disab 0=enab )"}
    C1_VbStAlarmBit            AT %MB300.1853 : BOOL;         {DE:"vb1853 - Stato allarme cucitrice"}
    C1_VbStIrqBit              AT %MB300.1854 : BOOL;         {DE:"vb1854 - Stato IRQ cucitrice"}
    C1_VbStCamMovBit           AT %MB300.1855 : BOOL;         {DE:"vb1855 - Stato camma movimento"}
    C1_VbStSelEnc0Bit          AT %MB300.1856 : BOOL;         {DE:"vb1856 - Stato bit 0 selezione encoder"}
    C1_VbStSelEnc1Bit          AT %MB300.1857 : BOOL;         {DE:"vb1857 - Stato bit 1 selezione encoder"}
    C1_VbStAxMovBit            AT %MB300.1858 : BOOL;         {DE:"vb1858 - Stato asse in movimento"}
    C1_VbStBit9                AT %MB300.1859 : BOOL;         {DE:"vb1859 - Stato bit 9"}
    C1_VbStBit10               AT %MB300.1860 : BOOL;         {DE:"vb1860 - Stato bit 10"}
    C1_VbStBit11               AT %MB300.1861 : BOOL;         {DE:"vb1861 - Stato bit 11"}
    C1_VbStBit12               AT %MB300.1862 : BOOL;         {DE:"vb1862 - Stato bit 12"}
    C1_VbStBit13               AT %MB300.1863 : BOOL;         {DE:"vb1863 - Stato bit 13"}
    C1_VbStBit14               AT %MB300.1864 : BOOL;         {DE:"vb1864 - Stato bit 14"}
    C1_VbStBit15               AT %MB300.1865 : BOOL;         {DE:"vb1865 - Stato bit 15"}
    C1_VbStartCuci             AT %MB300.1951 : BOOL;         {DE:"vb1951"}
    C1_VbHoldCuci              AT %MB300.1952 : BOOL;         {DE:"vb1952"}
    C1_VbReleaseCuci           AT %MB300.1953 : BOOL;         {DE:"vb1953"}
    C1_VbEndCuci               AT %MB300.1954 : BOOL;         {DE:"vb1954"}
    C1_VbRunCuci               AT %MB300.1955 : BOOL;         {DE:"vb1955"}
    C1_VbRallCuci              AT %MB300.1956 : BOOL;         {DE:"vb1956"}
    C1_VbRasafCuci             AT %MB300.1957 : BOOL;         {DE:"vb1957"}
    C1_VbAgoAzzCuci            AT %MB300.1958 : BOOL;         {DE:"vb1958"}
    C1_VbCamMovCuci            AT %MB300.1959 : BOOL;         {DE:"vb1959"}
    C1_VbAxMovCuci             AT %MB300.1960 : BOOL;         {DE:"vb1960"}
    C1_VbLastPnt               AT %MB300.1961 : BOOL;         {DE:"vb1961"}
    C1_VbSuspendCuci           AT %MB300.1962 : BOOL;         {DE:"vb1962"}
    C1_VbCuciIsoActive         AT %MB300.1963 : BOOL;         {DE:"vb1963"}
    C1_VbCuciGoto              AT %MB300.1964 : BOOL;         {DE:"vb1964"}
    C2_VbEnableCamme           AT %MB300.2001 : BOOL;         {DE:"vb2001 - Comando di abilitazione camme della cucitrice 2"}
    C2_CmdInitCamme            AT %MB300.2002 : BOOL;         {DE:"vb2002 - Comando di inizializzazione delle camme digitali"}
    C2_CmdPiedinoSu            AT %MB300.2003 : BOOL;         {DE:"vb2003 - Comando per alzare il piedino"}
    C2_CmdPiedinoGiu           AT %MB300.2004 : BOOL;         {DE:"vb2004 - Comando per abbassare il piedino"}
    C2_CmdRiposiziona          AT %MB300.2005 : BOOL;         {DE:"vb2005 - Comando di riposizionamento sul punto di cucitura"}
    C2_CmdSimulaAva            AT %MB300.2006 : BOOL;         {DE:"vb2006 - Comando di Simula avanti"}
    C2_CmdSimulaInd            AT %MB300.2007 : BOOL;         {DE:"vb2007 - Comando di Simula indietro"}
    C2_CmdReloadTabellone      AT %MB300.2008 : BOOL;         {DE:"vb2008 - Comando di reload tabellone"}
    C2_CmdHoldRelease          AT %MB300.2009 : BOOL;         {DE:"vb2009 - Comando interno di Hold/Release"}
    C2_CmdHoldHMI              AT %MB300.2010 : BOOL;         {DE:"vb2010 - Comando Hold da HMI"}
    C2_CmdReleaseHMI           AT %MB300.2011 : BOOL;         {DE:"vb2011 - Comando Release da HMI"}
    C2_CmdSaveParam            AT %MB300.2012 : BOOL;         {DE:"vb2012 - Comando di save parametri"}
    C2_CmdGantryCrochet        AT %MB300.2013 : BOOL;         {DE:"vb2013 - Comando di aggancio inseguimento gantry crochet"}
    C2_CmdStdFollowCrochet     AT %MB300.2014 : BOOL;         {DE:"vb2014 - Comando di aggancio inseguimento standard crochet"}
    C2_CmdSganciaCrochet       AT %MB300.2015 : BOOL;         {DE:"vb2015 - Comando di sgancio  inseguimento crochet"}
    C2_CmdSetOffsetAgoTacca    AT %MB300.2016 : BOOL;         {DE:"vb2016 - Comando di set offset ago - tacca di zero"}
    C2_CmdGetOffsetAgoTacca    AT %MB300.2017 : BOOL;         {DE:"vb2017 - Comando di acquisizione offset ago - tacca di zero"}
    C2_CmdSbloccaAgo           AT %MB300.2018 : BOOL;         {DE:"vb2018 - Comando di sblocco dell'ago per movimento 'a mano'"}
    C2_CmdForceLoadProfilo     AT %MB300.2019 : BOOL;         {DE:"vb2019 - Comando di forzatura load profilo"}
    C2_CmdSimulaAvaNpoint      AT %MB300.2020 : BOOL;         {DE:"vb2020 - Comando di Simula avanti n-punti"}
    C2_CmdSimulaIndNpoint      AT %MB300.2021 : BOOL;         {DE:"vb2021 - Comando di Simula indietro n-punti"}
    C2_CmdSimulaAvaCont        AT %MB300.2022 : BOOL;         {DE:"vb2022 - Comando di Simula avanti n-punti"}
    C2_CmdSimulaIndCont        AT %MB300.2023 : BOOL;         {DE:"vb2023 - Comando di Simula indietro n-punti"}
    C2_CmdLoadParam            AT %MB300.2024 : BOOL;         {DE:"vb2024 - Comando di load del file UDF dei parametri"}
    C2_ReloadParam             AT %MB300.2025 : BOOL;         {DE:"vb2025 - Forza il ricalcolo dei parametri"}
    C2_ModoSimulaNpoint        AT %MB300.2026 : BOOL;         {DE:"vb2026 - Modo di Simulazione n-punti (0=tutti i punti  1=ultimo punto)"}
    C2_CmdSimulaPedaleVel      AT %MB300.2027 : BOOL;         {DE:"vb2027 - Pedale per alta velocita' simulazione continua"}
    C2_CuciBufRewind           AT %MB300.2028 : BOOL;         {DE:"vb2028 - Comando Rewind nella ripartenza"}
    C2_AgoFuoriIngombro        AT %MB300.2030 : BOOL;         {DE:"vb2030 - Flag segnalazione asse in camma fuori ingombro"}
    C2_AsseAgoFermo            AT %MB300.2031 : BOOL;         {DE:"vb2031 - Flag segnalazione asse ago fermo"}
    C2_AssiAzzerati            AT %MB300.2032 : BOOL;         {DE:"vb2032 - Flag segnalazione assi azzerati"}
    C2_VbFlgCuciOrMove         AT %MB300.2033 : BOOL;         {DE:"vb2033 - Flag FlgCuciOrMove ( 1=cuci  0=move )"}
    C2_CuciSimulaAuto          AT %MB300.2034 : BOOL;         {DE:"vb2034 - Esecuzione cucitura simulata per il CNC"}
    C2_CuciLastPoint           AT %MB300.2035 : BOOL;         {DE:"vb2035 - Esecuzione ultimo punto di cucitura"}
    C2_CuciLastPointEnaStop    AT %MB300.2036 : BOOL;         {DE:"vb2036 - Consenso stop su ago alto ( last point )"}
    C2_CammaStopAgoAlto        AT %MB300.2037 : BOOL;         {DE:"vb2037 - Camma per stop ago alto"}
    C2_VbFlgG280Running        AT %MB300.2038 : BOOL;         {DE:"vb2038 - Flag FlgG280Running"}
    C2_VbEnableCammeIni        AT %MB300.2039 : BOOL;         {DE:"vb2039 - Comando di abilitazione camme della cucitrice 2 start asse"}
    C2_CuciLastPointAxC        AT %MB300.2040 : BOOL;         {DE:"vb2040 - Last point: gestione hold asse C"}
    C2_VbFlgJtaskRunning       AT %MB300.2041 : BOOL;         {DE:"vb2041 - Flag JTask running"}
    C2_VbFlgJtaskLoopHold      AT %MB300.2042 : BOOL;         {DE:"vb2042 - Flag JTask loop hold"}
    C2_FinitoSimulazione       AT %MB300.2043 : BOOL;         {DE:"vb2043 - il comando Simula è arrivato all'ultimo punto"}
    C2_VbStEnIrqBit            AT %MB300.2850 : BOOL;         {DE:"vb2850 - Stato abilitazione IRQ"}
    C2_VbStEnMovBit            AT %MB300.2851 : BOOL;         {DE:"vb2851 - Stato abilitazione movimento cucitura"}
    C2_VbStDisAlarmBit         AT %MB300.2852 : BOOL;         {DE:"vb2852 - Stato generazione allarme ( 1=disab 0=enab )"}
    C2_VbStAlarmBit            AT %MB300.2853 : BOOL;         {DE:"vb2853 - Stato allarme cucitrice"}
    C2_VbStIrqBit              AT %MB300.2854 : BOOL;         {DE:"vb2854 - Stato IRQ cucitrice"}
    C2_VbStCamMovBit           AT %MB300.2855 : BOOL;         {DE:"vb2855 - Stato camma movimento"}
    C2_VbStSelEnc0Bit          AT %MB300.2856 : BOOL;         {DE:"vb2856 - Stato bit 0 selezione encoder"}
    C2_VbStSelEnc1Bit          AT %MB300.2857 : BOOL;         {DE:"vb2857 - Stato bit 1 selezione encoder"}
    C2_VbStAxMovBit            AT %MB300.2858 : BOOL;         {DE:"vb2858 - Stato asse in movimento"}
    C2_VbStBit9                AT %MB300.2859 : BOOL;         {DE:"vb2859 - Stato bit 9"}
    C2_VbStBit10               AT %MB300.2860 : BOOL;         {DE:"vb2860 - Stato bit 10"}
    C2_VbStBit11               AT %MB300.2861 : BOOL;         {DE:"vb2861 - Stato bit 11"}
    C2_VbStBit12               AT %MB300.2862 : BOOL;         {DE:"vb2862 - Stato bit 12"}
    C2_VbStBit13               AT %MB300.2863 : BOOL;         {DE:"vb2863 - Stato bit 13"}
    C2_VbStBit14               AT %MB300.2864 : BOOL;         {DE:"vb2864 - Stato bit 14"}
    C2_VbStBit15               AT %MB300.2865 : BOOL;         {DE:"vb2865 - Stato bit 15"}
    C2_VbStartCuci             AT %MB300.2951 : BOOL;         {DE:"vb2951"}
    C2_VbHoldCuci              AT %MB300.2952 : BOOL;         {DE:"vb2952"}
    C2_VbReleaseCuci           AT %MB300.2953 : BOOL;         {DE:"vb2953"}
    C2_VbEndCuci               AT %MB300.2954 : BOOL;         {DE:"vb2954"}
    C2_VbRunCuci               AT %MB300.2955 : BOOL;         {DE:"vb2955"}
    C2_VbRallCuci              AT %MB300.2956 : BOOL;         {DE:"vb2956"}
    C2_VbRasafCuci             AT %MB300.2957 : BOOL;         {DE:"vb2957"}
    C2_VbAgoAzzCuci            AT %MB300.2958 : BOOL;         {DE:"vb2958"}
    C2_VbCamMovCuci            AT %MB300.2959 : BOOL;         {DE:"vb2959"}
    C2_VbAxMovCuci             AT %MB300.2960 : BOOL;         {DE:"vb2960"}
    C2_VbLastPnt               AT %MB300.2961 : BOOL;         {DE:"vb2961"}
    C2_VbSuspendCuci           AT %MB300.2962 : BOOL;         {DE:"vb2962"}
    C2_VbCuciIsoActive         AT %MB300.2963 : BOOL;         {DE:"vb2963"}
    C2_VbCuciGoto              AT %MB300.2964 : BOOL;         {DE:"vb2964"}


    C1_TabParContext           AT %MW400.1001 : INT;          {DE:"vn1001 - Contesto pr UDF cucitrice"}
    C1_VelLavRPM               AT %MW400.1002 : INT;          {DE:"vn1002 - Velocita' di lavoro ( per FunPlc )"}
    C1_VelLimitRPM             AT %MW400.1003 : INT;          {DE:"vn1003 - Limitazione RPM Ago"}
    C1_PlcStatoAgo             AT %MW400.1004 : INT;          {DE:"vn1004 - Stato Ago ( macchina a stati PLC )"}
    C1_PlcStatoScartafilo      AT %MW400.1005 : INT;          {DE:"vn1005 - Stato scartafilo  ( macchina a stati PLC )"}
    C1_MovAxCStatus            AT %MW400.1006 : INT;          {DE:"vn1006 - Stato asse C ( macchina a stati PLC )"}
    C1_NextCode                AT %MW400.1010 : INT;          {DE:"vn1010 - Codice prossimo movimento simulato ( fun 281 cmd 48 e 49 )"}
    C1_StepNum                 AT %MW400.1011 : INT;          {DE:"vn1011 - Numero del passo da scrivere"}
    C1_MtxNum                  AT %MW400.1012 : INT;          {DE:"vn1012 - Numero della matrice di base"}
    mc_stati_C1CmdSimula       AT %MW400.1020 : INT;          {DE:"vn1020 - indice macchina stati per gestione piedino durante simula"}
    mc_stati_C1CmdSimulaCont   AT %MW400.1021 : INT;          {DE:"vn1021 - indice macchina stati per gestione piedino durante simula continuo"}
    C1_SDO_ErrCode             AT %MW400.1680 : INT;          {DE:"vn1680 - Error Code"}
    C1_SDO_Network             AT %MW400.1681 : INT;          {DE:"vn1681 - Rete"}
    C1_SDO_Node                AT %MW400.1682 : INT;          {DE:"vn1682 - Nodo"}
    C1_SDO_ObjIndex            AT %MW400.1683 : INT;          {DE:"vn1683 - Index"}
    C1_SDO_SubIndex            AT %MW400.1684 : INT;          {DE:"vn1684 - SubIndex"}
    C1_SDO_Size                AT %MW400.1685 : INT;          {DE:"vn1685 - Size"}
    C1_SDO_VqDataIdx           AT %MW400.1686 : INT;          {DE:"vn1686 - Vq data index"}
    C1_SetParamStatus          AT %MW400.1690 : INT;          {DE:"vn1690 - Status"}
    C1_SetParamErrCode         AT %MW400.1691 : INT;          {DE:"vn1691 - ErrorCode"}
    C1_SetParamCmd             AT %MW400.1692 : INT;          {DE:"vn1692 - Cmd  1=rd  2=wr"}
    C1_SetParamAxNum           AT %MW400.1693 : INT;          {DE:"vn1693 - Axis Number [1,2,...]"}
    C1_SetParamCat             AT %MW400.1694 : INT;          {DE:"vn1694 - Categoria di parametri"}
    C1_SetParamIdx             AT %MW400.1695 : INT;          {DE:"vn1695 - Indice del parametro"}
    C1_SetParamSize            AT %MW400.1696 : INT;          {DE:"vn1696 - Size del parametro [ 1=byte  2=word  4=long ]"}
    C1_BaseOpCode              AT %MW400.1901 : INT;          {DE:"vn1901 - Op code ( matrice di base )"}
    C1_VnErrCuci               AT %MW400.1951 : INT;          {DE:"vn1951 - Error code"}
    C1_VnStatusCuci            AT %MW400.1952 : INT;          {DE:"vn1952 - Vn status"}
    C1_VnZeroCuci              AT %MW400.1953 : INT;          {DE:"vn1953 - Contatore tacche di zero"}
    C1_VnPntRallCuci           AT %MW400.1954 : INT;          {DE:"vn1954 - Punti di rallentamento"}
    C1_VnOvdAxAgo              AT %MW400.1955 : INT;          {DE:"vn1955 - Override asse ago"}
    C1_VnRpmMaxAgo             AT %MW400.1956 : INT;          {DE:"vn1956 - Vel max ago"}
    C1_VnInfoPoint             AT %MW400.1957 : INT;          {DE:"vn1957 - Info point"}
    C2_TabParContext           AT %MW400.2001 : INT;          {DE:"vn2001 - Contesto pr UDF cucitrice"}
    C2_VelLavRPM               AT %MW400.2002 : INT;          {DE:"vn2002 - Velocita' di lavoro ( per FunPlc )"}
    C2_VelLimitRPM             AT %MW400.2003 : INT;          {DE:"vn2003 - Limitazione RPM Ago"}
    C2_PlcStatoAgo             AT %MW400.2004 : INT;          {DE:"vn2004 - Stato Ago ( macchina a stati PLC )"}
    C2_PlcStatoScartafilo      AT %MW400.2005 : INT;          {DE:"vn2005 - Stato scartafilo  ( macchina a stati PLC )"}
    C2_MovAxCStatus            AT %MW400.2006 : INT;          {DE:"vn2006 - Stato asse C ( macchina a stati PLC )"}
    C2_NextCode                AT %MW400.2010 : INT;          {DE:"vn2010 - Codice prossimo movimento simulato ( fun 281 cmd 48 e 49 )"}
    C2_StepNum                 AT %MW400.2011 : INT;          {DE:"vn2011 - Numero del passo da scrivere"}
    C2_MtxNum                  AT %MW400.2012 : INT;          {DE:"vn2012 - Numero della matrice di base"}
    mc_stati_C2CmdSimula       AT %MW400.2020 : INT;          {DE:"vn2020"}
    mc_stati_C2CmdSimulaCont   AT %MW400.2021 : INT;          {DE:"vn2021"}
    C2_BaseOpCode              AT %MW400.2901 : INT;          {DE:"vn2901 - Op code ( matrice di base )"}
    C2_VnErrCuci               AT %MW400.2951 : INT;          {DE:"vn2951 - Error code"}
    C2_VnStatusCuci            AT %MW400.2952 : INT;          {DE:"vn2952 - Vn status"}
    C2_VnZeroCuci              AT %MW400.2953 : INT;          {DE:"vn2953 - Contatore tacche di zero"}
    C2_VnPntRallCuci           AT %MW400.2954 : INT;          {DE:"vn2954 - Punti di rallentamento"}
    C2_VnOvdAxAgo              AT %MW400.2955 : INT;          {DE:"vn2955 - Override asse ago"}
    C2_VnRpmMaxAgo             AT %MW400.2956 : INT;          {DE:"vn2956 - Vel max ago"}
    C2_VnInfoPoint             AT %MW400.2957 : INT;          {DE:"vn2957 - Info point"}


    C1_VelRifAgo               AT %MD500.1001 : DINT;         {DE:"vq1001 - Velocita' riferimento asse ago"}
    C1_ImpRifAgo               AT %MD500.1002 : DINT;         {DE:"vq1002 - Impulsi riferimento asse ago"}
    C1_MmRifAgo                AT %MD500.1003 : DINT;         {DE:"vq1003 - Mm riferimento asse ago"}
    C1_PtIni                   AT %MD500.1004 : DINT;         {DE:"vq1004 - Punti iniziali"}
    C1_RpmIni                  AT %MD500.1005 : DINT;         {DE:"vq1005 - RPM punti iniziali"}
    C1_PtRall                  AT %MD500.1006 : DINT;         {DE:"vq1006 - Punti finali"}
    C1_RpmRall                 AT %MD500.1007 : DINT;         {DE:"vq1007 - RPM punti finali"}
    C1_VelMaxAgoRPM            AT %MD500.1008 : DINT;         {DE:"vq1008 - Vel max RPM AGO"}
    C1_CntApritens             AT %MD500.1009 : DINT;         {DE:"vq1009 - Contatore impulsi uscita apritensione"}
    C1_CntColtello             AT %MD500.1010 : DINT;         {DE:"vq1010 - Contatore impulsi uscita coltello"}
    C1_SimulaNumPoint          AT %MD500.1011 : DINT;         {DE:"vq1011 - Numero di punti simulazione"}
    C1_SimulaNumPointVel       AT %MD500.1012 : DINT;         {DE:"vq1012 - Vel [%] simulazione npoint"}
    C1_SimulaNumPointMsk       AT %MD500.1013 : DINT;         {DE:"vq1013 - Maschera simulazione npoint"}
    C1_SimulaContVbIdx         AT %MD500.1015 : DINT;         {DE:"vq1015 - Indice Vb"}
    C1_SimulaContVel1          AT %MD500.1016 : DINT;         {DE:"vq1016 - Vel [%] simulazione continua"}
    C1_SimulaContVel2          AT %MD500.1017 : DINT;         {DE:"vq1017 - Vel [%] simulazione continua"}
    C1_SimulaContVel3          AT %MD500.1018 : DINT;         {DE:"vq1018 - Vel [%] simulazione continua"}
    C1_SimulaContPt12          AT %MD500.1019 : DINT;         {DE:"vq1019 - N. punti cambio da Vel1 a Vel2"}
    C1_SimulaContPt23          AT %MD500.1020 : DINT;         {DE:"vq1020 - N. punti cambio da Vel2 a Vel3"}
    C1_SimulaContVbPedale      AT %MD500.1021 : DINT;         {DE:"vq1021 - Indice VB pedale per alta velocita'"}
    C1_SimulaContVelPedale     AT %MD500.1022 : DINT;         {DE:"vq1022 - Vel pedale alta velocita'[%] simulazione continua"}
    C1_FirstPtContext          AT %MD500.1025 : DINT;         {DE:"vq1025 - Contesto UDF per calcolo primo punto"}
    C1_FirstPtValid            AT %MD500.1026 : DINT;         {DE:"vq1026 - Flag primo punto valido"}
    C1_FirstPt_X               AT %MD500.1027 : DINT;         {DE:"vq1027 - Coordinata X del primo punto"}
    C1_FirstPt_Y               AT %MD500.1028 : DINT;         {DE:"vq1028 - Coordinata Y del primo punto"}
    C1_FirstPt_C               AT %MD500.1029 : DINT;         {DE:"vq1029 - Coordinata C iniziale"}
    C1_GantryErrAct            AT %MD500.1030 : DINT;         {DE:"vq1030 - Errore istantaneo"}
    C1_GantryErrMax            AT %MD500.1031 : DINT;         {DE:"vq1031 - Errore massimo"}
    C1_GantryErrReset          AT %MD500.1032 : DINT;         {DE:"vq1032 - Reset errore massimo"}
    C1_CalcBufContext          AT %MD500.1035 : DINT;         {DE:"vq1035 - Contesto ( dato di input )"}
    C1_CalcBufErrCode          AT %MD500.1036 : DINT;         {DE:"vq1036 - Codice di errore"}
    C1_CalcBufErrStepNum       AT %MD500.1037 : DINT;         {DE:"vq1037 - N. passo UDF dove e' avventuto l'errore"}
    C1_CalcBufErrPar           AT %MD500.1038 : DINT;         {DE:"vq1038 - Parametro aggiuntivo dell'errore"}
    C1_WarningFlg              AT %MD500.1040 : DINT;         {DE:"vq1040 - Flag Warning"}
    C1_WarningAntXMm           AT %MD500.1041 : DINT;         {DE:"vq1041 - Mm per il calcolo dell'anticipo  X"}
    C1_WarningAntXRpm          AT %MD500.1042 : DINT;         {DE:"vq1042 - RPM per il calcolo dell'anticipo X"}
    C1_WarningAntXPassoUdf     AT %MD500.1043 : DINT;         {DE:"vq1043 - Passo UDF per il calcolo dell'anticipo X"}
    C1_WarningAntYMm           AT %MD500.1044 : DINT;         {DE:"vq1044 - Mm per il calcolo dell'anticipo  Y"}
    C1_WarningAntYRpm          AT %MD500.1045 : DINT;         {DE:"vq1045 - RPM per il calcolo dell'anticipo Y"}
    C1_WarningAntYPassoUdf     AT %MD500.1046 : DINT;         {DE:"vq1046 - Passo UDF per il calcolo dell'anticipo Y"}
    C1_WarningFreqXMm          AT %MD500.1047 : DINT;         {DE:"vq1047 - Mm per il calcolo delle frequenze X"}
    C1_WarningFreqXRpm         AT %MD500.1048 : DINT;         {DE:"vq1048 - RPM per il calcolo delle frequenze X"}
    C1_WarningFreqXPassoUdf    AT %MD500.1049 : DINT;         {DE:"vq1049 - Passo UDF per il calcolo delle frequenze X"}
    C1_WarningFreqYMm          AT %MD500.1050 : DINT;         {DE:"vq1050 - Mm per il calcolo delle frequenze Y"}
    C1_WarningFreqYRpm         AT %MD500.1051 : DINT;         {DE:"vq1051 - RPM per il calcolo delle frequenze Y"}
    C1_WarningFreqYPassoUdf    AT %MD500.1052 : DINT;         {DE:"vq1052 - Passo UDF per il calcolo delle frequenze Y"}
    C1_CntBloccoFiloINI        AT %MD500.1053 : DINT;         {DE:"vq1053 - Contatore impulsi uscita BloccoFiloINI"}
    C1_CntBloccoFiloEND        AT %MD500.1054 : DINT;         {DE:"vq1054 - Contatore impulsi uscita BloccoFiloEND"}
    C1_Fun74_RetCode           AT %MD500.1060 : DINT;         {DE:"vq1060 - RetCode"}
    C1_Fun74_QuoObj            AT %MD500.1061 : DINT;         {DE:"vq1061 - Quota obiettivo"}
    C1_Fun74_VelObj            AT %MD500.1062 : DINT;         {DE:"vq1062 - Velocita'"}
    C1_Fun74_Future            AT %MD500.1063 : DINT;         {DE:"vq1063 - Future"}
    C1_Fun74_Acc               AT %MD500.1063 : DINT;         {DE:"vq1063 - Accelerazione ( polinomio grado 5 )"}
    C1_Fun74_Tmov              AT %MD500.1064 : DINT;         {DE:"vq1064 - Tempo di movimento ( polinomio grado 5 )"}
    C1_Fun74_Offs              AT %MD500.1065 : DINT;         {DE:"vq1065 - Offset anticipo start ( polinomio grado 5 )"}
    C1_FaseAxAgo               AT %MD500.1070 : DINT;         {DE:"vq1070 - Fase asse ago"}
    C1_FaseAxC                 AT %MD500.1071 : DINT;         {DE:"vq1071 - Fase asse C"}
    C1_CmdQuoAbsRet            AT %MD500.1075 : DINT;         {DE:"vq1075 - RetCode"}
    C1_CmdQuoAbsX              AT %MD500.1076 : DINT;         {DE:"vq1076 - QuoAbs X"}
    C1_CmdQuoAbsY              AT %MD500.1077 : DINT;         {DE:"vq1077 - QuoAbs Y"}
    C1_CmdQuoAbsC              AT %MD500.1078 : DINT;         {DE:"vq1078 - QuoAbs C"}
    C1_RpmAgoInProfilo         AT %MD500.1100 : DINT;         {DE:"vq1100 - Rpm ago impostati da istruzione del profile ( Vcd1 )"}
    C1_TensioneInProfilo       AT %MD500.1101 : DINT;         {DE:"vq1101 - tensione impostata da istruzione del profile ( Vcd2 )"}
    C1_VelRiduzioneRPM         AT %MD500.1110 : DINT;         {DE:"vq1110 - Ulteriore limite RPM Ago ( #M200710_1GF# )"}
    C1_CmdMoveAxC              AT %MD500.1120 : DINT;         {DE:"vq1120 - Comando di movimento asse C"}
    C1_QuoObjAxC               AT %MD500.1121 : DINT;         {DE:"vq1121 - Quota obiettivo asse C"}
    C1_NumPtMoveAxC            AT %MD500.1122 : DINT;         {DE:"vq1122 - Punti di cucitura - movimento asse C"}
    C1_RpmMoveAxC              AT %MD500.1123 : DINT;         {DE:"vq1123 - Rpm ago durante il movimento dell'asse C"}
    C1_IrqNumMoveAxC           AT %MD500.1124 : DINT;         {DE:"vq1124 - IrqNumber interpretazione movimento dell'asse C"}
    C1_IrqCnt                  AT %MD500.1127 : DINT;         {DE:"vq1127 - Contatore Irq ( Fun 281 cmd 63 )"}
    C1_MovePlcAxCErrCode       AT %MD500.1130 : DINT;         {DE:"vq1130 - Mov. asse C - ErrorCode"}
    C1_MovePlcAxCQuoObj        AT %MD500.1131 : DINT;         {DE:"vq1131 - Mov. asse C - Quota obiettivo"}
    C1_MovePlcAxCVel           AT %MD500.1132 : DINT;         {DE:"vq1132 - Mov. asse C - Velocita'"}
    C1_MovePlcAxCAcc           AT %MD500.1133 : DINT;         {DE:"vq1133 - Mov. asse C - Accelerazione"}
    C1_MovePlcAxCTime          AT %MD500.1134 : DINT;         {DE:"vq1134 - Mov. asse C - Tempo di movimento"}
    C1_MovePlcAxCAnt           AT %MD500.1135 : DINT;         {DE:"vq1135 - Mov. asse C - Anticipo"}
    C1_InfoCntPunti            AT %MD500.1651 : DINT;         {DE:"vq1651 - Contatore punti di cucitura"}
    C1_InfoAnticipoMm          AT %MD500.1652 : DINT;         {DE:"vq1652 - Mm per il calcolo dell'anticipo"}
    C1_InfoAnticipoRpm         AT %MD500.1653 : DINT;         {DE:"vq1653 - RPM per il calcolo dell'anticipo"}
    C1_InfoAnticipoPassoUdf    AT %MD500.1654 : DINT;         {DE:"vq1654 - Passo UDF per il calcolo dell'anticipo"}
    C1_InfoFreqXMm             AT %MD500.1655 : DINT;         {DE:"vq1655 - Mm per il calcolo delle frequenze X"}
    C1_InfoFreqXRpm            AT %MD500.1656 : DINT;         {DE:"vq1656 - RPM per il calcolo delle frequenze X"}
    C1_InfoFreqXPassoUdf       AT %MD500.1657 : DINT;         {DE:"vq1657 - Passo UDF per il calcolo delle frequenze X"}
    C1_InfoFreqYMm             AT %MD500.1658 : DINT;         {DE:"vq1658 - Mm per il calcolo delle frequenze Y"}
    C1_InfoFreqYRpm            AT %MD500.1659 : DINT;         {DE:"vq1659 - RPM per il calcolo delle frequenze Y"}
    C1_InfoFreqYPassoUdf       AT %MD500.1660 : DINT;         {DE:"vq1660 - Passo UDF per il calcolo delle frequenze Y"}
    C1_SDO_VqRwData            AT %MD500.1690 : DINT;         {DE:"vq1690 - Vq dato letto o da scrivere"}
    C1_SogliaStart             AT %MD500.1701 : DINT;         {DE:"vq1701 - Soglia start movimento [gradi]"}
    C1_SogliaStop              AT %MD500.1702 : DINT;         {DE:"vq1702 - Soglia stop  movimento [gradi]"}
    C1_AgoAlto                 AT %MD500.1703 : DINT;         {DE:"vq1703 - Ago alto [gradi]"}
    C1_StartApriTens           AT %MD500.1704 : DINT;         {DE:"vq1704 - Start camma apritensione [gradi]"}
    C1_StopApriTens            AT %MD500.1705 : DINT;         {DE:"vq1705 - Stop  camma apritensione [gradi]"}
    C1_StartColtello           AT %MD500.1706 : DINT;         {DE:"vq1706 - Start camma coltello [gradi]"}
    C1_StopColtello            AT %MD500.1707 : DINT;         {DE:"vq1707 - Stop  camma coltello [gradi]"}
    C1_TSalitaPiedino          AT %MD500.1708 : DINT;         {DE:"vq1708 - Tempo salita piedino [s]"}
    C1_TDiscesaPiedino         AT %MD500.1709 : DINT;         {DE:"vq1709 - Tempo discesa piedino [s]"}
    C1_ParVelLavRPM            AT %MD500.1710 : DINT;         {DE:"vq1710 - Vel. lavoro ago [RPM]"}
    C1_ParPuntiVelIni          AT %MD500.1711 : DINT;         {DE:"vq1711 - Punti iniziali (no fix3)"}
    C1_ParVelIniRPM            AT %MD500.1712 : DINT;         {DE:"vq1712 - Vel iniziale ago [RPM]"}
    C1_ParPuntiVelRall         AT %MD500.1713 : DINT;         {DE:"vq1713 - Punti rallentamento (no fix3)"}
    C1_ParVelRallRPM           AT %MD500.1714 : DINT;         {DE:"vq1714 - Vel rallentamento ago [RPM]"}
    C1_StopAgo                 AT %MD500.1715 : DINT;         {DE:"vq1715 - Quota stop dell'ago (prima del movimento ad ago alto)"}
    C1_OffsetAgoTacca          AT %MD500.1716 : DINT;         {DE:"vq1716 - Offset di fase tran la quota dell'ago e la tacca di zero"}
    C1_Par_FeedG0Reset         AT %MD500.1717 : DINT;         {DE:"vq1717 - Feed nei movimenti G0 per azzeramento o reset [mm/min] fix3"}
    C1_StartBloccoFiloINI      AT %MD500.1718 : DINT;         {DE:"vq1718 - Start camma blocco filo inizio cucitura [gradi]"}
    C1_StopBloccoFiloINI       AT %MD500.1719 : DINT;         {DE:"vq1719 - Stop camma blocco filo inizio cucitura [gradi]"}
    C1_StartBloccoFiloEND      AT %MD500.1720 : DINT;         {DE:"vq1720 - Start camma blocco filo fine cucitura [gradi]"}
    C1_StopBloccoFiloEND       AT %MD500.1721 : DINT;         {DE:"vq1721 - Stop camma blocco filo fine cucitura [gradi]"}
    C1_ParVelRotazione         AT %MD500.1722 : DINT;         {DE:"vq1722 - Velocita' asse C rotazione [%] fix3 movimento iniziale"}
    C1_Par_23                  AT %MD500.1723 : DINT;         {DE:"vq1723"}
    C1_Par_24                  AT %MD500.1724 : DINT;         {DE:"vq1724"}
    C1_Par_25                  AT %MD500.1725 : DINT;         {DE:"vq1725"}
    C1_Par_26                  AT %MD500.1726 : DINT;         {DE:"vq1726"}
    C1_Par_27                  AT %MD500.1727 : DINT;         {DE:"vq1727"}
    C1_Par_28                  AT %MD500.1728 : DINT;         {DE:"vq1728"}
    C1_Par_29                  AT %MD500.1729 : DINT;         {DE:"vq1729"}
    C1_Par_30                  AT %MD500.1730 : DINT;         {DE:"vq1730"}
    C1_Par_31                  AT %MD500.1731 : DINT;         {DE:"vq1731"}
    C1_Par_32                  AT %MD500.1732 : DINT;         {DE:"vq1732"}
    C1_Par_33                  AT %MD500.1733 : DINT;         {DE:"vq1733"}
    C1_Par_34                  AT %MD500.1734 : DINT;         {DE:"vq1734"}
    C1_Par_35                  AT %MD500.1735 : DINT;         {DE:"vq1735"}
    C1_Par_36                  AT %MD500.1736 : DINT;         {DE:"vq1736"}
    C1_Par_37                  AT %MD500.1737 : DINT;         {DE:"vq1737"}
    C1_Par_38                  AT %MD500.1738 : DINT;         {DE:"vq1738"}
    C1_Par_39                  AT %MD500.1739 : DINT;         {DE:"vq1739"}
    C1_Par_40                  AT %MD500.1740 : DINT;         {DE:"vq1740"}
    C1_TabSpostamentoMm        AT %MD500.1851 : DINT;         {DE:"vq1851 - Spostamento [mm]"}
    C1_TabVelAgoRPM            AT %MD500.1852 : DINT;         {DE:"vq1852 - Vel. ago [RPM]"}
    C1_AnticipoX               AT %MD500.1853 : DINT;         {DE:"vq1853 - Anticipo start stop X [gradi]"}
    C1_AnticipoY               AT %MD500.1854 : DINT;         {DE:"vq1854 - Anticipo start stop Y [gradi]"}
    C1_FrqLavX                 AT %MD500.1855 : DINT;         {DE:"vq1855 - Frequenza di lavoro X [KHz]"}
    C1_StpAccX                 AT %MD500.1856 : DINT;         {DE:"vq1856 - Step di accelerazione X"}
    C1_FrqAccX                 AT %MD500.1857 : DINT;         {DE:"vq1857 - Frequenza accelerazione X [KHz]"}
    C1_StpDecX                 AT %MD500.1858 : DINT;         {DE:"vq1858 - Step di decelerazione X"}
    C1_FrqDecX                 AT %MD500.1859 : DINT;         {DE:"vq1859 - Frequenza decelerazione X [KHz]"}
    C1_FrqLavY                 AT %MD500.1860 : DINT;         {DE:"vq1860 - Frequenza di lavoro Y [KHz]"}
    C1_StpAccY                 AT %MD500.1861 : DINT;         {DE:"vq1861 - Step di accelerazione Y"}
    C1_FrqAccY                 AT %MD500.1862 : DINT;         {DE:"vq1862 - Frequenza accelerazione Y [KHz]"}
    C1_StpDecY                 AT %MD500.1863 : DINT;         {DE:"vq1863 - Step di decelerazione Y"}
    C1_FrqDecY                 AT %MD500.1864 : DINT;         {DE:"vq1864 - Frequenza decelerazione Y [KHz]"}
    C1_BaseParam1              AT %MD500.1901 : DINT;         {DE:"vq1901 - Parametro 1"}
    C1_BaseParam2              AT %MD500.1902 : DINT;         {DE:"vq1902 - Parametro 2"}
    C1_QuoHomeX                AT %MD500.1911 : DINT;         {DE:"vq1911 - Quota Home X"}
    C1_QuoHomeY                AT %MD500.1912 : DINT;         {DE:"vq1912 - Quota Home Y"}
    C1_UdfVelLavRPM            AT %MD500.1913 : DINT;         {DE:"vq1913 - Vel lavoro ago [RPM]"}
    C1_UdfPuntiVelIni          AT %MD500.1914 : DINT;         {DE:"vq1914 - Punti iniziali (no fix3)"}
    C1_UdfVelIniRPM            AT %MD500.1915 : DINT;         {DE:"vq1915 - Vel iniziale ago [RPM]"}
    C1_UdfPuntiVelRall         AT %MD500.1916 : DINT;         {DE:"vq1916 - Punti rallentamento (no fix3)"}
    C1_UdfVelRallRPM           AT %MD500.1917 : DINT;         {DE:"vq1917 - Vel rallentamento ago [RPM]"}
    C1_Udf_FeedG0              AT %MD500.1918 : DINT;         {DE:"vq1918 - Feed nei movimenti G0 [mm/min] fix3"}
    C1_Udf_ValTensione         AT %MD500.1919 : DINT;         {DE:"vq1919 - Valore Tensione Testa 1"}
    C1_Udf_20                  AT %MD500.1920 : DINT;         {DE:"vq1920"}
    C1_Udf_ValEletSopra        AT %MD500.1921 : DINT;         {DE:"vq1921 - Valore Uscita magnete Sopra"}
    C1_Udf_ValEletSotto        AT %MD500.1922 : DINT;         {DE:"vq1922 - Valore Uscita magnete Sotto"}
    C1_Udf_VelCaric            AT %MD500.1923 : DINT;         {DE:"vq1923"}
    C1_Udf_24                  AT %MD500.1924 : DINT;         {DE:"vq1924"}
    C1_Udf_25                  AT %MD500.1925 : DINT;         {DE:"vq1925"}
    C1_Udf_26                  AT %MD500.1926 : DINT;         {DE:"vq1926"}
    C1_Udf_27                  AT %MD500.1927 : DINT;         {DE:"vq1927"}
    C1_Udf_28                  AT %MD500.1928 : DINT;         {DE:"vq1928"}
    C1_Udf_29                  AT %MD500.1929 : DINT;         {DE:"vq1929"}
    C1_Udf_30                  AT %MD500.1930 : DINT;         {DE:"vq1930"}
    C1_VqTotPntCuci            AT %MD500.1951 : DINT;         {DE:"vq1951 - Punti totali cucitura"}
    C1_VqActPntCuci            AT %MD500.1952 : DINT;         {DE:"vq1952 - Punto corrente cucitura"}
    C1_VqEncImpCuci            AT %MD500.1953 : DINT;         {DE:"vq1953 - Lettura encoder ago [imp]"}
    C1_VqEncMmCuci             AT %MD500.1954 : DINT;         {DE:"vq1954 - Lettura encoder ago [mm]"}
    C1_VqRpmAgoCuci            AT %MD500.1955 : DINT;         {DE:"vq1955 - Velocita' ago [RPM]"}
    C1_VqActStartCuci          AT %MD500.1956 : DINT;         {DE:"vq1956 - Lettura quota start [gradi] (con anticipo)"}
    C1_VqActStopCuci           AT %MD500.1957 : DINT;         {DE:"vq1957 - Lettura quota stop  [gradi] (con anticipo)"}
    C1_VqAgoStartCuci          AT %MD500.1958 : DINT;         {DE:"vq1958 - Lettura hw quota start [gradi]"}
    C1_VqAgoStopCuci           AT %MD500.1959 : DINT;         {DE:"vq1959 - Lettura hw quota stop  [gradi]"}
    C1_VqTotParzPnt            AT %MD500.1960 : DINT;         {DE:"vq1960 - N. punti cucitura parziale"}
    C1_VqActParzPnt            AT %MD500.1961 : DINT;         {DE:"vq1961 - Punto corrente cucitura parziale"}
    C1_VelFeed                 AT %MD500.1962 : DINT;         {DE:"vq1962 - Velocità esecuzione Feed"}
    C2_VelRifAgo               AT %MD500.2001 : DINT;         {DE:"vq2001 - Velocita' riferimento asse ago"}
    C2_ImpRifAgo               AT %MD500.2002 : DINT;         {DE:"vq2002 - Impulsi riferimento asse ago"}
    C2_MmRifAgo                AT %MD500.2003 : DINT;         {DE:"vq2003 - Mm riferimento asse ago"}
    C2_PtIni                   AT %MD500.2004 : DINT;         {DE:"vq2004 - Punti iniziali"}
    C2_RpmIni                  AT %MD500.2005 : DINT;         {DE:"vq2005 - RPM punti iniziali"}
    C2_PtRall                  AT %MD500.2006 : DINT;         {DE:"vq2006 - Punti finali"}
    C2_RpmRall                 AT %MD500.2007 : DINT;         {DE:"vq2007 - RPM punti finali"}
    C2_VelMaxAgoRPM            AT %MD500.2008 : DINT;         {DE:"vq2008 - Vel max RPM AGO"}
    C2_CntApritens             AT %MD500.2009 : DINT;         {DE:"vq2009 - Contatore impulsi uscita apritensione"}
    C2_CntColtello             AT %MD500.2010 : DINT;         {DE:"vq2010 - Contatore impulsi uscita coltello"}
    C2_SimulaNumPoint          AT %MD500.2011 : DINT;         {DE:"vq2011 - Numero di punti simulazione"}
    C2_SimulaNumPointVel       AT %MD500.2012 : DINT;         {DE:"vq2012 - Vel [%] simulazione npoint"}
    C2_SimulaNumPointMsk       AT %MD500.2013 : DINT;         {DE:"vq2013 - Maschera simulazione npoint"}
    C2_SimulaContVbIdx         AT %MD500.2015 : DINT;         {DE:"vq2015 - Indice Vb"}
    C2_SimulaContVel1          AT %MD500.2016 : DINT;         {DE:"vq2016 - Vel [%] simulazione continua"}
    C2_SimulaContVel2          AT %MD500.2017 : DINT;         {DE:"vq2017 - Vel [%] simulazione continua"}
    C2_SimulaContVel3          AT %MD500.2018 : DINT;         {DE:"vq2018 - Vel [%] simulazione continua"}
    C2_SimulaContPt12          AT %MD500.2019 : DINT;         {DE:"vq2019 - N. punti cambio da Vel1 a Vel2"}
    C2_SimulaContPt23          AT %MD500.2020 : DINT;         {DE:"vq2020 - N. punti cambio da Vel2 a Vel3"}
    C2_SimulaContVbPedale      AT %MD500.2021 : DINT;         {DE:"vq2021 - Indice VB pedale per alta velocita'"}
    C2_SimulaContVelPedale     AT %MD500.2022 : DINT;         {DE:"vq2022 - Vel pedale alta velocita'[%] simulazione continua"}
    C2_FirstPtContext          AT %MD500.2025 : DINT;         {DE:"vq2025 - Contesto UDF per calcolo primo punto"}
    C2_FirstPtValid            AT %MD500.2026 : DINT;         {DE:"vq2026 - Flag primo punto valido"}
    C2_FirstPt_X               AT %MD500.2027 : DINT;         {DE:"vq2027 - Coordinata X del primo punto"}
    C2_FirstPt_Y               AT %MD500.2028 : DINT;         {DE:"vq2028 - Coordinata Y del primo punto"}
    C2_FirstPt_C               AT %MD500.2029 : DINT;         {DE:"vq2029 - Coordinata C iniziale"}
    C2_GantryErrAct            AT %MD500.2030 : DINT;         {DE:"vq2030 - Errore istantaneo"}
    C2_GantryErrMax            AT %MD500.2031 : DINT;         {DE:"vq2031 - Errore massimo"}
    C2_GantryErrReset          AT %MD500.2032 : DINT;         {DE:"vq2032 - Reset errore massimo"}
    C2_CalcBufContext          AT %MD500.2035 : DINT;         {DE:"vq2035 - Contesto ( dato di input )"}
    C2_CalcBufErrCode          AT %MD500.2036 : DINT;         {DE:"vq2036 - Codice di errore"}
    C2_CalcBufErrStepNum       AT %MD500.2037 : DINT;         {DE:"vq2037 - N. passo UDF dove e' avventuto l'errore"}
    C2_CalcBufErrPar           AT %MD500.2038 : DINT;         {DE:"vq2038 - Parametro aggiuntivo dell'errore"}
    C2_WarningFlg              AT %MD500.2040 : DINT;         {DE:"vq2040 - Flag Warning"}
    C2_WarningAntXMm           AT %MD500.2041 : DINT;         {DE:"vq2041 - Mm per il calcolo dell'anticipo  X"}
    C2_WarningAntXRpm          AT %MD500.2042 : DINT;         {DE:"vq2042 - RPM per il calcolo dell'anticipo X"}
    C2_WarningAntXPassoUdf     AT %MD500.2043 : DINT;         {DE:"vq2043 - Passo UDF per il calcolo dell'anticipo X"}
    C2_WarningAntYMm           AT %MD500.2044 : DINT;         {DE:"vq2044 - Mm per il calcolo dell'anticipo  Y"}
    C2_WarningAntYRpm          AT %MD500.2045 : DINT;         {DE:"vq2045 - RPM per il calcolo dell'anticipo Y"}
    C2_WarningAntYPassoUdf     AT %MD500.2046 : DINT;         {DE:"vq2046 - Passo UDF per il calcolo dell'anticipo Y"}
    C2_WarningFreqXMm          AT %MD500.2047 : DINT;         {DE:"vq2047 - Mm per il calcolo delle frequenze X"}
    C2_WarningFreqXRpm         AT %MD500.2048 : DINT;         {DE:"vq2048 - RPM per il calcolo delle frequenze X"}
    C2_WarningFreqXPassoUdf    AT %MD500.2049 : DINT;         {DE:"vq2049 - Passo UDF per il calcolo delle frequenze X"}
    C2_WarningFreqYMm          AT %MD500.2050 : DINT;         {DE:"vq2050 - Mm per il calcolo delle frequenze Y"}
    C2_WarningFreqYRpm         AT %MD500.2051 : DINT;         {DE:"vq2051 - RPM per il calcolo delle frequenze Y"}
    C2_WarningFreqYPassoUdf    AT %MD500.2052 : DINT;         {DE:"vq2052 - Passo UDF per il calcolo delle frequenze Y"}
    C2_CntBloccoFiloINI        AT %MD500.2053 : DINT;         {DE:"vq2053 - Contatore impulsi uscita BloccoFiloINI"}
    C2_CntBloccoFiloEND        AT %MD500.2054 : DINT;         {DE:"vq2054 - Contatore impulsi uscita BloccoFiloEND"}
    C2_Fun74_RetCode           AT %MD500.2060 : DINT;         {DE:"vq2060 - RetCode"}
    C2_Fun74_QuoObj            AT %MD500.2061 : DINT;         {DE:"vq2061 - Quota obiettivo"}
    C2_Fun74_VelObj            AT %MD500.2062 : DINT;         {DE:"vq2062 - Velocita'"}
    C2_Fun74_Future            AT %MD500.2063 : DINT;         {DE:"vq2063 - Future"}
    C2_Fun74_Acc               AT %MD500.2063 : DINT;         {DE:"vq2063 - Accelerazione ( polinomio grado 5 )"}
    C2_Fun74_Tmov              AT %MD500.2064 : DINT;         {DE:"vq2064 - Tempo di movimento ( polinomio grado 5 )"}
    C2_Fun74_Offs              AT %MD500.2065 : DINT;         {DE:"vq2065 - Offset anticipo start ( polinomio grado 5 )"}
    C2_FaseAxAgo               AT %MD500.2070 : DINT;         {DE:"vq2070 - Fase asse ago"}
    C2_FaseAxC                 AT %MD500.2071 : DINT;         {DE:"vq2071 - Fase asse C"}
    C2_CmdQuoAbsRet            AT %MD500.2075 : DINT;         {DE:"vq2075 - RetCode"}
    C2_CmdQuoAbsX              AT %MD500.2076 : DINT;         {DE:"vq2076 - QuoAbs X"}
    C2_CmdQuoAbsY              AT %MD500.2077 : DINT;         {DE:"vq2077 - QuoAbs Y"}
    C2_CmdQuoAbsC              AT %MD500.2078 : DINT;         {DE:"vq2078 - QuoAbs C"}
    C2_RpmAgoInProfilo         AT %MD500.2100 : DINT;         {DE:"vq2100 - Rpm ago impostati da istruzione del profile ( Vcd1 )"}
    C2_TensioneInProfilo       AT %MD500.2101 : DINT;         {DE:"vq2101 - tensione impostata da istruzione del profile ( Vcd2 )"}
    C2_VelRiduzioneRPM         AT %MD500.2110 : DINT;         {DE:"vq2110 - Ulteriore limite RPM Ago ( #M200710_1GF# )"}
    C2_CmdMoveAxC              AT %MD500.2120 : DINT;         {DE:"vq2120 - Comando di movimento asse C"}
    C2_QuoObjAxC               AT %MD500.2121 : DINT;         {DE:"vq2121 - Quota obiettivo asse C"}
    C2_NumPtMoveAxC            AT %MD500.2122 : DINT;         {DE:"vq2122 - Punti di cucitura - movimento asse C"}
    C2_RpmMoveAxC              AT %MD500.2123 : DINT;         {DE:"vq2123 - Rpm ago durante il movimento dell'asse C"}
    C2_IrqNumMoveAxC           AT %MD500.2124 : DINT;         {DE:"vq2124 - IrqNumber interpretazione movimento dell'asse C"}
    C2_IrqCnt                  AT %MD500.2127 : DINT;         {DE:"vq2127 - Contatore Irq ( Fun 281 cmd 63 )"}
    C2_MovePlcAxCErrCode       AT %MD500.2130 : DINT;         {DE:"vq2130 - Mov. asse C - ErrorCode"}
    C2_MovePlcAxCQuoObj        AT %MD500.2131 : DINT;         {DE:"vq2131 - Mov. asse C - Quota obiettivo"}
    C2_MovePlcAxCVel           AT %MD500.2132 : DINT;         {DE:"vq2132 - Mov. asse C - Velocita'"}
    C2_MovePlcAxCAcc           AT %MD500.2133 : DINT;         {DE:"vq2133 - Mov. asse C - Accelerazione"}
    C2_MovePlcAxCTime          AT %MD500.2134 : DINT;         {DE:"vq2134 - Mov. asse C - Tempo di movimento"}
    C2_MovePlcAxCAnt           AT %MD500.2135 : DINT;         {DE:"vq2135 - Mov. asse C - Anticipo"}
    C2_InfoCntPunti            AT %MD500.2651 : DINT;         {DE:"vq2651 - Contatore punti di cucitura"}
    C2_InfoAnticipoMm          AT %MD500.2652 : DINT;         {DE:"vq2652 - Mm per il calcolo dell'anticipo"}
    C2_InfoAnticipoRpm         AT %MD500.2653 : DINT;         {DE:"vq2653 - RPM per il calcolo dell'anticipo"}
    C2_InfoAnticipoPassoUdf    AT %MD500.2654 : DINT;         {DE:"vq2654 - Passo UDF per il calcolo dell'anticipo"}
    C2_InfoFreqXMm             AT %MD500.2655 : DINT;         {DE:"vq2655 - Mm per il calcolo delle frequenze X"}
    C2_InfoFreqXRpm            AT %MD500.2656 : DINT;         {DE:"vq2656 - RPM per il calcolo delle frequenze X"}
    C2_InfoFreqXPassoUdf       AT %MD500.2657 : DINT;         {DE:"vq2657 - Passo UDF per il calcolo delle frequenze X"}
    C2_InfoFreqYMm             AT %MD500.2658 : DINT;         {DE:"vq2658 - Mm per il calcolo delle frequenze Y"}
    C2_InfoFreqYRpm            AT %MD500.2659 : DINT;         {DE:"vq2659 - RPM per il calcolo delle frequenze Y"}
    C2_InfoFreqYPassoUdf       AT %MD500.2660 : DINT;         {DE:"vq2660 - Passo UDF per il calcolo delle frequenze Y"}
    C2_SogliaStart             AT %MD500.2701 : DINT;         {DE:"vq2701 - Soglia start movimento [gradi]"}
    C2_SogliaStop              AT %MD500.2702 : DINT;         {DE:"vq2702 - Soglia stop  movimento [gradi]"}
    C2_AgoAlto                 AT %MD500.2703 : DINT;         {DE:"vq2703 - Ago alto [gradi]"}
    C2_StartApriTens           AT %MD500.2704 : DINT;         {DE:"vq2704 - Start camma apritensione [gradi]"}
    C2_StopApriTens            AT %MD500.2705 : DINT;         {DE:"vq2705 - Stop  camma apritensione [gradi]"}
    C2_StartColtello           AT %MD500.2706 : DINT;         {DE:"vq2706 - Start camma coltello [gradi]"}
    C2_StopColtello            AT %MD500.2707 : DINT;         {DE:"vq2707 - Stop  camma coltello [gradi]"}
    C2_TSalitaPiedino          AT %MD500.2708 : DINT;         {DE:"vq2708 - Tempo salita piedino [s]"}
    C2_TDiscesaPiedino         AT %MD500.2709 : DINT;         {DE:"vq2709 - Tempo discesa piedino [s]"}
    C2_ParVelLavRPM            AT %MD500.2710 : DINT;         {DE:"vq2710 - Vel. lavoro ago [RPM]"}
    C2_ParPuntiVelIni          AT %MD500.2711 : DINT;         {DE:"vq2711 - Punti iniziali (no fix3)"}
    C2_ParVelIniRPM            AT %MD500.2712 : DINT;         {DE:"vq2712 - Vel iniziale ago [RPM]"}
    C2_ParPuntiVelRall         AT %MD500.2713 : DINT;         {DE:"vq2713 - Punti rallentamento (no fix3)"}
    C2_ParVelRallRPM           AT %MD500.2714 : DINT;         {DE:"vq2714 - Vel rallentamento ago [RPM]"}
    C2_StopAgo                 AT %MD500.2715 : DINT;         {DE:"vq2715 - Quota stop dell'ago (prima del movimento ad ago alto)"}
    C2_OffsetAgoTacca          AT %MD500.2716 : DINT;         {DE:"vq2716 - Offset di fase tran la quota dell'ago e la tacca di zero"}
    C2_Par_FeedG0Reset         AT %MD500.2717 : DINT;         {DE:"vq2717 - Feed nei movimenti G0 per azzeramento o reset [mm/min] fix3"}
    C2_StartBloccoFiloINI      AT %MD500.2718 : DINT;         {DE:"vq2718 - Start camma blocco filo inizio cucitura [gradi]"}
    C2_StopBloccoFiloINI       AT %MD500.2719 : DINT;         {DE:"vq2719 - Stop camma blocco filo inizio cucitura [gradi]"}
    C2_StartBloccoFiloEND      AT %MD500.2720 : DINT;         {DE:"vq2720 - Start camma blocco filo fine cucitura [gradi]"}
    C2_StopBloccoFiloEND       AT %MD500.2721 : DINT;         {DE:"vq2721 - Stop camma blocco filo fine cucitura [gradi]"}
    C2_ParVelRotazione         AT %MD500.2722 : DINT;         {DE:"vq2722 - Velocita' asse C rotazione [%] fix3 movimento iniziale"}
    C2_Par_23                  AT %MD500.2723 : DINT;         {DE:"vq2723"}
    C2_Par_24                  AT %MD500.2724 : DINT;         {DE:"vq2724"}
    C2_Par_25                  AT %MD500.2725 : DINT;         {DE:"vq2725"}
    C2_Par_26                  AT %MD500.2726 : DINT;         {DE:"vq2726"}
    C2_Par_27                  AT %MD500.2727 : DINT;         {DE:"vq2727"}
    C2_Par_28                  AT %MD500.2728 : DINT;         {DE:"vq2728"}
    C2_Par_29                  AT %MD500.2729 : DINT;         {DE:"vq2729"}
    C2_Par_30                  AT %MD500.2730 : DINT;         {DE:"vq2730"}
    C2_Par_31                  AT %MD500.2731 : DINT;         {DE:"vq2731"}
    C2_Par_32                  AT %MD500.2732 : DINT;         {DE:"vq2732"}
    C2_Par_33                  AT %MD500.2733 : DINT;         {DE:"vq2733"}
    C2_Par_34                  AT %MD500.2734 : DINT;         {DE:"vq2734"}
    C2_Par_35                  AT %MD500.2735 : DINT;         {DE:"vq2735"}
    C2_Par_36                  AT %MD500.2736 : DINT;         {DE:"vq2736"}
    C2_Par_37                  AT %MD500.2737 : DINT;         {DE:"vq2737"}
    C2_Par_38                  AT %MD500.2738 : DINT;         {DE:"vq2738"}
    C2_Par_39                  AT %MD500.2739 : DINT;         {DE:"vq2739"}
    C2_Par_40                  AT %MD500.2740 : DINT;         {DE:"vq2740"}
    C2_TabSpostamentoMm        AT %MD500.2851 : DINT;         {DE:"vq2851 - Spostamento [mm]"}
    C2_TabVelAgoRPM            AT %MD500.2852 : DINT;         {DE:"vq2852 - Vel. ago [RPM]"}
    C2_AnticipoX               AT %MD500.2853 : DINT;         {DE:"vq2853 - Anticipo start stop X [gradi]"}
    C2_AnticipoY               AT %MD500.2854 : DINT;         {DE:"vq2854 - Anticipo start stop Y [gradi]"}
    C2_FrqLavX                 AT %MD500.2855 : DINT;         {DE:"vq2855 - Frequenza di lavoro X [KHz]"}
    C2_StpAccX                 AT %MD500.2856 : DINT;         {DE:"vq2856 - Step di accelerazione X"}
    C2_FrqAccX                 AT %MD500.2857 : DINT;         {DE:"vq2857 - Frequenza accelerazione X [KHz]"}
    C2_StpDecX                 AT %MD500.2858 : DINT;         {DE:"vq2858 - Step di decelerazione X"}
    C2_FrqDecX                 AT %MD500.2859 : DINT;         {DE:"vq2859 - Frequenza decelerazione X [KHz]"}
    C2_FrqLavY                 AT %MD500.2860 : DINT;         {DE:"vq2860 - Frequenza di lavoro Y [KHz]"}
    C2_StpAccY                 AT %MD500.2861 : DINT;         {DE:"vq2861 - Step di accelerazione Y"}
    C2_FrqAccY                 AT %MD500.2862 : DINT;         {DE:"vq2862 - Frequenza accelerazione Y [KHz]"}
    C2_StpDecY                 AT %MD500.2863 : DINT;         {DE:"vq2863 - Step di decelerazione Y"}
    C2_FrqDecY                 AT %MD500.2864 : DINT;         {DE:"vq2864 - Frequenza decelerazione Y [KHz]"}
    C2_BaseParam1              AT %MD500.2901 : DINT;         {DE:"vq2901 - Parametro 1"}
    C2_BaseParam2              AT %MD500.2902 : DINT;         {DE:"vq2902 - Parametro 2"}
    C2_QuoHomeX                AT %MD500.2911 : DINT;         {DE:"vq2911 - Quota Home X"}
    C2_QuoHomeY                AT %MD500.2912 : DINT;         {DE:"vq2912 - Quota Home Y"}
    C2_UdfVelLavRPM            AT %MD500.2913 : DINT;         {DE:"vq2913 - Vel lavoro ago [RPM]"}
    C2_UdfPuntiVelIni          AT %MD500.2914 : DINT;         {DE:"vq2914 - Punti iniziali (no fix3)"}
    C2_UdfVelIniRPM            AT %MD500.2915 : DINT;         {DE:"vq2915 - Vel iniziale ago [RPM]"}
    C2_UdfPuntiVelRall         AT %MD500.2916 : DINT;         {DE:"vq2916 - Punti rallentamento (no fix3)"}
    C2_UdfVelRallRPM           AT %MD500.2917 : DINT;         {DE:"vq2917 - Vel rallentamento ago [RPM]"}
    C2_Udf_FeedG0              AT %MD500.2918 : DINT;         {DE:"vq2918 - Feed nei movimenti G0 [mm/min] fix3"}
    C2_Udf_ValTensione         AT %MD500.2919 : DINT;         {DE:"vq2919 - Valore Tensione Testa 1 ( non utilizzato )"}
    C2_Udf_20                  AT %MD500.2920 : DINT;         {DE:"vq2920"}
    C2_Udf_ValEletSopra        AT %MD500.2921 : DINT;         {DE:"vq2921 - Valore Uscita magnete Sopra ( non utilizzato )"}
    C2_Udf_ValEletSotto        AT %MD500.2922 : DINT;         {DE:"vq2922 - Valore Uscita magnete Sotto  ( non utilizzato )"}
    C2_Udf_23                  AT %MD500.2923 : DINT;         {DE:"vq2923"}
    C2_Udf_24                  AT %MD500.2924 : DINT;         {DE:"vq2924"}
    C2_Udf_25                  AT %MD500.2925 : DINT;         {DE:"vq2925"}
    C2_Udf_26                  AT %MD500.2926 : DINT;         {DE:"vq2926"}
    C2_Udf_27                  AT %MD500.2927 : DINT;         {DE:"vq2927"}
    C2_Udf_28                  AT %MD500.2928 : DINT;         {DE:"vq2928"}
    C2_Udf_29                  AT %MD500.2929 : DINT;         {DE:"vq2929"}
    C2_Udf_30                  AT %MD500.2930 : DINT;         {DE:"vq2930"}
    C2_VqTotPntCuci            AT %MD500.2951 : DINT;         {DE:"vq2951 - Punti totali cucitura"}
    C2_VqActPntCuci            AT %MD500.2952 : DINT;         {DE:"vq2952 - Punto corrente cucitura"}
    C2_VqEncImpCuci            AT %MD500.2953 : DINT;         {DE:"vq2953 - Lettura encoder ago [imp]"}
    C2_VqEncMmCuci             AT %MD500.2954 : DINT;         {DE:"vq2954 - Lettura encoder ago [mm]"}
    C2_VqRpmAgoCuci            AT %MD500.2955 : DINT;         {DE:"vq2955 - Velocita' ago [RPM]"}
    C2_VqActStartCuci          AT %MD500.2956 : DINT;         {DE:"vq2956 - Lettura quota start [gradi] (con anticipo)"}
    C2_VqActStopCuci           AT %MD500.2957 : DINT;         {DE:"vq2957 - Lettura quota stop  [gradi] (con anticipo)"}
    C2_VqAgoStartCuci          AT %MD500.2958 : DINT;         {DE:"vq2958 - Lettura hw quota start [gradi]"}
    C2_VqAgoStopCuci           AT %MD500.2959 : DINT;         {DE:"vq2959 - Lettura hw quota stop  [gradi]"}
    C2_VqTotParzPnt            AT %MD500.2960 : DINT;         {DE:"vq2960 - N. punti cucitura parziale"}
    C2_VqActParzPnt            AT %MD500.2961 : DINT;         {DE:"vq2961 - Punto corrente cucitura parziale"}
    C2_VelFeed                 AT %MD500.2962 : DINT;         {DE:"vq2962 - Velocità esecuzione Feed"}

END_VAR

VAR_GLOBAL CONSTANT


    {G:"Application_Constant"}

    C1_PROFILO_CNTX            : INT := 1; { DE:"Cucitrice 1 - contesto profilo udf di cucitura" }
    C2_PROFILO_CNTX            : INT := 2; { DE:"Cucitrice 2 - contesto profilo udf di cucitura" }
    C1_PAR_CNTX                : INT := 3; { DE:"Cucitrice 1 - contesto parametri ( C1_Param.udf )" }
    C2_PAR_CNTX                : INT := 4; { DE:"Cucitrice 2 - contesto parametri ( C2_Param.udf )" }
    C1_PAR_BASE_MTX            : INT := 101; { DE:"Matrice di base dei parametri ( C1_Param.udf )" }
    C1_TAB_BASE_MTX            : INT := 102; { DE:"Matrice di base del tabellone dei parametri dinamici" }
    C1_PROF_BASE_MTX           : INT := 111; { DE:"Matrice di base del profilo udf di cucitura" }
    C1_PROF_HDR_MTX            : INT := 112; { DE:"Matrice di header del profilo udf di cucitura" }
    C2_PAR_BASE_MTX            : INT := 201; { DE:"Matrice di base dei parametri ( C2_Param.udf )" }
    C2_TAB_BASE_MTX            : INT := 202; { DE:"Matrice di base del tabellone dei parametri dinamici" }
    C2_PROF_BASE_MTX           : INT := 211; { DE:"Matrice di base del profilo udf di cucitura" }
    C2_PROF_HDR_MTX            : INT := 212; { DE:"Matrice di header del profilo udf di cucitura" }
    C1_SIMULA_AVA_CONT_IDX     : INT := 1022;
    C1_SIMULA_IND_CONT_IDX     : INT := 1023;
    C1_AGO_FUORI_ING_IDX       : INT := 1030;
    C1_FLG_CUCI_OR_MOVE_IDX    : INT := 1033;
    C1_AGO_ALTO_STOP_IDX       : INT := 1037;
    C1_FLG_G280_RUNNING_IDX    : INT := 1038;
    C1_FLG_JTASK_INFO_IDX      : INT := 1041;
    C1_STATUS_WORD_BIT_IDX     : INT := 1850; { DE:"STATUS_WORD_BIT_IDX" }
    C2_SIMULA_AVA_CONT_IDX     : INT := 2022;
    C2_SIMULA_IND_CONT_IDX     : INT := 2023;
    C2_AGO_FUORI_ING_IDX       : INT := 2030;
    C2_FLG_CUCI_OR_MOVE_IDX    : INT := 2033;
    C2_AGO_ALTO_STOP_IDX       : INT := 2037;
    C2_FLG_G280_RUNNING_IDX    : INT := 2038;
    C2_FLG_JTASK_INFO_IDX      : INT := 2041;
    C2_STATUS_WORD_BIT_IDX     : INT := 2850; { DE:"STATUS_WORD_BIT_IDX" }
    C1_TAB_CONTEXT_IDX         : INT := 1001;
    C1_RD_NEXT_CODE_IDX        : INT := 1010;
    C1_WRITE_PAR_IDX           : INT := 1011;
    C1_SDO_ERRCODE_IDX         : INT := 1680; { DE:"Servizio SDO - ErrorCode" }
    C1_SDO_RW_PAR_IDX          : INT := 1681; { DE:"Servizio SDO - Parametri" }
    C1_VN_STATUS_CUCI_IDX      : INT := 1952; { DE:"Status cucitrice" }
    C2_TAB_CONTEXT_IDX         : INT := 2001;
    C2_RD_NEXT_CODE_IDX        : INT := 2010;
    C2_WRITE_PAR_IDX           : INT := 2011;
    C2_VN_STATUS_CUCI_IDX      : INT := 2952; { DE:"Status cucitrice" }
    C1_SIMULA_NPOINT_IDX       : INT := 1011;
    C1_SIMULA_CONT_IDX         : INT := 1015;
    C1_FIRST_PT_IDX            : INT := 1025;
    C1_GANTRY_INFO_IDX         : INT := 1030;
    C1_CALC_BUF_IDX            : INT := 1035;
    C1_WARNING_INFO_IDX        : INT := 1040;
    C1_FUN74_IDX               : INT := 1060;
    C1_FASE_AX_AGO_IDX         : INT := 1070;
    C1_FASE_AX_C_IDX           : INT := 1071;
    C1_CMD_QUO_ABS_IDX         : INT := 1075;
    C1_RPM_AGO_PROFILO_IDX     : INT := 1100;
    C1_TENSIONE_PROFILO_IDX    : INT := 1101;
    C1_CMD_MOVE_AX_C_IDX       : INT := 1120;
    C1_CMD_GET_IRQ_CNT_IDX     : INT := 1127;
    C1_MOVE_PLC_AX_C_IDX       : INT := 1130;
    C1_SDO_VQ_DATA_IDX         : INT := 1690; { DE:"Servizio SDO - Vq dato letto o da scrivere" }
    C1_SGL_START_STOP_IDX      : INT := 1701;
    C1_OFFSET_AGO_TACCA_IDX    : INT := 1716;
    C1_FEED_G0_IDX             : INT := 1918; { DE:"Indice Vq Feed movimento G0" }
    C2_SIMULA_NPOINT_IDX       : INT := 2011;
    C2_SIMULA_CONT_IDX         : INT := 2015;
    C2_FIRST_PT_IDX            : INT := 2025;
    C2_GANTRY_INFO_IDX         : INT := 2030;
    C2_CALC_BUF_IDX            : INT := 2035;
    C2_WARNING_INFO_IDX        : INT := 2040;
    C2_FUN74_IDX               : INT := 2060;
    C2_FASE_AX_AGO_IDX         : INT := 2070;
    C2_FASE_AX_C_IDX           : INT := 2071;
    C2_CMD_QUO_ABS_IDX         : INT := 2075;
    C2_RPM_AGO_PROFILO_IDX     : INT := 2100;
    C2_TENSIONE_PROFILO_IDX    : INT := 2101;
    C2_CMD_MOVE_AX_C_IDX       : INT := 2120;
    C2_CMD_GET_IRQ_CNT_IDX     : INT := 2127;
    C2_MOVE_PLC_AX_C_IDX       : INT := 2130;
    C2_SGL_START_STOP_IDX      : INT := 2701;
    C2_OFFSET_AGO_TACCA_IDX    : INT := 2716;
    C2_FEED_G0_IDX             : INT := 2918; { DE:"Indice Vq Feed movimento G0" }

END_VAR
]]>
			</lib>
		</libraries>
		<aux/>
	</sources>
	<codegen crossReference="false" crossReferenceOptions="0x3000001D" listing="true" saveEXPFile="true" saveEXPFileLibraries="false" saveTargetFiles="true" warningEnable="true" symMap="true" checkIndexType="false" waitExtension="false" allocateUnusedVariables="false" checkArrayBounds="false" checkDivisionByZero="false" checkPointers="1" checkReferences="false" checkInterfaces="false" ioVarsAsReferences="false" customTargetBINFileName="Cuci.bin" customTargetTSCFileName="Cuci_source.bin" customTargetTDSFileName="Cuci_debug.bin" generateCustomFilesName="false" initFunVarsWithZero="false">
		<disabledWarnings/>
		<applicationDataBlocks/>
	</codegen>
	<simWorkspaces/>
	<debug watchRefresh="20" watchVarRefresh="0" watchMaxArray="20" autoSaveWatchList="false" watchFBLocalVars="false"/>
	<editor useOldGridSize="false"/>
	<userDef>
		<release>Cuci</release>
		<author/>
		<note/>
		<version/>
		<password disabled="false"/>
	</userDef>
	<downloadSequence sourceCode="onPLCApplicationDownload" debugSymbols="onPLCApplicationDownload"/>
	<commands>
		<postbuild>"%APPLPATH%\CmpAlPlc" %PRJBASENAME% %PRJPATH%</postbuild>
		<postdown/>
		<predown/>
	</commands>
	<resources/>
</plcProject>